{
  "version": 3,
  "sources": ["../src/index.ts", "../src/redirect.ts"],
  "sourcesContent": ["import type { EventEmitter } from \"events\";\nimport type { Request, Response, NextFunction } from \"express\";\nimport {\n  kCSPNonce,\n  redirectWithMidstreamSupport,\n  ResponseWithInternals,\n} from \"./redirect\";\n\n// newer versions of `@types/express`\ndeclare module \"express-serve-static-core\" {\n  interface Response {\n    marko: typeof renderMarkoTemplate;\n  }\n}\n\n// older versions of `@types/express`\ndeclare module \"express\" {\n  interface Response {\n    marko: typeof renderMarkoTemplate;\n  }\n}\n\nexport default function middleware() {\n  return (_req: Request, res: Response, next: NextFunction): void => {\n    res.marko = renderMarkoTemplate;\n    // We don't have a handle to the cspNonce, if any so we start with\n    // a default function which may generate a script with no nonce attr\n    res.redirect = redirectWithMidstreamSupport;\n    next();\n  };\n}\n\nfunction renderMarkoTemplate<\n  I extends Record<string, unknown> & { $global?: Record<string, unknown> },\n  T extends { render(input: I, ...args: unknown[]): EventEmitter }\n>(this: ResponseWithInternals, template: T, input?: I) {\n  const $global = { ...this.app.locals, ...this.locals };\n\n  if (input) {\n    if (input.$global) {\n      Object.assign($global, input.$global);\n    }\n\n    input.$global = $global;\n  }\n\n  this[kCSPNonce] = $global.cspNonce;\n  this.set(\"Content-Type\", \"text/html; charset=utf-8\");\n  template\n    .render(input || ({ $global } as I), this)\n    .on(\"error\", this.req!.next!);\n}\n", "import type { Response } from \"express\";\nimport { ServerResponse } from \"http\";\n\nexport const kCSPNonce = Symbol(\"cspNonce\");\nconst kOnWriteFlush = Symbol(\"on-flush\");\n\nexport interface ResponseWithInternals extends Response {\n  [kCSPNonce]?: string;\n  [kOnWriteFlush]?: (this: ResponseWithInternals) => void;\n}\n\nexport function redirectWithMidstreamSupport(\n  this: ResponseWithInternals,\n  status: number,\n  redirectUrl: string\n): void;\nexport function redirectWithMidstreamSupport(\n  this: ResponseWithInternals,\n  redirectUrl: string,\n  status: number\n): void;\nexport function redirectWithMidstreamSupport(\n  this: ResponseWithInternals,\n  redirectUrl: string\n): void;\nexport function redirectWithMidstreamSupport(\n  this: ResponseWithInternals,\n  p1: string | number,\n  p2?: string | number\n) {\n  const status = typeof p1 === \"number\" ? p1 : 302;\n  const redirectUrl = typeof p1 === \"string\" ? p1 : (p2 as string);\n  const nonce = this[kCSPNonce]\n    ? ` nonce=${JSON.stringify(this[kCSPNonce])}`\n    : \"\";\n\n  if (\n    this.headersSent &&\n    (this.getHeader(\"Content-Type\") as string | undefined)?.startsWith(\n      \"text/html\"\n    )\n  ) {\n    // already begun response, so we can't redirect with a status code\n    // but it is text/html, so we can redirect using <meta> refresh or location.href\n    // and destroy the stream once the response is flushed\n    this[kOnWriteFlush] = this.destroy;\n    this.write(`\n        <meta http-equiv=refresh content=${JSON.stringify(\n          `0;url=${redirectUrl}`\n        )}>\n        <script${nonce}>location.href=${JSON.stringify(redirectUrl)}</script>\n      `);\n\n    // special case: compression\n    // ensure the redirect is flushed when compression middleware is used\n    if (this.flush) this.flush();\n\n    // prevent any further output\n    this.write = noopTrue;\n    this.flush = this.end = noopThis;\n  } else {\n    // use the default redirect behavior\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    Object.getPrototypeOf(this).redirect.call(this, status, redirectUrl);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noopThis(this: any) {\n  return this;\n}\n\nfunction noopTrue() {\n  return true;\n}\n\n// we want to know when the write is flushed\n// but monkeypatching is so common in the express ecosystem that we can't rely on the callback\n// specifically, compression middleware omits the callback\nconst _write = ServerResponse.prototype.write;\nServerResponse.prototype.write = function (\n  this: ResponseWithInternals,\n  data: any,\n  encoding: any,\n  callback: any\n) {\n  if (!this[kOnWriteFlush]) return _write.call(this, data, encoding, callback);\n\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = \"utf8\";\n  }\n\n  return _write.call(this, data, encoding, () => {\n    this[kOnWriteFlush]!();\n    callback?.();\n  });\n} as any;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,kBAA+B;AAExB,IAAM,YAAY,OAAO,UAAU;AAC1C,IAAM,gBAAgB,OAAO,UAAU;AAqBhC,sCAEL,IACA,IACA;AA7BF;AA8BE,QAAM,SAAS,OAAO,OAAO,WAAW,KAAK;AAC7C,QAAM,cAAc,OAAO,OAAO,WAAW,KAAM;AACnD,QAAM,QAAQ,KAAK,aACf,UAAU,KAAK,UAAU,KAAK,UAAU,MACxC;AAEJ,MACE,KAAK,eACJ,YAAK,UAAU,cAAc,MAA7B,mBAAuD,WACtD,eAEF;AAIA,SAAK,iBAAiB,KAAK;AAC3B,SAAK,MAAM;AAAA,2CAC4B,KAAK,UACtC,SAAS,aACX;AAAA,iBACS,uBAAuB,KAAK,UAAU,WAAW;AAAA,OAC3D;AAIH,QAAI,KAAK;AAAO,WAAK,MAAM;AAG3B,SAAK,QAAQ;AACb,SAAK,QAAQ,KAAK,MAAM;AAAA,EAC1B,OAAO;AAGL,WAAO,eAAe,IAAI,EAAE,SAAS,KAAK,MAAM,QAAQ,WAAW;AAAA,EACrE;AACF;AAGA,oBAA6B;AAC3B,SAAO;AACT;AAEA,oBAAoB;AAClB,SAAO;AACT;AAKA,IAAM,SAAS,2BAAe,UAAU;AACxC,2BAAe,UAAU,QAAQ,SAE/B,MACA,UACA,UACA;AACA,MAAI,CAAC,KAAK;AAAgB,WAAO,OAAO,KAAK,MAAM,MAAM,UAAU,QAAQ;AAE3E,MAAI,OAAO,aAAa,YAAY;AAClC,eAAW;AACX,eAAW;AAAA,EACb;AAEA,SAAO,OAAO,KAAK,MAAM,MAAM,UAAU,MAAM;AAC7C,SAAK,eAAgB;AACrB;AAAA,EACF,CAAC;AACH;;;AD3Ee,sBAAsB;AACnC,SAAO,CAAC,MAAe,KAAe,SAA6B;AACjE,QAAI,QAAQ;AAGZ,QAAI,WAAW;AACf,SAAK;AAAA,EACP;AACF;AAEA,6BAG+B,UAAa,OAAW;AACrD,QAAM,UAAU,EAAE,GAAG,KAAK,IAAI,QAAQ,GAAG,KAAK,OAAO;AAErD,MAAI,OAAO;AACT,QAAI,MAAM,SAAS;AACjB,aAAO,OAAO,SAAS,MAAM,OAAO;AAAA,IACtC;AAEA,UAAM,UAAU;AAAA,EAClB;AAEA,OAAK,aAAa,QAAQ;AAC1B,OAAK,IAAI,gBAAgB,0BAA0B;AACnD,WACG,OAAO,SAAU,EAAE,QAAQ,GAAS,IAAI,EACxC,GAAG,SAAS,KAAK,IAAK,IAAK;AAChC;",
  "names": []
}
