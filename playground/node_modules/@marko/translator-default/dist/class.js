"use strict";exports.__esModule = true;exports.default = _default;var _compiler = require("@marko/compiler");

function _default(path) {
  const {
    hub: { file },
    node: {
      body: { body }
    }
  } = path;

  const classProperties = [];
  let onCreateMethod = body.find(
    (prop) =>
    prop.computed === false &&
    _compiler.types.isIdentifier(prop.key) &&
    prop.key.name === "onCreate"
  );

  const objectProperties = body.
  map((prop) => {
    if (_compiler.types.isClassMethod(prop)) {
      prop.type = "ObjectMethod";
      delete prop.start;
      delete prop.end;
      delete prop.loc;
      return prop;
    } else if (_compiler.types.isClassProperty(prop) && !prop.static) {
      if (!prop.declare) {
        classProperties.push(
          _compiler.types.assignmentExpression(
            "=",
            _compiler.types.memberExpression(_compiler.types.thisExpression(), prop.key, prop.computed),
            prop.value || _compiler.types.unaryExpression("void", _compiler.types.numericLiteral(0))
          )
        );
      }

      return undefined;
    }

    throw file.buildCodeFrameError(
      prop,
      "Unsupported class property on component."
    );
  }).
  filter(Boolean);

  if (classProperties.length) {
    if (!onCreateMethod) {
      objectProperties.push(
        onCreateMethod = _compiler.types.objectMethod(
          "method",
          _compiler.types.identifier("onCreate"),
          [],
          _compiler.types.blockStatement([])
        )
      );
    }

    onCreateMethod.body.body.unshift(...classProperties);
  }

  file._inlineComponentClass = _compiler.types.objectExpression(objectProperties);
  path.remove();
}