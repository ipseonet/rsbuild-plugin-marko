"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = _default;var _babelUtils = require("@marko/babel-utils");




var _compiler = require("@marko/compiler");
var _attr = _interopRequireDefault(require("marko/src/runtime/html/helpers/attr"));
var _escapeQuotes = require("marko/src/runtime/html/helpers/escape-quotes");

var _util = require("../util");

function _default(path, attrs) {
  const len = attrs.length;
  if (len === 0) return _compiler.types.stringLiteral("");
  if (len === 1 && attrs[0].node.type === "MarkoSpreadAttribute") {
    return _compiler.types.callExpression(
      (0, _babelUtils.importDefault)(
        path.hub.file,
        "marko/src/runtime/html/helpers/attrs.js",
        "marko_attrs"
      ),
      [attrs[0].node.value]
    );
  }

  if (attrs.some((attr) => attr.node.type === "MarkoSpreadAttribute")) {
    const attrsObjects = [];
    let props;

    for (let i = 0; i < len; i++) {
      const attr = attrs[i];
      const {
        node: { name, value }
      } = attr;

      if (name) {
        const computed = (0, _util.evaluateAttr)(attr);
        const prop = _compiler.types.objectProperty(
          _compiler.types.stringLiteral(name),
          computed?.value !== undefined ?
          _compiler.types.stringLiteral(computed.value) :
          value
        );
        if (props) {
          props.push(prop);
        } else {
          attrsObjects.push(_compiler.types.objectExpression(props = [prop]));
        }
      } else {
        attrsObjects.push(value);
        props = undefined;
      }
    }

    return _compiler.types.callExpression(
      (0, _babelUtils.importDefault)(
        path.hub.file,
        "marko/src/runtime/html/helpers/merge-attrs.js",
        "marko_merge_attrs"
      ),
      attrsObjects
    );
  }

  const file = path.hub.file;
  const quasis = [];
  const expressions = [];
  const attrValues = new Map();
  let curString = "";

  // Remove duplicate attrs so last one wins.
  for (let i = len; i--;) {
    const attr = attrs[i];
    const { name, value } = attr.node;
    if (attrValues.has(name)) continue;
    const computed = (0, _util.evaluateAttr)(attr);
    attrValues.set(
      name,
      computed ?
      {
        confident: true,
        computed: computed.value,
        value
      } :
      {
        confident: false,
        computed: undefined,
        value
      }
    );
  }

  for (const [name, { confident, computed, value }] of [
  ...attrValues].
  reverse()) {
    if (confident) {
      if (computed == null || computed === false) {
        continue;
      }

      curString += (0, _attr.default)(name, computed);
    } else if (value.type === "TemplateLiteral") {
      curString += " " + name + '="';

      for (let i = 0; i < value.expressions.length; i++) {
        const quasi = value.quasis[i];
        const expression = value.expressions[i];
        curString += (0, _escapeQuotes.d)(quasi.value.cooked);
        quasis.push(curString);
        curString = "";
        expressions.push(
          _compiler.types.callExpression(
            (0, _babelUtils.importNamed)(
              file,
              "marko/src/runtime/html/helpers/escape-quotes.js",
              "d",
              "marko_escape_double_quotes"
            ),
            [expression]
          )
        );
      }

      curString +=
      (0, _escapeQuotes.d)(
        value.quasis[value.expressions.length].value.cooked
      ) + '"';
    } else {
      quasis.push(curString);
      curString = "";
      expressions.push(
        _compiler.types.callExpression(
          (0, _babelUtils.importDefault)(
            file,
            "marko/src/runtime/html/helpers/attr.js",
            "marko_attr"
          ),
          [_compiler.types.stringLiteral(name), value]
        )
      );
    }
  }

  quasis.push(curString);

  if (expressions.length) {
    return (0, _babelUtils.normalizeTemplateString)(quasis, ...expressions);
  } else {
    return _compiler.types.stringLiteral(quasis.join(""));
  }
}