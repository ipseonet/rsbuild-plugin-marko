"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = _default;var _babelUtils = require("@marko/babel-utils");




var _compiler = require("@marko/compiler");

var _getComponentFiles = _interopRequireDefault(require("../../util/get-component-files"));

function _default(path) {
  const {
    node,
    hub: { file }
  } = path;
  const {
    rawValue: code,
    name: { start, end }
  } = node;
  const meta = file.metadata.marko;

  if (meta.hasComponent) {
    (0, _babelUtils.diagnosticError)(path.get("name"), {
      label: "A Marko component can only have one top level class."
    });
    path.remove();
    return;
  }

  meta.hasComponent = true;

  if ((0, _getComponentFiles.default)(path).componentFile) {
    (0, _babelUtils.diagnosticError)(path.get("name"), {
      label:
      'A Marko file can either have an inline class, or an external "component.js", but not both.'
    });

    path.remove();
    return;
  }

  const parsed = (0, _babelUtils.parseExpression)(file, code.replace(/;\s*$/, ""), start, end);
  if (parsed.type === "MarkoParseError") {
    path.replaceWith(_compiler.types.markoClass([_compiler.types.expressionStatement(parsed)]));
    return;
  }

  if (parsed.superClass) {
    (0, _babelUtils.diagnosticError)(path, {
      label: "Component class cannot have a super class.",
      loc: parsed.superClass.loc
    });
  }

  const constructorPropIndex = parsed.body.body.findIndex(
    (prop) => _compiler.types.isClassMethod(prop) && prop.kind === "constructor"
  );
  if (constructorPropIndex !== -1) {
    const constructorProp = parsed.body.body[constructorPropIndex];
    (0, _babelUtils.diagnosticError)(path, {
      label:
      "The constructor method should not be used for a component, use onCreate instead.",
      loc: constructorProp.key.loc
    });

    parsed.body.body.splice(constructorProp, 1);
  }

  if (parsed.id) {
    (0, _babelUtils.diagnosticDeprecate)(path, {
      label: "Component class should not have a name.",
      loc: parsed.id.loc,
      fix() {
        parsed.id = null;
      }
    });
  }

  path.replaceWith(_compiler.types.markoClass(parsed.body));
}