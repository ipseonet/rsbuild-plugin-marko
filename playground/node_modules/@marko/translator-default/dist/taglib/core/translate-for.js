"use strict";exports.__esModule = true;exports.exit = exit;var _babelUtils = require("@marko/babel-utils");
var _compiler = require("@marko/compiler");

function exit(path) {
  const { node } = path;
  const {
    attributes,
    body: { body, params }
  } = node;
  const namePath = path.get("name");
  const ofAttr = findName(attributes, "of");
  const inAttr = findName(attributes, "in");
  const fromAttr = findName(attributes, "from");
  const toAttr = findName(attributes, "to");
  const block = _compiler.types.blockStatement(body);
  let forNode;
  let allowedAttributes = ["by"];

  if (inAttr) {
    allowedAttributes.push("in");

    const [keyParam, valParam] = params;

    if (!keyParam) {
      throw namePath.buildCodeFrameError(
        "Invalid 'for in' tag, missing |key, value| params."
      );
    }

    if (valParam) {
      block.body.unshift(
        _compiler.types.variableDeclaration("const", [
        _compiler.types.variableDeclarator(
          valParam,
          _compiler.types.memberExpression(inAttr.value, keyParam, true)
        )]
        )
      );
    }

    forNode = _compiler.types.forInStatement(
      _compiler.types.variableDeclaration("const", [_compiler.types.variableDeclarator(keyParam)]),
      inAttr.value,
      block
    );
  } else if (ofAttr) {
    let ofAttrValue = _compiler.types.callExpression(
      (0, _babelUtils.importDefault)(
        path.hub.file,
        "marko/src/runtime/helpers/of-fallback.js",
        "of_fallback"
      ),
      [ofAttr.value]
    );
    allowedAttributes.push("of");

    const [valParam, keyParam, loopParam] = params;

    if (!valParam) {
      throw namePath.buildCodeFrameError(
        "Invalid 'for of' tag, missing |value, index| params."
      );
    }

    forNode = [];

    if (keyParam) {
      const indexName = path.scope.generateUidIdentifier(keyParam.name);
      forNode.push(
        _compiler.types.variableDeclaration("let", [
        _compiler.types.variableDeclarator(indexName, _compiler.types.numericLiteral(0))]
        )
      );

      block.body.unshift(
        _compiler.types.variableDeclaration("let", [
        _compiler.types.variableDeclarator(keyParam, _compiler.types.updateExpression("++", indexName))]
        )
      );
    }

    if (loopParam) {
      ofAttrValue = loopParam;
      forNode.push(
        _compiler.types.variableDeclaration("const", [
        _compiler.types.variableDeclarator(loopParam, ofAttr.value)]
        )
      );
    }

    forNode.push(
      _compiler.types.forOfStatement(
        _compiler.types.variableDeclaration("const", [_compiler.types.variableDeclarator(valParam)]),
        ofAttrValue,
        block
      )
    );
  } else if (fromAttr && toAttr) {
    allowedAttributes.push("from", "to", "step");

    const stepAttr = findName(attributes, "step") || {
      value: _compiler.types.numericLiteral(1)
    };
    const stepValue = stepAttr ? stepAttr.value : _compiler.types.numericLiteral(1);
    const [indexParam] = params;
    const stepsName = path.scope.generateUidIdentifier("steps");
    const stepName = path.scope.generateUidIdentifier("step");

    if (indexParam) {
      block.body.unshift(
        _compiler.types.variableDeclaration("const", [
        _compiler.types.variableDeclarator(
          indexParam,
          _compiler.types.binaryExpression(
            "+",
            fromAttr.value,
            _compiler.types.binaryExpression("*", stepName, stepValue)
          )
        )]
        )
      );
    }

    forNode = _compiler.types.forStatement(
      _compiler.types.variableDeclaration("let", [
      _compiler.types.variableDeclarator(
        stepsName,
        _compiler.types.binaryExpression(
          "/",
          _compiler.types.binaryExpression("-", toAttr.value, fromAttr.value),
          stepValue
        )
      ),
      _compiler.types.variableDeclarator(stepName, _compiler.types.numericLiteral(0))]
      ),
      _compiler.types.binaryExpression("<=", stepName, stepsName),
      _compiler.types.updateExpression("++", stepName),
      block
    );
  } else {
    throw namePath.buildCodeFrameError(
      "Invalid 'for' tag, missing an 'of', 'in' or 'to' attribute."
    );
  }

  (0, _babelUtils.assertAllowedAttributes)(path, allowedAttributes);
  path.replaceWithMultiple([].concat(forNode));
}

function findName(arr, value) {
  return arr.find((obj) => obj.name === value);
}