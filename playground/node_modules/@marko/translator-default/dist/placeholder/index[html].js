"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = _default;var _babelUtils = require("@marko/babel-utils");





var _compiler = require("@marko/compiler");
var _toString = _interopRequireDefault(require("marko/src/runtime/helpers/to-string"));
var _escapeScriptPlaceholder = _interopRequireDefault(require("marko/src/runtime/html/helpers/escape-script-placeholder"));
var _escapeStylePlaceholder = _interopRequireDefault(require("marko/src/runtime/html/helpers/escape-style-placeholder"));
var _escapeXml = require("marko/src/runtime/html/helpers/escape-xml");

var _htmlOutWrite = _interopRequireDefault(require("../util/html-out-write"));
var _withPreviousLocation = _interopRequireDefault(require("../util/with-previous-location"));

const ESCAPE_TYPES = {
  html: {
    name: "x",
    module: "marko/src/runtime/html/helpers/escape-xml.js",
    alias: "marko_escapeXml",
    fn: _escapeXml.x
  },
  script: {
    module: "marko/src/runtime/html/helpers/escape-script-placeholder.js",
    alias: "marko_escapeScript",
    fn: _escapeScriptPlaceholder.default
  },
  style: {
    module: "marko/src/runtime/html/helpers/escape-style-placeholder.js",
    alias: "marko_escapeStyle",
    fn: _escapeStylePlaceholder.default
  }
};

function _default(path) {
  const {
    node,
    hub: { file }
  } = path;
  const computed = (0, _babelUtils.computeNode)(node.value);
  let { escape, value } = node;

  if (escape) {
    const tagName = findParentTagName(path);
    const escapeType = ESCAPE_TYPES[tagName] || ESCAPE_TYPES.html;

    value = computed ?
    _compiler.types.stringLiteral(escapeType.fn(computed.value)) :
    _compiler.types.callExpression(
      escapeType.name ?
      (0, _babelUtils.importNamed)(
        file,
        escapeType.module,
        escapeType.name,
        escapeType.alias
      ) :
      (0, _babelUtils.importDefault)(file, escapeType.module, escapeType.alias),
      [value]
    );
  } else {
    value = computed ?
    _compiler.types.stringLiteral((0, _toString.default)(computed.value)) :
    _compiler.types.callExpression(
      (0, _babelUtils.importDefault)(
        file,
        "marko/src/runtime/helpers/to-string.js",
        "marko_to_string"
      ),
      [value]
    );
  }

  const replacement = (0, _htmlOutWrite.default)`${value}`;

  if (replacement) {
    path.replaceWith((0, _withPreviousLocation.default)(replacement, node));
  } else {
    path.remove();
  }
}

function findParentTagName(path) {
  while (path = path.parentPath) {
    if (path.isProgram()) {
      return;
    }

    if (path.isMarkoTag()) {
      const tagDef = (0, _babelUtils.getTagDef)(path);
      return tagDef && tagDef.html && path.get("name.value").node;
    }
  }
}