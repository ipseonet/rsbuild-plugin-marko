"use strict";exports.__esModule = true;exports.DiagnosticType = void 0;exports.diagnosticDeprecate = diagnosticDeprecate;exports.diagnosticError = diagnosticError;exports.diagnosticSuggest = diagnosticSuggest;exports.diagnosticWarn = diagnosticWarn;const DiagnosticType = exports.DiagnosticType = {
  Error: "error",
  Warning: "warning",
  Deprecation: "deprecation",
  Suggestion: "suggestion"
};

function diagnosticError(path, options) {
  add(DiagnosticType.Error, path, options);
}

function diagnosticWarn(path, options) {
  add(DiagnosticType.Warning, path, options);
}

function diagnosticDeprecate(path, options) {
  add(DiagnosticType.Deprecation, path, options);
}

function diagnosticSuggest(path, options) {
  add(DiagnosticType.Suggestion, path, options);
}

function add(type, path, options) {
  const { file } = path.hub;
  const { diagnostics } = file.metadata.marko;
  const { label, fix: rawFix, loc = path.node.loc } = options;
  let fix = false;

  if (rawFix) {
    switch (file.___compileStage) {
      case "parse":
      case "migrate":
        break;
      default:
        throw new Error(
          "Diagnostic fixes can only be registered up to and including the migrate stage."
        );
    }

    const { applyFixes } = file.markoOpts;
    let apply;

    if (typeof rawFix === "function") {
      apply = rawFix;
      fix = true;
    } else {
      // strip off the apply function.
      ({ apply, ...fix } = rawFix);
    }

    if (applyFixes) {
      const i = diagnostics.length;
      if (applyFixes.has(i)) {
        apply(applyFixes.get(i));
      }
    } else {
      apply(undefined);
    }
  }

  diagnostics.push({ type, label, loc, fix });
}