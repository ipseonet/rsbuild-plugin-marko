"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const loader_utils_1 = tslib_1.__importDefault(require("loader-utils"));
const escape_string_regexp_1 = tslib_1.__importDefault(require("escape-string-regexp"));
const markoCompiler = tslib_1.__importStar(require("@marko/compiler"));
const get_asset_code_1 = tslib_1.__importDefault(require("./get-asset-code"));
const manifest_1 = require("../shared/manifest");
const WATCH_MISSING_FILES = [
    {
        basename: "style",
        has(meta) {
            return Boolean(meta.deps &&
                meta.deps.some((dep) => getBasenameWithoutExt((typeof dep === "object" && dep.virtualPath) ||
                    dep) === this.basename));
        }
    },
    {
        basename: "component",
        has(meta) {
            return Boolean(meta.component);
        }
    },
    {
        basename: "component-browser",
        has(meta) {
            return Boolean(meta.component ||
                (meta.deps &&
                    meta.deps.some((dep) => getBasenameWithoutExt((typeof dep === "object" && dep.virtualPath) ||
                        dep) === this.basename)));
        }
    }
];
const ADDED_CACHE_CLEAR = new WeakSet();
markoCompiler.taglib.register(__filename, {
    "<head>": {
        transformer: require.resolve("./head-transformer")
    }
});
async function default_1(source) {
    var _a, _b;
    const { resourcePath, resourceQuery } = this;
    const compiler = getCompiler(this);
    const loaderOptions = this.getOptions
        ? this.getOptions()
        : loader_utils_1.default.getOptions(this);
    const { runtimeId, markoCompileCache, markoVirtualSources } = (compiler.markoPluginOptions || (compiler.markoPluginOptions = {
        markoCompileCache: new Map(),
        markoVirtualSources: new Map()
    }));
    const sourceMaps = (_a = loaderOptions.sourceMaps) !== null && _a !== void 0 ? _a : this.sourceMap;
    const target = normalizeTarget(loaderOptions.target || this.target);
    this.cacheable(true);
    if (!ADDED_CACHE_CLEAR.has(compiler)) {
        compiler.hooks.watchRun.tap("clearMarkoTaglibCache", () => markoCompiler.taglib.clearCaches());
        ADDED_CACHE_CLEAR.add(compiler);
    }
    if (resourceQuery === "?manifest") {
        return `export default ${manifest_1.MANIFEST_PLACEHOLDER}`;
    }
    if (markoVirtualSources.has(this.resource)) {
        const { code, map } = markoVirtualSources.get(this.resource);
        return this.callback(null, code, map);
    }
    const done = this.async();
    try {
        const baseConfig = {
            sourceMaps,
            hot: this.hot,
            fileSystem: this.fs,
            writeVersionComment: false,
            runtimeId,
            cache: markoCompileCache,
            resolveVirtualDependency(resourcePath, { code, map, virtualPath }) {
                const absoluteVirtualPath = `${resourcePath}?virtual=${virtualPath}`;
                markoVirtualSources.set(absoluteVirtualPath, { code, map });
                return `${virtualPath}!=!${__filename}!${absoluteVirtualPath}`;
            },
            babelConfig: {
                babelrc: false,
                configFile: false,
                browserslistConfigFile: false,
                ...loaderOptions.babelConfig,
                compact: false,
                comments: false,
                caller: {
                    name: "@marko/webpack/loader",
                    target: this.target,
                    supportsStaticESM: true,
                    supportsDynamicImport: true,
                    supportsTopLevelAwait: true,
                    ...(_b = loaderOptions.babelConfig) === null || _b === void 0 ? void 0 : _b.caller
                }
            }
        };
        if (loaderOptions.hydrateIncludeImports) {
            baseConfig.hydrateIncludeImports = loaderOptions.hydrateIncludeImports;
        }
        if (resourceQuery === "?server-entry") {
            const { code, map } = await markoCompiler.compile((0, get_asset_code_1.default)(resourcePath, runtimeId, compiler.options.output.publicPath), resourcePath.replace(/\.marko$/, "-server-entry.marko"), baseConfig);
            return done(null, code, map);
        }
        if (target === "server") {
            const { code, map, meta } = await markoCompiler.compile(source, resourcePath, baseConfig);
            return done(null, code + getTrailingContent(this, resourcePath, meta), map);
        }
        if (resourceQuery === "?browser-entry") {
            const { code, meta } = await markoCompiler.compile(source, resourcePath, {
                ...baseConfig,
                sourceMaps: false,
                output: "hydrate"
            });
            const mwpVar = `$mwp${runtimeId ? `_${runtimeId}` : ""}`;
            const mwpPrefix = compiler.options.output.publicPath === undefined
                ? `if (window.${mwpVar}) __webpack_public_path__ = ${mwpVar};\n`
                : "";
            return done(null, mwpPrefix + code + getTrailingContent(this, resourcePath, meta));
        }
        const { code, meta, map } = await markoCompiler.compile(source, resourcePath, {
            ...baseConfig,
            output: "dom"
        });
        return done(null, code + getTrailingContent(this, resourcePath, meta), map);
    }
    catch (err) {
        done(err);
    }
}
exports.default = default_1;
function getTrailingContent(ctx, resource, meta) {
    let result = "";
    if (meta.watchFiles) {
        for (const watchFile of meta.watchFiles) {
            ctx.addDependency(watchFile);
        }
    }
    if (ctx._compiler.watchMode) {
        const missingDeps = [];
        for (const watchFile of WATCH_MISSING_FILES) {
            if (!watchFile.has(meta)) {
                missingDeps.push(watchFile.basename);
            }
        }
        if (missingDeps.length) {
            const templateFileName = getBasenameWithoutExt(resource);
            result += `\nrequire.context(".", false, /\\/${templateFileName === "index"
                ? ""
                : `${(0, escape_string_regexp_1.default)(templateFileName)}\\.`}(?:${missingDeps.join("|")})\\.[^d]\\w*$/)`;
        }
    }
    if (ctx.hot && ctx.resourceQuery !== "?browser-entry") {
        result += "\nif (import.meta.webpackHot) import.meta.webpackHot.accept()";
    }
    return result;
}
function getCompiler(ctx) {
    let compiler = ctx._compiler;
    if (compiler.root)
        return compiler.root;
    while (compiler.parentCompilation) {
        compiler = compiler.parentCompilation.compiler;
    }
    return compiler;
}
function getBasenameWithoutExt(file) {
    const baseStart = file.lastIndexOf(path_1.default.sep) + 1;
    const extStart = file.indexOf(".", baseStart + 1);
    return file.slice(baseStart, extStart);
}
function normalizeTarget(target) {
    switch (target) {
        case "server":
        case "node":
        case "async-node":
        case "atom":
        case "electron":
        case "electron-main":
            return "server";
        default:
            return "browser";
    }
}
//# sourceMappingURL=index.js.map