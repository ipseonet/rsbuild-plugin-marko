"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const sort_keys_1 = tslib_1.__importDefault(require("sort-keys"));
const webpack = tslib_1.__importStar(require("webpack"));
const manifest_1 = require("../shared/manifest");
const module_name_1 = tslib_1.__importDefault(require("../shared/module-name"));
const WEBPACK_5 = parseInt(webpack.version.slice(0, webpack.version.indexOf(".")), 10) >= 5;
class MarkoWebpackPlugin {
    constructor(options = {}) {
        this.browserCompilers = [];
        this.clientEntries = {};
        this.clientAssets = {};
        this.options = {
            ...options,
            markoCompileCache: new Map(),
            markoVirtualSources: new Map()
        };
        if (this.options.runtimeId) {
            this.options.runtimeId = normalizeRuntimeId(this.options.runtimeId);
        }
    }
    get server() {
        return (compiler) => {
            const isEvalDevtool = String(compiler.options.devtool).includes("eval");
            const escapeIfEval = (code) => isEvalDevtool ? JSON.stringify(code).slice(1, -1) : code;
            this.serverCompiler = compiler;
            addLoaderAlias(compiler.options);
            patchWatchingWebpack4(compiler);
            compiler.markoAssetsRead = false;
            compiler.markoPluginOptions = this.options;
            compiler.markoEntriesPending = createDeferredPromise();
            compiler.hooks.invalid.tap("MarkoWebpackServer:invalid", () => {
                var _a;
                compiler.markoAssetsRead = false;
                (_a = compiler.markoEntriesPending) !== null && _a !== void 0 ? _a : (compiler.markoEntriesPending = createDeferredPromise());
            });
            compiler.hooks.normalModuleFactory.tap("MarkoWebpackServer:normalModuleFactory", normalModuleFactory => {
                normalModuleFactory.hooks.beforeResolve.tap("MarkoWebpackServer:resolver", (data) => {
                    const { issuer } = data.contextInfo;
                    if (data.request.endsWith(".marko") &&
                        (!issuer ||
                            !(issuer.endsWith(".marko") ||
                                /[/\\]node_modules[/\\]/.test(issuer)))) {
                        data.request = `${data.request}?server-entry`;
                    }
                });
            });
            compiler.hooks.thisCompilation.tap("MarkoWebpackServer:compilation", compilation => {
                if (!this.options.runtimeId && compilation.outputOptions.uniqueName) {
                    this.options.runtimeId = normalizeRuntimeId(compilation.outputOptions.uniqueName);
                }
                compilation.hooks.finishModules.tap("MarkoWebpackServer:finishModules", modules => {
                    var _a;
                    let hasChangedEntries = false;
                    const removedEntryIds = new Set(Object.keys(this.clientEntries));
                    for (const mod of modules) {
                        const resource = mod
                            .resource;
                        if (resource && resource.endsWith(".marko?server-entry")) {
                            const filename = resource.replace(/\?server-entry$/, "");
                            const entryTemplateId = (0, module_name_1.default)(filename);
                            if (!removedEntryIds.delete(entryTemplateId)) {
                                hasChangedEntries = true;
                                this.clientEntries[entryTemplateId] = `${filename}?browser-entry`;
                            }
                        }
                    }
                    for (const removedEntryId of removedEntryIds) {
                        hasChangedEntries = true;
                        delete this.clientEntries[removedEntryId];
                        for (const compilerName in this.clientAssets) {
                            delete this.clientAssets[compilerName][removedEntryId];
                        }
                    }
                    if (hasChangedEntries) {
                        for (const browserCompiler of this.browserCompilers) {
                            if (browserCompiler.markoEntriesRead) {
                                (_a = browserCompiler.watching) === null || _a === void 0 ? void 0 : _a.invalidate();
                            }
                        }
                    }
                    compiler.markoEntriesPending.resolve();
                    compiler.markoEntriesPending = undefined;
                });
                (WEBPACK_5
                    ? compilation.hooks.processAssets
                    : compilation.hooks.optimizeChunkAssets).tapPromise({
                    name: "MarkoWebpackServer:optimizeChunkAssets",
                    stage: WEBPACK_5
                        ? webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
                        : undefined
                }, async () => {
                    await Promise.all(this.browserCompilers.map(it => it.markoAssetsPending));
                    compiler.markoAssetsRead = true;
                    const clientAssets = (0, sort_keys_1.default)(this.clientAssets, { deep: true });
                    for (const chunk of compilation.chunks) {
                        if (!chunk.canBeInitial()) {
                            continue;
                        }
                        for (const file of chunk.files) {
                            compilation.updateAsset(file, old => {
                                const placeholder = escapeIfEval(manifest_1.MANIFEST_PLACEHOLDER);
                                const placeholderPosition = old.source().indexOf(placeholder);
                                if (placeholderPosition > -1) {
                                    const hasMultipleBuilds = this.browserCompilers.length > 1;
                                    const content = escapeIfEval(hasMultipleBuilds
                                        ? `{
  getAssets(entry, buildName) {
    const buildAssets = this.builds[buildName];
    if (!buildAssets) {
      throw new Error("Unable to load assets for build with a '$global.buildName' of '" + buildName + "'.");
    }

    return buildAssets[entry];
  },
  builds: ${JSON.stringify(clientAssets)}
}`
                                        : `{
  getAssets(entry) {
    return this.build[entry];
  },
  build: ${JSON.stringify(clientAssets[this.browserCompilers[0].name])}
}`);
                                    const sources = compiler.webpack
                                        ? compiler.webpack.sources
                                        : require("webpack-sources");
                                    const newSource = new sources.ReplaceSource(old.original ? old.original() : old);
                                    newSource.replace(placeholderPosition, placeholderPosition + placeholder.length - 1, content);
                                    return newSource;
                                }
                                return old;
                            });
                        }
                    }
                });
            });
        };
    }
    get browser() {
        return (compiler) => {
            const compilerName = compiler.options.name;
            const entryOption = compiler.options.entry;
            this.browserCompilers.push(compiler);
            addLoaderAlias(compiler.options);
            patchWatchingWebpack4(compiler);
            compiler.markoEntriesRead = false;
            compiler.markoPluginOptions = this.options;
            compiler.options.entry = async () => {
                await this.serverCompiler.markoEntriesPending;
                compiler.markoEntriesRead = true;
                let normalizedEntries = this.clientEntries;
                if (WEBPACK_5) {
                    normalizedEntries = {};
                    for (const key in this.clientEntries) {
                        normalizedEntries[key] = {
                            import: [this.clientEntries[key]]
                        };
                    }
                }
                if (isDefaultEntry(entryOption)) {
                    return normalizedEntries;
                }
                const currentEntry = typeof entryOption === "function" ? await entryOption() : entryOption;
                if (typeof currentEntry === "string" || Array.isArray(currentEntry)) {
                    return Object.assign({ main: currentEntry }, normalizedEntries);
                }
                else if (typeof currentEntry === "object") {
                    return { ...currentEntry, ...normalizedEntries };
                }
            };
            compiler.hooks.thisCompilation.tap("MarkoWebpackBrowser:compilation", compilation => {
                compiler.markoEntriesRead = false;
                const prevPendingAssets = compiler.markoAssetsPending;
                const pendingAssets = (compiler.markoAssetsPending =
                    createDeferredPromise());
                if (prevPendingAssets !== undefined) {
                    // If multiple compilations started, the last one always is treated
                    // as the source of truth.
                    pendingAssets.finally(() => prevPendingAssets.resolve());
                }
                compilation.hooks.afterOptimizeAssets.tap("MarkoWebpackBrowser:afterProcessAssets", () => {
                    var _a;
                    if (pendingAssets !== compiler.markoAssetsPending) {
                        return;
                    }
                    for (const [entryName, { chunks }] of compilation.entrypoints) {
                        const assetsByType = {};
                        for (const { files } of chunks) {
                            if (files) {
                                for (const asset of files) {
                                    if (compilation.assets[asset].size() === 0) {
                                        if (WEBPACK_5) {
                                            compilation.deleteAsset(asset);
                                        }
                                        else {
                                            delete compilation.assets[asset];
                                        }
                                        continue;
                                    }
                                    const ext = path_1.default.extname(asset).slice(1);
                                    const type = (assetsByType[ext] =
                                        assetsByType[ext] || []);
                                    type.push(asset);
                                }
                            }
                        }
                        const buildAssets = (this.clientAssets[compilerName] =
                            this.clientAssets[compilerName] || {});
                        buildAssets[entryName] = assetsByType;
                    }
                    if (this.serverCompiler.markoAssetsRead) {
                        (_a = this.serverCompiler.watching) === null || _a === void 0 ? void 0 : _a.invalidate();
                    }
                    compiler.markoAssetsPending = undefined;
                    pendingAssets.resolve();
                });
            });
        };
    }
}
exports.default = MarkoWebpackPlugin;
function patchWatchingWebpack4(compiler) {
    if (!WEBPACK_5) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        const { watch } = compiler;
        compiler.watch = (...args) => {
            return (compiler.watching = watch.apply(compiler, args));
        };
    }
}
function normalizeRuntimeId(id) {
    return id.replace(/[^a-z0-9$_]/gi, "_");
}
function addLoaderAlias(config) {
    var _a, _b;
    const resolveLoader = ((_a = config.resolveLoader) !== null && _a !== void 0 ? _a : (config.resolveLoader = {}));
    const resolveLoaderAlias = ((_b = resolveLoader.alias) !== null && _b !== void 0 ? _b : (resolveLoader.alias = {}));
    resolveLoaderAlias["@marko/webpack/loader"] = require.resolve("../loader");
}
function isDefaultEntry(entry) {
    if (WEBPACK_5) {
        if (typeof entry === "object") {
            for (const key in entry) {
                if (key !== "main") {
                    return false;
                }
                for (const _ in entry[key]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    return entry === "./src";
}
function createDeferredPromise() {
    let resolve;
    const promise = new Promise(_resolve => {
        resolve = _resolve;
    });
    promise.resolve = resolve;
    return promise;
}
//# sourceMappingURL=index.js.map