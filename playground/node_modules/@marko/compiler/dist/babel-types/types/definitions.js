"use strict";exports.__esModule = true;exports.default = exports.MARKO_TYPES = exports.MARKO_ALIAS_TYPES = void 0;var _utils = require("@babel/types/lib/definitions/utils");







const valueFieldCommon = {
  value: {
    validate: (0, _utils.assertValueType)("string")
  }
};

const MarkoDefinitions = {
  MarkoParseError: {
    aliases: ["Marko", "Expression", "Statement"],
    builder: ["source", "label", "errorLoc"],
    fields: {
      source: {
        validate: (0, _utils.assertValueType)("string")
      },
      label: {
        validate: (0, _utils.assertValueType)("string")
      },
      errorLoc: {
        optional: true,
        validate: (0, _utils.assertValueType)("object")
      }
    }
  },
  MarkoDocumentType: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon }
  },

  MarkoDeclaration: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon }
  },

  MarkoCDATA: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon }
  },

  MarkoComment: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon }
  },

  MarkoText: {
    aliases: ["Marko", "Statement"],
    builder: ["value"],
    fields: { ...valueFieldCommon }
  },

  MarkoPlaceholder: {
    aliases: ["Marko", "Statement"],
    builder: ["value", "escape"],
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      escape: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: true
      }
    }
  },

  MarkoScriptlet: {
    aliases: ["Marko", "Statement"],
    builder: ["body", "static", "target"],
    visitor: ["body"],
    fields: {
      body: {
        validate: arrayOfType(["Statement"])
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      target: {
        validate: (0, _utils.assertOneOf)("server", "client"),
        optional: true
      }
    }
  },

  MarkoClass: {
    aliases: ["Marko", "Statement"],
    builder: ["body"],
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      }
    }
  },

  MarkoAttribute: {
    aliases: ["Marko"],
    builder: ["name", "value", "modifier", "arguments", "default", "bound"],
    visitor: ["value", "arguments"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      modifier: {
        validate: (0, _utils.assertValueType)("string"),
        optional: true
      },
      arguments: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))
        ),
        optional: true
      },
      default: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      bound: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    }
  },

  MarkoSpreadAttribute: {
    aliases: ["Marko"],
    builder: ["value"],
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  },

  MarkoTagBody: {
    aliases: ["Marko", "BlockParent", "Scope"],
    builder: ["body", "params"],
    visitor: ["typeParameters", "params", "body"],
    fields: {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement"))
        ),
        default: []
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration"),
        optional: true
      },
      body: {
        validate: arrayOfType([
        "MarkoTag",
        "MarkoCDATA",
        "MarkoText",
        "MarkoPlaceholder",
        "MarkoScriptlet",
        "MarkoComment"]
        ),
        default: []
      }
    }
  },

  MarkoTag: {
    aliases: ["Marko", "Statement"],
    builder: ["name", "attributes", "body", "arguments", "var"],
    visitor: [
    "name",
    "typeArguments",
    "attributes",
    "body",
    "arguments",
    "var"],

    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      attributes: {
        validate: arrayOfType(["MarkoAttribute", "MarkoSpreadAttribute"]),
        default: []
      },
      body: {
        validate: (0, _utils.assertNodeType)("MarkoTagBody")
      },
      arguments: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))
        ),
        optional: true
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      },
      rawValue: {
        validate: (0, _utils.assertValueType)("string"),
        optional: true
      },
      var: {
        validate: (0, _utils.assertNodeType)("LVal"),
        optional: true
      }
    }
  }
};var _default = exports.default =

MarkoDefinitions;
const MARKO_TYPES = exports.MARKO_TYPES = Object.keys(MarkoDefinitions);
const MARKO_ALIAS_TYPES = exports.MARKO_ALIAS_TYPES = Array.from(
  new Set(
    MARKO_TYPES.reduce((all, t) => all.concat(MarkoDefinitions[t].aliases), [])
  )
);

// Note this is inline because a change in babel caused a regression with this api.
// TODO: we should not rely on babels validators or builders.
function arrayOfType(types) {
  return (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)(...types)));
}