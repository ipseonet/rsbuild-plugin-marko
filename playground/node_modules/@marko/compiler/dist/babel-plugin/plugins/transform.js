"use strict";exports.__esModule = true;exports.visitor = void 0;var _babelUtils = require("@marko/babel-utils");

var t = _interopRequireWildcard(require("../../babel-types"));
var _pluginHooks = require("../util/plugin-hooks");function _getRequireWildcardCache(e) {if ("function" != typeof WeakMap) return null;var r = new WeakMap(),t = new WeakMap();return (_getRequireWildcardCache = function (e) {return e ? t : r;})(e);}function _interopRequireWildcard(e, r) {if (!r && e && e.__esModule) return e;if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };var t = _getRequireWildcardCache(r);if (t && t.has(e)) return t.get(e);var n = { __proto__: null },a = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];}return n.default = e, t && t.set(e, n), n;}

/**
 * Applies custom transformers on tags.
 */
const visitor = exports.visitor = {
  MarkoTag: {
    enter(path) {
      const transformers = getTransformersForTag(path);
      const { node } = path;

      for (const transformer of transformers) {
        (0, _pluginHooks.enter)(transformer, path, t);
        if (path.node !== node) break; // Stop if node is replaced.
      }
    },
    exit(path) {
      const transformers = getTransformersForTag(path);
      const { node } = path;

      for (const transformer of transformers) {
        (0, _pluginHooks.exit)(transformer, path, t);
        if (path.node !== node) break; // Stop if node is replaced.
      }
    }
  }
};

function getTransformersForTag(path) {
  const {
    hub: { file }
  } = path;
  const { watchFiles } = file.metadata.marko;
  const tagName = path.get("name.value").node || "*";
  const TRANSFORMER_CACHE = file.TRANSFORMER_CACHE =
  file.TRANSFORMER_CACHE || Object.create(null);

  let transformers = TRANSFORMER_CACHE[tagName];

  if (!transformers) {
    transformers = TRANSFORMER_CACHE[tagName] = [];
    const addTransformers = (tagDef) => {
      if (tagDef && tagDef.transformers) {
        for (const transformer of tagDef.transformers) {
          if (transformer.path) {
            watchFiles.push(transformer.path);
          }
          transformers.push(transformer.hook.default || transformer.hook);
        }
      }
    };

    addTransformers((0, _babelUtils.getTagDef)(path));

    if (tagName !== "*") {
      addTransformers((0, _babelUtils.getTagDefForTagName)(file, "*"));
    }
  }

  return transformers;
}