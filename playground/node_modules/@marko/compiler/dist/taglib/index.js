"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports._loader = exports._finder = void 0;exports.buildLookup = buildLookup;exports.clearCaches = clearCaches;exports.excludePackage = exports.excludeDir = void 0;exports.register = register;exports.resolveOptionalTaglibs = resolveOptionalTaglibs;var _lassoPackageRoot = require("lasso-package-root");
var _path = _interopRequireDefault(require("path"));

var _modules = _interopRequireDefault(require("../../modules"));
var _tryLoadTranslator = _interopRequireDefault(require("../util/try-load-translator"));
var _config = _interopRequireDefault(require("./config"));
var _finder2 = _interopRequireDefault(require("./finder"));
var _loader2 = _interopRequireDefault(require("./loader"));
var _lookup = _interopRequireDefault(require("./lookup"));




var _markoHtml = _interopRequireDefault(require("./marko-html.json"));
var _markoMath = _interopRequireDefault(require("./marko-math.json"));
var _markoSvg = _interopRequireDefault(require("./marko-svg.json"));const excludeDir = exports.excludeDir = _finder2.default.excludeDir;const excludePackage = exports.excludePackage = _finder2.default.excludePackage;

const registeredTaglibs = [];
const loadedTranslatorsTaglibs = new Map();
let lookupCache = Object.create(null);

register("marko/html", _markoHtml.default);
register("marko/svg", _markoSvg.default);
register("marko/math", _markoMath.default);

function buildLookup(dirname, requestedTranslator, onError) {
  const translator = (0, _tryLoadTranslator.default)(requestedTranslator);
  if (!translator || !Array.isArray(translator.taglibs)) {
    throw new Error(
      "@marko/compiler: Invalid translator provided to buildLookup(dir, translator)"
    );
  }

  let taglibsForDir = loadedTranslatorsTaglibs.get(translator);

  if (!taglibsForDir) {
    loadedTranslatorsTaglibs.set(
      translator,
      taglibsForDir = registeredTaglibs.concat(
        resolveOptionalTaglibs(translator.optionalTaglibs || []).
        concat(translator.taglibs).
        map(([id, props]) => loadTaglib(id, props))
      )
    );
  }

  if (onError) {
    const prevOnError = _config.default.onError;
    _config.default.onError = onError;
    try {
      taglibsForDir = _finder2.default.find(dirname, taglibsForDir);
    } catch (err) {
      _config.default.onError(err);
    } finally {
      _config.default.onError = prevOnError;
    }
  } else {
    taglibsForDir = _finder2.default.find(dirname, taglibsForDir);
  }

  const cacheKey = taglibsForDir.
  map((it) => it.id).
  sort().
  join();
  let lookup = lookupCache[cacheKey];

  if (!lookup) {
    lookup = lookupCache[cacheKey] = new _lookup.default();
    for (let i = taglibsForDir.length; i--;) {
      const taglib = taglibsForDir[i];
      lookup.addTaglib(taglib);
      if (taglib.imports) {
        for (const importedTaglib of taglib.imports) {
          if (!lookup.hasTaglib(importedTaglib)) {
            lookup.addTaglib(importedTaglib);
          }
        }
      }
    }
  }

  return lookup;
}

function register(id, props) {
  if (typeof props === "undefined") {
    [id, props] = resolveTaglib(id);
  }
  registeredTaglibs.push(loadTaglib(id, props));
}

function clearCaches() {
  _loader2.default.clearCache();
  _finder2.default.clearCache();
  lookupCache = Object.create(null);
}

function resolveOptionalTaglibs(taglibIds) {
  const resolvedTaglibs = [];
  for (const id of taglibIds) {
    if (hasRootDependency(id)) {
      resolvedTaglibs.push(resolveTaglib(id));
    }
  }

  return resolvedTaglibs;
}

// Used by legacy compiler api.
const _loader = exports._loader = _loader2.default;
const _finder = exports._finder = _finder2.default;

function loadTaglib(id, props) {
  return _loader2.default.loadTaglibFromProps(_loader2.default.createTaglib(id), props);
}

function resolveTaglib(id) {
  switch (id[0]) {
    case ".":
    case "/":
    case "\\":
      break;
    default:
      if (!id.endsWith(".json")) {
        id = _path.default.join(id, "marko.json");
      }
      break;
  }

  const resolved = _modules.default.require.resolve(id);
  return [resolved, _modules.default.require(resolved)];
}

function hasRootDependency(id) {
  const pkg = (0, _lassoPackageRoot.getRootPackage)(process.cwd());
  return !!(pkg && pkg.dependencies?.[id] || pkg.devDependencies?.[id]);
}