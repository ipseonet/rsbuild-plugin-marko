"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports._clearDefaults = _clearDefaults;exports.compile = compile;exports.compileFile = compileFile;exports.compileFileSync = compileFileSync;exports.compileSync = compileSync;exports.configure = configure;exports.getRuntimeEntryFiles = getRuntimeEntryFiles;exports.types = exports.taglib = void 0;var _types = _interopRequireWildcard(require("./babel-types"));exports.types = _types;
var babel = _interopRequireWildcard(require("@babel/core"));
var _pluginSyntaxTypescript = _interopRequireDefault(require("@babel/plugin-syntax-typescript"));
var _pluginTransformModulesCommonjs = _interopRequireDefault(require("@babel/plugin-transform-modules-commonjs"));
var _pluginTransformTypescript = _interopRequireDefault(require("@babel/plugin-transform-typescript"));
var _babelUtils = require("@marko/babel-utils");
var _path = _interopRequireDefault(require("path"));

var _babelPlugin = _interopRequireDefault(require("./babel-plugin"));
var _config = _interopRequireDefault(require("./config"));
var taglib = _interopRequireWildcard(require("./taglib"));exports.taglib = taglib;
var _buildCodeFrame = require("./util/build-code-frame");
var _mergeErrors = _interopRequireDefault(require("./util/merge-errors"));
var _shouldOptimize = _interopRequireDefault(require("./util/should-optimize"));
var _tryLoadTranslator = _interopRequireDefault(require("./util/try-load-translator"));function _getRequireWildcardCache(e) {if ("function" != typeof WeakMap) return null;var r = new WeakMap(),t = new WeakMap();return (_getRequireWildcardCache = function (e) {return e ? t : r;})(e);}function _interopRequireWildcard(e, r) {if (!r && e && e.__esModule) return e;if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };var t = _getRequireWildcardCache(r);if (t && t.has(e)) return t.get(e);var n = { __proto__: null },a = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];}return n.default = e, t && t.set(e, n), n;}


const CWD = process.cwd();

let globalConfig = { ..._config.default };
function configure(newConfig) {
  globalConfig = { ..._config.default, ...newConfig };
}

async function compile(src, filename, config) {
  const markoConfig = loadMarkoConfig(config);
  const babelConfig = await loadBabelConfig(filename, markoConfig);
  const babelResult = await babel.transformAsync(src, babelConfig);
  scheduleDefaultClear(markoConfig);
  return buildResult(src, filename, markoConfig.errorRecovery, babelResult);
}

function compileSync(src, filename, config) {
  const markoConfig = loadMarkoConfig(config);
  const babelConfig = loadBabelConfigSync(filename, markoConfig);
  const babelResult = babel.transformSync(src, babelConfig);
  scheduleDefaultClear(markoConfig);
  return buildResult(src, filename, markoConfig.errorRecovery, babelResult);
}

async function compileFile(filename, config) {
  return new Promise((resolve, reject) => {
    getFs(config).readFile(filename, "utf-8", (err, src) => {
      if (err) {
        return reject(err);
      }

      return resolve(compile(src, filename, config));
    });
  });
}

function compileFileSync(filename, config) {
  const src = getFs(config).readFileSync(filename, "utf-8");
  return compileSync(src, filename, config);
}

function getRuntimeEntryFiles(output, requestedTranslator) {
  const translator = (0, _tryLoadTranslator.default)(requestedTranslator);
  if (translator && translator.getRuntimeEntryFiles) {
    return translator.getRuntimeEntryFiles(output, (0, _shouldOptimize.default)());
  }

  return [];
}

function loadMarkoConfig(config) {
  const markoConfig = { ...globalConfig, ...config };

  if (markoConfig.stripTypes === undefined) {
    markoConfig.stripTypes = isTranslatedOutput(markoConfig.output);
  }

  return markoConfig;
}

async function loadBabelConfig(filename, config) {
  const baseBabelConfig = getBaseBabelConfig(filename, config);
  return isTranslatedOutput(config.output) ?
  (await babel.loadPartialConfigAsync(baseBabelConfig)).options :
  baseBabelConfig;
}

function loadBabelConfigSync(filename, config) {
  const baseBabelConfig = getBaseBabelConfig(filename, config);
  return isTranslatedOutput(config.output) ?
  babel.loadPartialConfigSync(baseBabelConfig).options :
  baseBabelConfig;
}

function getBaseBabelConfig(filename, { babelConfig, ...markoConfig }) {
  const isTranslated = isTranslatedOutput(markoConfig.output);
  const requiredPlugins = [
  [_babelPlugin.default, markoConfig],
  [
  markoConfig.stripTypes ? _pluginTransformTypescript.default : _pluginSyntaxTypescript.default,
  {
    isTSX: false,
    allowNamespaces: true,
    allowDeclareFields: true,
    optimizeConstEnums: true,
    onlyRemoveTypeImports: true,
    disallowAmbiguousJSXLike: false
  }]];


  const baseBabelConfig = {
    filenameRelative: filename ? _path.default.relative(CWD, filename) : undefined,
    sourceRoot: filename ? _path.default.dirname(filename) : undefined,
    sourceFileName: filename ? _path.default.basename(filename) : undefined,
    configFile: isTranslated,
    babelrc: isTranslated,
    ...babelConfig,
    filename,
    sourceType: "module",
    sourceMaps: markoConfig.sourceMaps,
    code: markoConfig.code,
    ast: markoConfig.ast,
    plugins:
    babelConfig && babelConfig.plugins ?
    requiredPlugins.concat(babelConfig.plugins) :
    requiredPlugins
  };

  if (isTranslated) {
    if (markoConfig.modules === "cjs") {
      baseBabelConfig.plugins.push([_pluginTransformModulesCommonjs.default, { loose: true }]);
    }
  }

  return baseBabelConfig;
}

function buildResult(src, filename, errorRecovery, babelResult) {
  const {
    ast,
    map,
    code,
    metadata: { marko: meta }
  } = babelResult;

  if (!errorRecovery) {
    const errors = [];

    for (const diag of meta.diagnostics) {
      if (diag.type === _babelUtils.DiagnosticType.Error) {
        errors.push((0, _buildCodeFrame.buildCodeFrameError)(filename, src, diag.loc, diag.label));
      }
    }

    (0, _mergeErrors.default)(errors);
  }

  return { ast, map, code, meta };
}

let clearingDefaultCache = false;
function scheduleDefaultClear(config) {
  if (
  !clearingDefaultCache && (
  clearingDefaultCache = isDefaultCache(config)))
  {
    setImmediate(_clearDefaults);
  }
}

function _clearDefaults() {
  clearingDefaultCache = false;
  globalConfig.cache.clear();
}

function isDefaultCache(config) {
  return !config.cache || config.cache === globalConfig.cache;
}

function getFs(config) {
  return config.fileSystem || globalConfig.fileSystem;
}

function isTranslatedOutput(output) {
  return output !== "source" && output !== "migrate";
}