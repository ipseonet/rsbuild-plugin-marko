'use strict';

// src/index.ts
var singleComment = Symbol("singleComment");
var multiComment = Symbol("multiComment");
function stripWithoutWhitespace() {
  return "";
}
function stripWithWhitespace(str, start, end) {
  return str.slice(start, end).replace(/\S/g, " ");
}
function isEscaped(jsonString, quotePosition) {
  let index = quotePosition - 1;
  let backslashCount = 0;
  while (jsonString[index] === "\\") {
    index -= 1;
    backslashCount += 1;
  }
  return Boolean(backslashCount % 2);
}
var DEFAULT_OPTIONS = {
  trailingCommas: false,
  whitespace: true
};
function strip(jsonString, options = DEFAULT_OPTIONS) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
  }
  const { trailingCommas = false, whitespace = true } = options;
  const _strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;
  let isInsideString = false;
  let isInsideComment = false;
  let offset = 0;
  let buffer = "";
  let result = "";
  let commaIndex = -1;
  for (let i = 0; i < jsonString.length; i++) {
    const currentCharacter = jsonString[i];
    const nextCharacter = jsonString[i + 1];
    if (!currentCharacter) {
      continue;
    }
    if (!isInsideComment && currentCharacter === '"') {
      const escaped = isEscaped(jsonString, i);
      if (!escaped) {
        isInsideString = !isInsideString;
      }
    }
    if (isInsideString) {
      continue;
    }
    if (!isInsideComment && currentCharacter + nextCharacter === "//") {
      buffer += jsonString.slice(offset, i);
      offset = i;
      isInsideComment = singleComment;
      i++;
    } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
      i++;
      isInsideComment = false;
      buffer += _strip(jsonString, offset, i);
      offset = i;
      continue;
    } else if (isInsideComment === singleComment && currentCharacter === "\n") {
      isInsideComment = false;
      buffer += _strip(jsonString, offset, i);
      offset = i;
    } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
      buffer += jsonString.slice(offset, i);
      offset = i;
      isInsideComment = multiComment;
      i++;
      continue;
    } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
      i++;
      isInsideComment = false;
      buffer += _strip(jsonString, offset, i + 1);
      offset = i + 1;
      continue;
    } else if (trailingCommas && !isInsideComment) {
      if (commaIndex !== -1) {
        if (currentCharacter === "}" || currentCharacter === "]") {
          buffer += jsonString.slice(offset, i);
          result += _strip(buffer, 0, 1) + buffer.slice(1);
          buffer = "";
          offset = i;
          commaIndex = -1;
        } else if (currentCharacter !== " " && currentCharacter !== "	" && currentCharacter !== "\r" && currentCharacter !== "\n") {
          buffer += jsonString.slice(offset, i);
          offset = i;
          commaIndex = -1;
        }
      } else if (currentCharacter === ",") {
        result += buffer + jsonString.slice(offset, i);
        buffer = "";
        offset = i;
        commaIndex = i;
      }
    }
  }
  return result + buffer + (isInsideComment ? _strip(jsonString.slice(offset)) : jsonString.slice(offset));
}

exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
exports.strip = strip;
