import { createRequire } from 'module';
var require = createRequire(import.meta['url']);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/.pnpm/@modern-js+module-tools@2.60.2_typescript@5.6.3/node_modules/@modern-js/module-tools/shims/esm.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename, getDirname, __dirname, __filename;
var init_esm = __esm({
  "../../node_modules/.pnpm/@modern-js+module-tools@2.60.2_typescript@5.6.3/node_modules/@modern-js/module-tools/shims/esm.js"() {
    "use strict";
    getFilename = () => fileURLToPath(import.meta.url);
    getDirname = () => path.dirname(getFilename());
    __dirname = /* @__PURE__ */ getDirname();
    __filename = /* @__PURE__ */ getFilename();
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js
var require_error = __commonJS({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js"(exports) {
    "use strict";
    init_esm();
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js"(exports) {
    "use strict";
    init_esm();
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       *
       * @returns {Argument}
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       *
       * @returns {Argument}
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports.Argument = Argument2;
    exports.humanReadableArgName = humanReadableArgName;
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/help.js
var require_help = __commonJS({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/help.js"(exports) {
    "use strict";
    init_esm();
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        const helpCommand = cmd._getHelpCommand();
        if (helpCommand && !helpCommand._hidden) {
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns {number}
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const helpOption = cmd._getHelpOption();
        if (helpOption && !helpOption.hidden) {
          const removeShort = helpOption.short && cmd._findOption(helpOption.short);
          const removeLong = helpOption.long && cmd._findOption(helpOption.long);
          if (!removeShort && !removeLong) {
            visibleOptions.push(helpOption);
          } else if (helpOption.long && !removeLong) {
            visibleOptions.push(
              cmd.createOption(helpOption.long, helpOption.description)
            );
          } else if (helpOption.short && !removeShort) {
            visibleOptions.push(
              cmd.createOption(helpOption.short, helpOption.description)
            );
          }
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions)
          return [];
        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter(
            (option) => !option.hidden
          );
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd.registeredArguments.find((argument) => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let ancestorCmdNames = "";
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(
              `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`
            );
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(
            `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`
          );
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(
              fullText,
              helpWidth - itemIndentWidth,
              termWidth + itemSeparatorWidth
            );
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([
            helper.wrap(commandDescription, helpWidth, 0),
            ""
          ]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(
            helper.argumentTerm(argument),
            helper.argumentDescription(argument)
          );
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option)
          );
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(
              helper.optionTerm(option),
              helper.optionDescription(option)
            );
          });
          if (globalOptionList.length > 0) {
            output = output.concat([
              "Global Options:",
              formatList(globalOptionList),
              ""
            ]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(
            helper.subcommandTerm(cmd2),
            helper.subcommandDescription(cmd2)
          );
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v   -   　\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "​";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex = new RegExp(
          `
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
          "g"
        );
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i) => {
          if (line === "\n")
            return "";
          return (i > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports.Help = Help2;
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/option.js
var require_option = __commonJS({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/option.js"(exports) {
    "use strict";
    init_esm();
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {(string | string[])} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === "string") {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @package
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @package
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey))
          return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports.Option = Option2;
    exports.DualOptions = DualOptions;
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/suggestSimilar.js"(exports) {
    "use strict";
    init_esm();
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            // deletion
            d[i][j - 1] + 1,
            // insertion
            d[i - 1][j - 1] + cost
            // substitution
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports.suggestSimilar = suggestSimilar;
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/command.js
var require_command = __commonJS({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/command.js"(exports) {
    "use strict";
    init_esm();
    var EventEmitter = __require("events").EventEmitter;
    var childProcess = __require("child_process");
    var path22 = __require("path");
    var fs12 = __require("fs");
    var process2 = __require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class _Command extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this.registeredArguments = [];
        this._args = this.registeredArguments;
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process2.stdout.write(str),
          writeErr: (str) => process2.stderr.write(str),
          getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
          getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._helpOption = void 0;
        this._addImplicitHelpCommand = void 0;
        this._helpCommand = void 0;
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._helpOption = sourceCommand._helpOption;
        this._helpCommand = sourceCommand._helpCommand;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * @returns {Command[]}
       * @private
       */
      _getCommandAndAncestors() {
        const result = [];
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new _Command(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {(boolean|string)} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd._checkForBrokenPassThrough();
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {(Function|*)} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.trim().split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(
            `only the last argument can be variadic '${previousArgument.name()}'`
          );
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(
            `a default value for a required argument is never used: '${argument.name()}'`
          );
        }
        this.registeredArguments.push(argument);
        return this;
      }
      /**
       * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
       *
       * @example
       *    program.helpCommand('help [cmd]');
       *    program.helpCommand('help [cmd]', 'show help');
       *    program.helpCommand(false); // suppress default help command
       *    program.helpCommand(true); // add help command even if no subcommands
       *
       * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
       * @param {string} [description] - custom description
       * @return {Command} `this` command for chaining
       */
      helpCommand(enableOrNameAndArgs, description) {
        if (typeof enableOrNameAndArgs === "boolean") {
          this._addImplicitHelpCommand = enableOrNameAndArgs;
          return this;
        }
        enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
        const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
        const helpDescription = description ?? "display help for command";
        const helpCommand = this.createCommand(helpName);
        helpCommand.helpOption(false);
        if (helpArgs)
          helpCommand.arguments(helpArgs);
        if (helpDescription)
          helpCommand.description(helpDescription);
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Add prepared custom help command.
       *
       * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
       * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(helpCommand, deprecatedDescription) {
        if (typeof helpCommand !== "object") {
          this.helpCommand(helpCommand, deprecatedDescription);
          return this;
        }
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Lazy create help command.
       *
       * @return {(Command|null)}
       * @package
       */
      _getHelpCommand() {
        const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
        if (hasImplicitHelpCommand) {
          if (this._helpCommand === void 0) {
            this.helpCommand(void 0, void 0);
          }
          return this._helpCommand;
        }
        return null;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process2.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {(Option | Argument)} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @private
       */
      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === "commander.invalidArgument") {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }
      /**
       * Check for option flag conflicts.
       * Register option if no conflicts found, or throw on conflict.
       *
       * @param {Option} option
       * @private
       */
      _registerOption(option) {
        const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
        if (matchingOption) {
          const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
          throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
        }
        this.options.push(option);
      }
      /**
       * Check for command name and alias conflicts with existing commands.
       * Register command if no conflicts found, or throw on conflict.
       *
       * @param {Command} command
       * @private
       */
      _registerCommand(command) {
        const knownBy = (cmd) => {
          return [cmd.name()].concat(cmd.aliases());
        };
        const alreadyUsed = knownBy(command).find(
          (name) => this._findCommand(name)
        );
        if (alreadyUsed) {
          const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
          const newCmd = knownBy(command).join("|");
          throw new Error(
            `cannot add command '${newCmd}' as already have command '${existingCmd}'`
          );
        }
        this.commands.push(command);
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        this._registerOption(option);
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(
              name,
              option.defaultValue === void 0 ? true : option.defaultValue,
              "default"
            );
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @return {Command} `this` command for chaining
       * @private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error(
            "To add an Option object use addOption() instead of option() or requiredOption()"
          );
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }
      /**
       * Add a required option which must have a value after parsing. This usually means
       * the option must be specified on the command line. (Otherwise the same as .option().)
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx(
          { mandatory: true },
          flags,
          description,
          parseArg,
          defaultValue
        );
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
       * @return {Command} `this` command for chaining
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
       * @return {Command} `this` command for chaining
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
       * @return {Command} `this` command for chaining
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {boolean} [positional]
       * @return {Command} `this` command for chaining
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {boolean} [passThrough] for unknown options.
       * @return {Command} `this` command for chaining
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        this._checkForBrokenPassThrough();
        return this;
      }
      /**
       * @private
       */
      _checkForBrokenPassThrough() {
        if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
          throw new Error(
            `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`
          );
        }
      }
      /**
       * Whether to store option values as properties on command object,
       * or store separately (specify false). In both cases the option values can be accessed using .opts().
       *
       * @param {boolean} [storeAsProperties=true]
       * @return {Command} `this` command for chaining
       */
      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        if (Object.keys(this._optionValues).length) {
          throw new Error(
            "call .storeOptionsAsProperties() before setting option values"
          );
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
       * Store option value and where the value came from.
       *
       * @param {string} key
       * @param {object} value
       * @param {string} source - expected values are default/config/env/cli/implied
       * @return {Command} `this` command for chaining
       */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
       * Get source of option value.
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
       * Get source of option value. See also .optsWithGlobals().
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSourceWithGlobals(key) {
        let source;
        this._getCommandAndAncestors().forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0 && parseOptions.from === void 0) {
          if (process2.versions?.electron) {
            parseOptions.from = "electron";
          }
          const execArgv = process2.execArgv ?? [];
          if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
            parseOptions.from = "eval";
          }
        }
        if (argv === void 0) {
          argv = process2.argv;
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process2.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          case "eval":
            userArgs = argv.slice(1);
            break;
          default:
            throw new Error(
              `unexpected parse option { from: '${parseOptions.from}' }`
            );
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * program.parse(); // parse process.argv and auto-detect electron and special node flags
       * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
       * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path22.resolve(baseDir, baseName);
          if (fs12.existsSync(localBin))
            return localBin;
          if (sourceExt.includes(path22.extname(baseName)))
            return void 0;
          const foundExt = sourceExt.find(
            (ext) => fs12.existsSync(`${localBin}${ext}`)
          );
          if (foundExt)
            return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs12.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path22.resolve(
            path22.dirname(resolvedScriptPath),
            executableDir
          );
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path22.basename(
              this._scriptPath,
              path22.extname(this._scriptPath)
            );
            if (legacyName !== this._name) {
              localFile = findFile(
                executableDir,
                `${legacyName}-${subcommand._name}`
              );
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path22.extname(executableFile));
        let proc;
        if (process2.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process2.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        proc.on("close", (code) => {
          code = code ?? 1;
          if (!exitCallback) {
            process2.exit(code);
          } else {
            exitCallback(
              new CommanderError2(
                code,
                "commander.executeSubCommandAsync",
                "(close)"
              )
            );
          }
        });
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process2.exit(1);
          } else {
            const wrappedError = new CommanderError2(
              1,
              "commander.executeSubCommandAsync",
              "(error)"
            );
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(
          promiseChain,
          subCommand,
          "preSubcommand"
        );
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }
      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @private
       */
      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }
        return this._dispatchSubcommand(
          subcommandName,
          [],
          [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]
        );
      }
      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @private
       */
      _checkNumberOfArguments() {
        this.registeredArguments.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(
              argument,
              value,
              previous,
              invalidValueMessage
            );
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {(Promise|undefined)} promise
       * @param {Function} fn
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          this._outputHelpIfRequested(unknown);
          return this._dispatchSubcommand(
            this._defaultCommandName,
            operands,
            unknown
          );
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        this._outputHelpIfRequested(parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
          promiseChain = this._chainOrCall(
            promiseChain,
            () => this._actionHandler(this.processedArgs)
          );
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @private
       * @return {Command | undefined}
       */
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find(
          (cmd) => cmd._name === name || cmd._aliases.includes(name)
        );
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @package
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForMissingMandatoryOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter((option) => {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === void 0) {
            return false;
          }
          return this.getOptionValueSource(optionKey) !== "default";
        });
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForConflictingOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd._checkForConflictingLocalOptions();
        });
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {string[]} argv
       * @return {{operands: string[], unknown: string[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {object}
       */
      optsWithGlobals() {
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(
          `${message}
`,
          this._outputConfiguration.writeErr
        );
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process2.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(
              this.getOptionValueSource(optionKey)
            )) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter(
          (option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option
          )
        ).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              "implied"
            );
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find(
            (target) => target.negate && optionKey === target.attributeName()
          );
          const positiveOption = this.options.find(
            (target) => !target.negate && optionKey === target.attributeName()
          );
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this.registeredArguments.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this._registerOption(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {object} [argsDescription]
       * @return {(string|Command)}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      summary(str) {
        if (str === void 0)
          return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {(string|Command)}
       */
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        const matchingCommand = this.parent?._findCommand(alias);
        if (matchingCommand) {
          const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
          throw new Error(
            `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`
          );
        }
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {(string[]|Command)}
       */
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this.registeredArguments.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._helpOption !== null ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this.registeredArguments.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path22.basename(filename, path22.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {(string|null|Command)}
       */
      executableDir(path23) {
        if (path23 === void 0)
          return this._executableDir;
        this._executableDir = path23;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        if (this._getHelpOption()?.long) {
          this.emit(this._getHelpOption().long);
        }
        this.emit("afterHelp", context);
        this._getCommandAndAncestors().forEach(
          (command) => command.emit("afterAllHelp", context)
        );
      }
      /**
       * You can pass in flags and a description to customise the built-in help option.
       * Pass in false to disable the built-in help option.
       *
       * @example
       * program.helpOption('-?, --help' 'show help'); // customise
       * program.helpOption(false); // disable
       *
       * @param {(string | boolean)} flags
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          if (flags) {
            this._helpOption = this._helpOption ?? void 0;
          } else {
            this._helpOption = null;
          }
          return this;
        }
        flags = flags ?? "-h, --help";
        description = description ?? "display help for command";
        this._helpOption = this.createOption(flags, description);
        return this;
      }
      /**
       * Lazy create help option.
       * Returns null if has been disabled with .helpOption(false).
       *
       * @returns {(Option | null)} the help option
       * @package
       */
      _getHelpOption() {
        if (this._helpOption === void 0) {
          this.helpOption(void 0, void 0);
        }
        return this._helpOption;
      }
      /**
       * Supply your own option to use for the built-in help option.
       * This is an alternative to using helpOption() to customise the flags and description etc.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addHelpOption(option) {
        this._helpOption = option;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process2.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {(string | Function)} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
      /**
       * Output help information if help flags specified
       *
       * @param {Array} args - array of options to search for help flags
       * @private
       */
      _outputHelpIfRequested(args) {
        const helpOption = this._getHelpOption();
        const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
        if (helpRequested) {
          this.outputHelp();
          this._exit(0, "commander.helpDisplayed", "(outputHelp)");
        }
      }
    };
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    exports.Command = Command2;
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/index.js
var require_commander = __commonJS({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/index.js"(exports) {
    "use strict";
    init_esm();
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports.program = new Command2();
    exports.createCommand = (name) => new Command2(name);
    exports.createOption = (flags, description) => new Option2(flags, description);
    exports.createArgument = (name, description) => new Argument2(name, description);
    exports.Command = Command2;
    exports.Option = Option2;
    exports.Argument = Argument2;
    exports.Help = Help2;
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
    exports.InvalidOptionArgumentError = InvalidArgumentError2;
  }
});

// ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/esm.mjs
var import_index, program, createCommand, createArgument, createOption, CommanderError, InvalidArgumentError, InvalidOptionArgumentError, Command, Argument, Option, Help;
var init_esm2 = __esm({
  "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/esm.mjs"() {
    "use strict";
    init_esm();
    import_index = __toESM(require_commander(), 1);
    ({
      program,
      createCommand,
      createArgument,
      createOption,
      CommanderError,
      InvalidArgumentError,
      InvalidOptionArgumentError,
      Command: (
        // deprecated old name
        Command
      ),
      Argument,
      Option,
      Help
    } = import_index.default);
  }
});

// src/logger.ts
import color from "../compiled/picocolors/index.js";
import { logger } from "../compiled/rslog/index.js";
function getTime() {
  const now = /* @__PURE__ */ new Date();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${hours}:${minutes}:${seconds}`;
}
var isDebug;
var init_logger = __esm({
  "src/logger.ts"() {
    "use strict";
    init_esm();
    isDebug = () => {
      if (!process.env.DEBUG) {
        return false;
      }
      const values = process.env.DEBUG.toLocaleLowerCase().split(",");
      return ["rsbuild", "builder", "*"].some((key) => values.includes(key));
    };
    if (isDebug()) {
      logger.level = "verbose";
    }
    logger.override({
      debug: (message, ...args) => {
        if (logger.level !== "verbose") {
          return;
        }
        const time = color.gray(`${getTime()}`);
        console.log(`  ${color.magenta("rsbuild")} ${time} ${message}`, ...args);
      }
    });
  }
});

// src/constants.ts
import { join } from "path";
var ROOT_DIST_DIR, HTML_DIST_DIR, JS_DIST_DIR, CSS_DIST_DIR, SVG_DIST_DIR, FONT_DIST_DIR, WASM_DIST_DIR, IMAGE_DIST_DIR, MEDIA_DIST_DIR, LOADER_PATH, STATIC_PATH, COMPILED_PATH, TS_CONFIG_FILE, HMR_SOCKET_PATH, RSBUILD_OUTPUTS_PATH, DEFAULT_PORT, DEFAULT_DATA_URL_SIZE, DEFAULT_MOUNT_ID, DEFAULT_DEV_HOST, DEFAULT_ASSET_PREFIX, DEFAULT_WEB_BROWSERSLIST, DEFAULT_BROWSERSLIST, HTML_REGEX, JS_REGEX, SCRIPT_REGEX, CSS_REGEX, NODE_MODULES_REGEX, PLUGIN_SWC_NAME, PLUGIN_CSS_NAME, FONT_EXTENSIONS, IMAGE_EXTENSIONS, VIDEO_EXTENSIONS, AUDIO_EXTENSIONS;
var init_constants = __esm({
  "src/constants.ts"() {
    "use strict";
    init_esm();
    ROOT_DIST_DIR = "dist";
    HTML_DIST_DIR = "./";
    JS_DIST_DIR = "static/js";
    CSS_DIST_DIR = "static/css";
    SVG_DIST_DIR = "static/svg";
    FONT_DIST_DIR = "static/font";
    WASM_DIST_DIR = "static/wasm";
    IMAGE_DIST_DIR = "static/image";
    MEDIA_DIST_DIR = "static/media";
    LOADER_PATH = join(__dirname);
    STATIC_PATH = join(__dirname, "../static");
    COMPILED_PATH = join(__dirname, "../compiled");
    TS_CONFIG_FILE = "tsconfig.json";
    HMR_SOCKET_PATH = "/rsbuild-hmr";
    RSBUILD_OUTPUTS_PATH = ".rsbuild";
    DEFAULT_PORT = 3e3;
    DEFAULT_DATA_URL_SIZE = 4096;
    DEFAULT_MOUNT_ID = "root";
    DEFAULT_DEV_HOST = "0.0.0.0";
    DEFAULT_ASSET_PREFIX = "/";
    DEFAULT_WEB_BROWSERSLIST = [
      "chrome >= 87",
      "edge >= 88",
      "firefox >= 78",
      "safari >= 14"
    ];
    DEFAULT_BROWSERSLIST = {
      web: DEFAULT_WEB_BROWSERSLIST,
      "web-worker": DEFAULT_WEB_BROWSERSLIST,
      node: ["node >= 16"]
    };
    HTML_REGEX = /\.html$/;
    JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/;
    SCRIPT_REGEX = /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/;
    CSS_REGEX = /\.css$/;
    NODE_MODULES_REGEX = /[\\/]node_modules[\\/]/;
    PLUGIN_SWC_NAME = "rsbuild:swc";
    PLUGIN_CSS_NAME = "rsbuild:css";
    FONT_EXTENSIONS = [
      "woff",
      "woff2",
      "eot",
      "ttf",
      "otf",
      "ttc"
    ];
    IMAGE_EXTENSIONS = [
      "png",
      "jpg",
      "jpeg",
      "pjpeg",
      "pjp",
      "gif",
      "bmp",
      "webp",
      "ico",
      "apng",
      "avif",
      "tif",
      "tiff",
      "jfif"
    ];
    VIDEO_EXTENSIONS = ["mp4", "webm", "ogg", "mov"];
    AUDIO_EXTENSIONS = [
      "mp3",
      "wav",
      "flac",
      "aac",
      "m4a",
      "opus"
    ];
  }
});

// ../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    init_esm();
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge5(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge5;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge5;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge5(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge5.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge5(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge5;
    module.exports = deepmerge_1;
  }
});

// src/helpers/fs.ts
import fs from "fs";
import path2 from "path";
function isEmptyDir(path22) {
  const files = fs.readdirSync(path22);
  return files.length === 0 || files.length === 1 && files[0] === ".git";
}
async function pathExists(path22) {
  return fs.promises.access(path22).then(() => true).catch(() => false);
}
async function isFileExists(file) {
  return fs.promises.access(file, fs.constants.F_OK).then(() => true).catch(() => false);
}
async function fileExistsByCompilation({ inputFileSystem }, filePath) {
  return new Promise((resolve2) => {
    if (!inputFileSystem) {
      resolve2(false);
      return;
    }
    inputFileSystem.stat(filePath, (err, stats) => {
      if (err) {
        resolve2(false);
      } else {
        resolve2(Boolean(stats?.isFile()));
      }
    });
  });
}
async function emptyDir(dir) {
  if (!await pathExists(dir)) {
    return;
  }
  try {
    for (const file of await fs.promises.readdir(dir)) {
      await fs.promises.rm(path2.resolve(dir, file), {
        recursive: true,
        force: true
      });
    }
  } catch (err) {
    logger.debug(`Failed to empty dir: ${dir}`);
    logger.debug(err);
  }
}
var isFileSync, findExists;
var init_fs = __esm({
  "src/helpers/fs.ts"() {
    "use strict";
    init_esm();
    init_logger();
    isFileSync = (filePath) => {
      try {
        return fs.statSync(filePath, { throwIfNoEntry: false })?.isFile();
      } catch (_) {
        return false;
      }
    };
    findExists = (files) => {
      for (const file of files) {
        if (isFileSync(file)) {
          return file;
        }
      }
      return false;
    };
  }
});

// src/helpers/path.ts
import { isAbsolute, join as join2, resolve, sep } from "path";
function getAbsolutePath(base, filepath) {
  return isAbsolute(filepath) ? filepath : join2(base, filepath);
}
function getCommonParentPath(paths) {
  const uniquePaths = [...new Set(paths)];
  if (uniquePaths.length === 1) {
    return uniquePaths[0];
  }
  const [first, ...rest] = uniquePaths.map((p) => p.split(sep));
  const common = [];
  for (let i = 0; i < first.length; i++) {
    const segment = first[i];
    if (rest.every((p) => p[i] === segment)) {
      common.push(segment);
    } else {
      break;
    }
  }
  return common.join(sep);
}
var getCompiledPath, ensureAbsolutePath, pathnameParse;
var init_path = __esm({
  "src/helpers/path.ts"() {
    "use strict";
    init_esm();
    init_constants();
    getCompiledPath = (packageName) => join2(COMPILED_PATH, packageName, "index.js");
    ensureAbsolutePath = (base, filePath) => isAbsolute(filePath) ? filePath : resolve(base, filePath);
    pathnameParse = (publicPath) => {
      try {
        return publicPath ? new URL(publicPath).pathname : publicPath;
      } catch (err) {
        return publicPath;
      }
    };
  }
});

// src/client/format.ts
function resolveFileName(stats) {
  if (stats.moduleIdentifier) {
    const regex = /(?:\!|^)([^!]+)$/;
    const matched = stats.moduleIdentifier.match(regex);
    if (matched) {
      const fileName = matched.pop();
      if (fileName) {
        return `File: ${fileName}:1:1
`;
      }
    }
  }
  const file = stats.file || stats.moduleName;
  return file ? `File: ${file}
` : "";
}
function hintUnknownFiles(message) {
  const hint = "You may need an appropriate loader to handle this file type.";
  if (message.indexOf(hint) === -1) {
    return message;
  }
  if (/File: .+\.s(c|a)ss/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Sass, use "@rsbuild/plugin-sass".`
    );
  }
  if (/File: .+\.less/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Less, use "@rsbuild/plugin-less".`
    );
  }
  if (/File: .+\.styl(us)?/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Stylus, use "@rsbuild/plugin-stylus".`
    );
  }
  return message;
}
function formatMessage(stats, verbose) {
  let lines = [];
  let message;
  if (typeof stats === "object") {
    const fileName = resolveFileName(stats);
    const mainMessage = stats.message;
    const details = verbose && stats.details ? `
Details: ${stats.details}
` : "";
    const stack = verbose && stats.stack ? `
${stats.stack}` : "";
    message = `${fileName}${mainMessage}${details}${stack}`;
  } else {
    message = stats;
  }
  message = hintUnknownFiles(message);
  lines = message.split("\n");
  lines = lines.filter(
    (line, index, arr) => index === 0 || line.trim() !== "" || line.trim() !== arr[index - 1].trim()
  );
  message = lines.join("\n");
  const innerError = "-- inner error --";
  if (!verbose && message.includes(innerError)) {
    message = message.split(innerError)[0];
  }
  return message.trim();
}
function formatStatsMessages(stats, verbose) {
  const formattedErrors = stats.errors?.map((error) => formatMessage(error, verbose)) || [];
  const formattedWarnings = stats.warnings?.map((warning) => formatMessage(warning, verbose)) || [];
  return {
    errors: formattedErrors,
    warnings: formattedWarnings
  };
}
var init_format = __esm({
  "src/client/format.ts"() {
    "use strict";
    init_esm();
  }
});

// src/helpers/stats.ts
import color2 from "../compiled/picocolors/index.js";
function formatErrorMessage(errors) {
  const messages = errors.map((error) => hintNodePolyfill(error));
  const text = `${messages.join("\n\n")}
`;
  const title = color2.bold(color2.red("Compile error: "));
  if (!errors.length) {
    return `${title}
${color2.yellow(`For more details, please setting 'stats.errors: true' `)}`;
  }
  const tip = color2.yellow(
    "Failed to compile, check the errors for troubleshooting."
  );
  return `${title}
${tip}
${text}`;
}
function getStatsOptions(compiler) {
  if (isMultiCompiler(compiler)) {
    return {
      children: compiler.compilers.map(
        (compiler2) => compiler2.options ? compiler2.options.stats : void 0
      )
    };
  }
  return compiler.options ? compiler.options.stats : void 0;
}
function formatStats(statsData, hasErrors) {
  const verbose = logger.level === "verbose";
  if (hasErrors) {
    const { errors } = formatStatsMessages(
      {
        errors: getAllStatsErrors(statsData),
        warnings: []
      },
      verbose
    );
    return {
      message: formatErrorMessage(errors),
      level: "error"
    };
  }
  const { warnings } = formatStatsMessages(
    {
      errors: [],
      warnings: getAllStatsWarnings(statsData)
    },
    verbose
  );
  if (warnings.length) {
    const title = color2.bold(color2.yellow("Compile Warning: \n"));
    return {
      message: `${title}${warnings.join("\n\n")}
`,
      level: "warning"
    };
  }
  return {};
}
var hintNodePolyfill, getAllStatsErrors, getAllStatsWarnings;
var init_stats = __esm({
  "src/helpers/stats.ts"() {
    "use strict";
    init_esm();
    init_format();
    init_logger();
    init_helpers();
    hintNodePolyfill = (message) => {
      const getTips = (moduleName2) => {
        const tips = [
          `Tip: "${moduleName2}" is a built-in Node.js module. It cannot be imported in client-side code.`,
          `Check if you need to import Node.js module. If needed, you can use ${color2.cyan("@rsbuild/plugin-node-polyfill")}.`
        ];
        return `${message}

${color2.yellow(tips.join("\n"))}`;
      };
      const isNodeProtocolError = message.includes(
        'need an additional plugin to handle "node:" URIs'
      );
      if (isNodeProtocolError) {
        return getTips("node:*");
      }
      if (!message.includes(`Can't resolve`)) {
        return message;
      }
      const matchArray = message.match(/Can't resolve '(\w+)'/);
      if (!matchArray) {
        return message;
      }
      const moduleName = matchArray[1];
      const nodeModules = [
        "assert",
        "buffer",
        "child_process",
        "cluster",
        "console",
        "constants",
        "crypto",
        "dgram",
        "dns",
        "domain",
        "events",
        "fs",
        "http",
        "https",
        "module",
        "net",
        "os",
        "path",
        "punycode",
        "process",
        "querystring",
        "readline",
        "repl",
        "stream",
        "_stream_duplex",
        "_stream_passthrough",
        "_stream_readable",
        "_stream_transform",
        "_stream_writable",
        "string_decoder",
        "sys",
        "timers",
        "tls",
        "tty",
        "url",
        "util",
        "vm",
        "zlib"
      ];
      if (moduleName && nodeModules.includes(moduleName)) {
        return getTips(moduleName);
      }
      return message;
    };
    getAllStatsErrors = (statsData) => {
      if (statsData.errorsCount && statsData.errors?.length === 0) {
        return statsData.children?.reduce(
          (errors, curr) => errors.concat(curr.errors || []),
          []
        );
      }
      return statsData.errors;
    };
    getAllStatsWarnings = (statsData) => {
      if (statsData.warningsCount && statsData.warnings?.length === 0) {
        return statsData.children?.reduce(
          (warnings, curr) => warnings.concat(curr.warnings || []),
          []
        );
      }
      return statsData.warnings;
    };
  }
});

// src/helpers/index.ts
import { posix } from "path";
import color3 from "../compiled/picocolors/index.js";
function getFilename2(config, type, isProd, isServer) {
  const { filename, filenameHash } = config.output;
  const getHash = () => {
    if (typeof filenameHash === "string") {
      return filenameHash ? `.[${filenameHash}]` : "";
    }
    return filenameHash ? ".[contenthash:8]" : "";
  };
  const hash = getHash();
  switch (type) {
    case "js":
      return filename.js ?? `[name]${isProd && !isServer ? hash : ""}.js`;
    case "css":
      return filename.css ?? `[name]${isProd ? hash : ""}.css`;
    case "svg":
      return filename.svg ?? `[name]${hash}.svg`;
    case "font":
      return filename.font ?? `[name]${hash}[ext]`;
    case "image":
      return filename.image ?? `[name]${hash}[ext]`;
    case "media":
      return filename.media ?? `[name]${hash}[ext]`;
    default:
      throw new Error(`unknown key ${type} in "output.filename"`);
  }
}
function partition(array, predicate) {
  const truthy = [];
  const falsy = [];
  for (const value of array) {
    if (predicate(value)) {
      truthy.push(value);
    } else {
      falsy.push(value);
    }
  }
  return [truthy, falsy];
}
function debounce(func, wait) {
  let timeoutId = null;
  return (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      func(...args);
    }, wait);
  };
}
function isWebTarget(target) {
  const targets = castArray(target);
  return targets.includes("web") || target.includes("web-worker");
}
function pick(obj, keys) {
  return keys.reduce(
    (ret, key) => {
      if (obj[key] !== void 0) {
        ret[key] = obj[key];
      }
      return ret;
    },
    {}
  );
}
var import_deepmerge, rspackMinVersion, getNodeEnv, setNodeEnv, isFunction, isObject, isPlainObject, castArray, cloneDeep, compareSemver, isSatisfyRspackVersion, removeLeadingSlash, removeTailingSlash, addTrailingSlash, formatPublicPath, getPublicPathFromChain, getPublicPathFromCompiler, urlJoin, canParse, ensureAssetPrefix, applyToCompiler, upperFirst, isURL, createVirtualModule, isMultiCompiler, camelCase, prettyTime;
var init_helpers = __esm({
  "src/helpers/index.ts"() {
    "use strict";
    init_esm();
    import_deepmerge = __toESM(require_cjs());
    init_constants();
    init_fs();
    init_path();
    init_stats();
    rspackMinVersion = "1.0.0";
    getNodeEnv = () => process.env.NODE_ENV;
    setNodeEnv = (env) => {
      process.env.NODE_ENV = env;
    };
    isFunction = (func) => typeof func === "function";
    isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    isPlainObject = (o) => {
      if (isObject(o) === false)
        return false;
      const ctor = o.constructor;
      if (ctor === void 0)
        return true;
      const prot = ctor.prototype;
      if (isObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
    castArray = (arr) => {
      if (arr === void 0) {
        return [];
      }
      return Array.isArray(arr) ? arr : [arr];
    };
    cloneDeep = (value) => {
      if (value === null || value === void 0) {
        return value;
      }
      return (0, import_deepmerge.default)({}, value, {
        isMergeableObject: isPlainObject
      });
    };
    compareSemver = (version1, version2) => {
      const parts1 = version1.split(".").map(Number);
      const parts2 = version2.split(".").map(Number);
      const len = Math.max(parts1.length, parts2.length);
      for (let i = 0; i < len; i++) {
        const item1 = parts1[i] ?? 0;
        const item2 = parts2[i] ?? 0;
        if (item1 > item2) {
          return 1;
        }
        if (item1 < item2) {
          return -1;
        }
      }
      return 0;
    };
    isSatisfyRspackVersion = async (originalVersion) => {
      let version2 = originalVersion;
      if (version2.includes("-canary")) {
        version2 = version2.split("-canary")[0];
      }
      if (version2 && /^[\d\.]+$/.test(version2)) {
        return compareSemver(version2, rspackMinVersion) >= 0;
      }
      return true;
    };
    removeLeadingSlash = (s) => s.replace(/^\/+/, "");
    removeTailingSlash = (s) => s.replace(/\/+$/, "");
    addTrailingSlash = (s) => s.endsWith("/") ? s : `${s}/`;
    formatPublicPath = (publicPath, withSlash = true) => {
      if (publicPath === "auto") {
        return publicPath;
      }
      return withSlash ? addTrailingSlash(publicPath) : removeTailingSlash(publicPath);
    };
    getPublicPathFromChain = (chain, withSlash = true) => {
      const publicPath = chain.output.get("publicPath");
      if (typeof publicPath === "string") {
        return formatPublicPath(publicPath, withSlash);
      }
      return formatPublicPath(DEFAULT_ASSET_PREFIX, withSlash);
    };
    getPublicPathFromCompiler = (compiler) => {
      const { publicPath } = compiler.options.output;
      if (typeof publicPath === "string") {
        if (publicPath === "auto") {
          return "";
        }
        return publicPath.endsWith("/") ? publicPath : `${publicPath}/`;
      }
      return DEFAULT_ASSET_PREFIX;
    };
    urlJoin = (base, path22) => {
      const [urlProtocol, baseUrl] = base.split("://");
      return `${urlProtocol}://${posix.join(baseUrl, path22)}`;
    };
    canParse = (url2) => {
      try {
        new URL(url2);
        return true;
      } catch {
        return false;
      }
    };
    ensureAssetPrefix = (url2, assetPrefix = DEFAULT_ASSET_PREFIX) => {
      if (url2.startsWith("//")) {
        return url2;
      }
      if (canParse(url2)) {
        return url2;
      }
      if (assetPrefix === "auto") {
        return url2;
      }
      if (typeof assetPrefix === "function") {
        return url2;
      }
      if (assetPrefix.startsWith("http")) {
        return urlJoin(assetPrefix, url2);
      }
      if (assetPrefix.startsWith("//")) {
        return urlJoin(`https:${assetPrefix}`, url2).replace("https:", "");
      }
      return posix.join(assetPrefix, url2);
    };
    applyToCompiler = (compiler, apply) => {
      if (isMultiCompiler(compiler)) {
        compiler.compilers.forEach(apply);
      } else {
        apply(compiler, 0);
      }
    };
    upperFirst = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
    isURL = (str) => str.startsWith("http") || str.startsWith("//:");
    createVirtualModule = (content) => `data:text/javascript,${content}`;
    isMultiCompiler = (compiler) => {
      return compiler.constructor.name === "MultiCompiler";
    };
    camelCase = (input) => input.replace(/[-_](\w)/g, (_, c) => c.toUpperCase());
    prettyTime = (seconds) => {
      const format = (time) => color3.bold(time);
      if (seconds < 10) {
        const digits = seconds >= 0.01 ? 2 : 3;
        return `${format(seconds.toFixed(digits))} s`;
      }
      if (seconds < 60) {
        return `${format(seconds.toFixed(1))} s`;
      }
      const minutes = seconds / 60;
      return `${format(minutes.toFixed(2))} m`;
    };
  }
});

// src/mergeConfig.ts
var OVERRIDE_PATHS, isOverridePath, merge, mergeRsbuildConfig;
var init_mergeConfig = __esm({
  "src/mergeConfig.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    OVERRIDE_PATHS = [
      "performance.removeConsole",
      "output.inlineScripts",
      "output.inlineStyles",
      "output.cssModules.auto",
      "output.overrideBrowserslist",
      "server.open",
      "server.printUrls",
      "provider"
    ];
    isOverridePath = (key) => {
      if (key.startsWith("environments.")) {
        const realKey = key.split(".").slice(2).join(".");
        return OVERRIDE_PATHS.includes(realKey);
      }
      return OVERRIDE_PATHS.includes(key);
    };
    merge = (x, y, path22 = "") => {
      if (isOverridePath(path22)) {
        return y ?? x;
      }
      if (x === void 0) {
        return isPlainObject(y) ? cloneDeep(y) : y;
      }
      if (y === void 0) {
        return isPlainObject(x) ? cloneDeep(x) : x;
      }
      if (typeof x === "boolean" || typeof y === "boolean") {
        return y;
      }
      const pair = [x, y];
      if (pair.some(Array.isArray)) {
        return [...castArray(x), ...castArray(y)];
      }
      if (pair.some(isFunction)) {
        return pair;
      }
      if (!isPlainObject(x) || !isPlainObject(y)) {
        return y;
      }
      const merged = {};
      const keys = /* @__PURE__ */ new Set([...Object.keys(x), ...Object.keys(y)]);
      for (const key of keys) {
        const childPath = path22 ? `${path22}.${key}` : key;
        merged[key] = merge(x[key], y[key], childPath);
      }
      return merged;
    };
    mergeRsbuildConfig = (...configs) => {
      if (configs.length === 2) {
        return merge(configs[0], configs[1]);
      }
      if (configs.length < 2) {
        return configs[0];
      }
      return configs.reduce(
        (result, config) => merge(result, config),
        {}
      );
    };
  }
});

// src/server/restart.ts
import path3 from "path";
import color4 from "../compiled/picocolors/index.js";
var cleaners, onBeforeRestartServer, clearConsole, restartDevServer;
var init_restart = __esm({
  "src/server/restart.ts"() {
    "use strict";
    init_esm();
    init_init();
    init_logger();
    cleaners = [];
    onBeforeRestartServer = (cleaner) => {
      cleaners.push(cleaner);
    };
    clearConsole = () => {
      if (process.stdout.isTTY && !process.env.DEBUG) {
        process.stdout.write("\x1B[H\x1B[2J");
      }
    };
    restartDevServer = async ({
      filePath,
      clear = true
    } = {}) => {
      if (clear) {
        clearConsole();
      }
      if (filePath) {
        const filename = path3.basename(filePath);
        logger.info(
          `Restart server because ${color4.yellow(filename)} is changed.
`
        );
      } else {
        logger.info("Restarting server...\n");
      }
      for (const cleaner of cleaners) {
        await cleaner();
        cleaners = [];
      }
      const rsbuild = await init({ isRestart: true });
      if (!rsbuild) {
        return;
      }
      await rsbuild.startDevServer();
    };
  }
});

// src/config.ts
import fs2 from "fs";
import { isAbsolute as isAbsolute2, join as join3 } from "path";
import color5 from "../compiled/picocolors/index.js";
import RspackChain from "../compiled/rspack-chain/index.js";
function getDefaultEntry(root) {
  const files = [
    // Most projects are using typescript now.
    // So we put `.ts` as the first one to improve performance.
    "ts",
    "js",
    "tsx",
    "jsx",
    "mjs",
    "cjs"
  ].map((ext) => join3(root, `src/index.${ext}`));
  const entryFile = findExists(files);
  if (entryFile) {
    return {
      index: entryFile
    };
  }
  return {};
}
function defineConfig(config) {
  return config;
}
async function watchFilesForRestart(files, watchOptions) {
  if (!files.length) {
    return;
  }
  const chokidar = await import("../compiled/chokidar/index.js");
  const watcher = chokidar.watch(files, {
    // do not trigger add for initial files
    ignoreInitial: true,
    // If watching fails due to read permissions, the errors will be suppressed silently.
    ignorePermissionErrors: true,
    ...watchOptions
  });
  const callback = debounce(
    async (filePath) => {
      watcher.close();
      await restartDevServer({ filePath });
    },
    // set 300ms debounce to avoid restart frequently
    300
  );
  watcher.on("add", callback);
  watcher.on("change", callback);
  watcher.on("unlink", callback);
}
async function loadConfig({
  cwd = process.cwd(),
  path: path22,
  envMode
} = {}) {
  const configFilePath = resolveConfigPath(cwd, path22);
  if (!configFilePath) {
    return {
      content: {},
      filePath: configFilePath
    };
  }
  const applyMetaInfo = (config) => {
    config._privateMeta = { configFilePath };
    return config;
  };
  let configExport;
  if (/\.(?:js|mjs|cjs)$/.test(configFilePath)) {
    try {
      const exportModule = await import(`${configFilePath}?t=${Date.now()}`);
      configExport = exportModule.default ? exportModule.default : exportModule;
    } catch (err) {
      logger.debug(
        `Failed to load file with dynamic import: ${color5.dim(configFilePath)}`
      );
    }
  }
  try {
    if (configExport === void 0) {
      const { default: jiti } = await import("../compiled/jiti/index.js");
      const loadConfig3 = jiti(__filename, {
        esmResolve: true,
        // disable require cache to support restart CLI and read the new config
        requireCache: false,
        interopDefault: true
      });
      configExport = loadConfig3(configFilePath);
    }
  } catch (err) {
    logger.error(`Failed to load file with jiti: ${color5.dim(configFilePath)}`);
    throw err;
  }
  if (typeof configExport === "function") {
    const command = process.argv[2];
    const nodeEnv = getNodeEnv();
    const params = {
      env: nodeEnv,
      command,
      envMode: envMode || nodeEnv
    };
    const result = await configExport(params);
    if (result === void 0) {
      throw new Error("The config function must return a config object.");
    }
    return {
      content: applyMetaInfo(result),
      filePath: configFilePath
    };
  }
  if (!isObject(configExport)) {
    throw new Error(
      `The config must be an object or a function that returns an object, get ${color5.yellow(
        configExport
      )}`
    );
  }
  return {
    content: applyMetaInfo(configExport),
    filePath: configFilePath
  };
}
async function outputInspectConfigFiles({
  rawBundlerConfigs,
  rawEnvironmentConfigs,
  inspectOptions,
  configType
}) {
  const { outputPath } = inspectOptions;
  const files = [
    ...rawEnvironmentConfigs.map(({ name, content }) => {
      if (rawEnvironmentConfigs.length === 1) {
        const outputFile2 = "rsbuild.config.mjs";
        const outputFilePath2 = join3(outputPath, outputFile2);
        return {
          path: outputFilePath2,
          label: "Rsbuild Config",
          content
        };
      }
      const outputFile = `rsbuild.config.${name}.mjs`;
      const outputFilePath = join3(outputPath, outputFile);
      return {
        path: outputFilePath,
        label: `Rsbuild Config (${name})`,
        content
      };
    }),
    ...rawBundlerConfigs.map(({ name, content }) => {
      const outputFile = `${configType}.config.${name}.mjs`;
      let outputFilePath = join3(outputPath, outputFile);
      if (fs2.existsSync(outputFilePath)) {
        outputFilePath = outputFilePath.replace(/\.mjs$/, `.${Date.now()}.mjs`);
      }
      return {
        path: outputFilePath,
        label: `${upperFirst(configType)} Config (${name})`,
        content
      };
    })
  ];
  await fs2.promises.mkdir(outputPath, { recursive: true });
  await Promise.all(
    files.map(async (item) => {
      return fs2.promises.writeFile(item.path, `export default ${item.content}`);
    })
  );
  const fileInfos = files.map(
    (item) => `  - ${color5.bold(color5.yellow(item.label))}: ${color5.underline(
      item.path
    )}`
  ).join("\n");
  logger.success(
    `Inspect config succeed, open following files to view the content: 

${fileInfos}
`
  );
}
function stringifyConfig(config, verbose) {
  const stringify = RspackChain.toString;
  return stringify(config, { verbose });
}
var getDefaultDevConfig, getDefaultServerConfig, getDefaultSourceConfig, getDefaultHtmlConfig, getDefaultSecurityConfig, getDefaultToolsConfig, getDefaultPerformanceConfig, getDefaultOutputConfig, createDefaultConfig, withDefaultConfig, normalizeConfig, resolveConfigPath, getRsbuildInspectConfig, normalizePublicDirs;
var init_config = __esm({
  "src/config.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    init_logger();
    init_mergeConfig();
    init_restart();
    getDefaultDevConfig = () => ({
      hmr: true,
      liveReload: true,
      // Temporary placeholder, default: `${server.base}`
      assetPrefix: DEFAULT_ASSET_PREFIX,
      writeToDisk: false,
      cliShortcuts: false,
      client: {
        path: HMR_SOCKET_PATH,
        port: "",
        host: "",
        overlay: true,
        reconnect: 100
      }
    });
    getDefaultServerConfig = () => ({
      port: DEFAULT_PORT,
      host: DEFAULT_DEV_HOST,
      open: false,
      base: "/",
      htmlFallback: "index",
      compress: true,
      printUrls: true,
      strictPort: false
    });
    getDefaultSourceConfig = () => ({
      alias: {},
      define: {},
      aliasStrategy: "prefer-tsconfig",
      preEntry: [],
      decorators: {
        version: "2022-03"
      }
    });
    getDefaultHtmlConfig = () => ({
      meta: {
        charset: { charset: "UTF-8" },
        viewport: "width=device-width, initial-scale=1.0"
      },
      title: "Rsbuild App",
      inject: "head",
      mountId: DEFAULT_MOUNT_ID,
      crossorigin: false,
      outputStructure: "flat",
      scriptLoading: "defer"
    });
    getDefaultSecurityConfig = () => ({
      nonce: "",
      sri: {
        enable: false
      }
    });
    getDefaultToolsConfig = () => ({
      cssExtract: {
        loaderOptions: {},
        pluginOptions: {
          ignoreOrder: true
        }
      }
    });
    getDefaultPerformanceConfig = () => ({
      profile: false,
      buildCache: true,
      printFileSize: true,
      removeConsole: false,
      removeMomentLocale: false,
      chunkSplit: {
        strategy: "split-by-experience"
      }
    });
    getDefaultOutputConfig = () => ({
      target: "web",
      cleanDistPath: "auto",
      distPath: {
        root: ROOT_DIST_DIR,
        css: CSS_DIST_DIR,
        svg: SVG_DIST_DIR,
        font: FONT_DIST_DIR,
        html: HTML_DIST_DIR,
        wasm: WASM_DIST_DIR,
        image: IMAGE_DIST_DIR,
        media: MEDIA_DIST_DIR
      },
      // Temporary placeholder, default: `${server.base}`
      assetPrefix: DEFAULT_ASSET_PREFIX,
      filename: {},
      charset: "utf8",
      polyfill: "off",
      dataUriLimit: {
        svg: DEFAULT_DATA_URL_SIZE,
        font: DEFAULT_DATA_URL_SIZE,
        image: DEFAULT_DATA_URL_SIZE,
        media: DEFAULT_DATA_URL_SIZE
      },
      legalComments: "linked",
      injectStyles: false,
      minify: true,
      manifest: false,
      sourceMap: {
        js: void 0,
        css: false
      },
      filenameHash: true,
      inlineScripts: false,
      inlineStyles: false,
      cssModules: {
        auto: true,
        namedExport: false,
        exportGlobals: false,
        exportLocalsConvention: "camelCase"
      },
      emitAssets: true
    });
    createDefaultConfig = () => ({
      dev: getDefaultDevConfig(),
      server: getDefaultServerConfig(),
      html: getDefaultHtmlConfig(),
      source: getDefaultSourceConfig(),
      output: getDefaultOutputConfig(),
      tools: getDefaultToolsConfig(),
      security: getDefaultSecurityConfig(),
      performance: getDefaultPerformanceConfig(),
      environments: {}
    });
    withDefaultConfig = async (rootPath, config) => {
      const merged = mergeRsbuildConfig(createDefaultConfig(), config);
      merged.root ||= rootPath;
      merged.source ||= {};
      if (merged.server?.base) {
        if (config.dev?.assetPrefix === void 0) {
          merged.dev ||= {};
          merged.dev.assetPrefix = merged.server.base;
        }
        if (config.output?.assetPrefix === void 0) {
          merged.output ||= {};
          merged.output.assetPrefix = merged.server.base;
        }
      }
      if (!merged.source.tsconfigPath) {
        const tsconfigPath = join3(rootPath, TS_CONFIG_FILE);
        if (await isFileExists(tsconfigPath)) {
          merged.source.tsconfigPath = tsconfigPath;
        }
      }
      return merged;
    };
    normalizeConfig = (config) => {
      const getMode = () => {
        if (config.mode) {
          return config.mode;
        }
        const nodeEnv = getNodeEnv();
        return nodeEnv === "production" || nodeEnv === "development" ? nodeEnv : "none";
      };
      return mergeRsbuildConfig(
        {
          ...createDefaultConfig(),
          mode: getMode()
        },
        config
      );
    };
    resolveConfigPath = (root, customConfig) => {
      if (customConfig) {
        const customConfigPath = isAbsolute2(customConfig) ? customConfig : join3(root, customConfig);
        if (fs2.existsSync(customConfigPath)) {
          return customConfigPath;
        }
        logger.warn(`Cannot find config file: ${color5.dim(customConfigPath)}
`);
      }
      const CONFIG_FILES = [
        // `.mjs` and `.ts` are the most used configuration types,
        // so we resolve them first for performance
        "rsbuild.config.mjs",
        "rsbuild.config.ts",
        "rsbuild.config.js",
        "rsbuild.config.cjs",
        "rsbuild.config.mts",
        "rsbuild.config.cts"
      ];
      for (const file of CONFIG_FILES) {
        const configFile = join3(root, file);
        if (fs2.existsSync(configFile)) {
          return configFile;
        }
      }
      return null;
    };
    getRsbuildInspectConfig = ({
      normalizedConfig,
      inspectOptions,
      pluginManager
    }) => {
      const { environments, ...rsbuildConfig } = normalizedConfig;
      const pluginNames = pluginManager.getPlugins().map((p) => p.name);
      const rsbuildDebugConfig = {
        ...rsbuildConfig,
        pluginNames
      };
      const rawRsbuildConfig = stringifyConfig(
        rsbuildDebugConfig,
        inspectOptions.verbose
      );
      const environmentConfigs = {};
      const rawEnvironmentConfigs = [];
      for (const [name, config] of Object.entries(environments)) {
        const debugConfig = {
          ...config,
          pluginNames: pluginManager.getPlugins({ environment: name }).map((p) => p.name)
        };
        rawEnvironmentConfigs.push({
          name,
          content: stringifyConfig(debugConfig, inspectOptions.verbose)
        });
        environmentConfigs[name] = debugConfig;
      }
      return {
        rsbuildConfig: rsbuildDebugConfig,
        rawRsbuildConfig,
        environmentConfigs,
        rawEnvironmentConfigs
      };
    };
    normalizePublicDirs = (publicDir) => {
      if (publicDir === false) {
        return [];
      }
      const defaultConfig = {
        name: "public",
        copyOnBuild: true,
        watch: false
      };
      if (publicDir === void 0) {
        return [defaultConfig];
      }
      if (Array.isArray(publicDir)) {
        return publicDir.map((options) => ({
          ...defaultConfig,
          ...options
        }));
      }
      return [
        {
          ...defaultConfig,
          ...publicDir
        }
      ];
    };
  }
});

// ../../node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/package.json"(exports, module) {
    module.exports = {
      name: "dotenv",
      version: "16.4.5",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        "test:coverage": "tap --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// ../../node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/dotenv@16.4.5/node_modules/dotenv/lib/main.js"(exports, module) {
    "use strict";
    init_esm();
    var fs12 = __require("fs");
    var path22 = __require("path");
    var os2 = __require("os");
    var crypto3 = __require("crypto");
    var packageJson = require_package();
    var version2 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse3(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version2}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version2}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version2}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs12.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path22.resolve(process.cwd(), ".env.vault");
      }
      if (fs12.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path22.join(os2.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path22.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path23 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs12.readFileSync(path23, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path23} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto3.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse3,
      populate
    };
    module.exports.configDotenv = DotenvModule.configDotenv;
    module.exports._configVault = DotenvModule._configVault;
    module.exports._parseVault = DotenvModule._parseVault;
    module.exports.config = DotenvModule.config;
    module.exports.decrypt = DotenvModule.decrypt;
    module.exports.parse = DotenvModule.parse;
    module.exports.populate = DotenvModule.populate;
    module.exports = DotenvModule;
  }
});

// ../../node_modules/.pnpm/dotenv-expand@11.0.6/node_modules/dotenv-expand/lib/main.js
var require_main2 = __commonJS({
  "../../node_modules/.pnpm/dotenv-expand@11.0.6/node_modules/dotenv-expand/lib/main.js"(exports, module) {
    "use strict";
    init_esm();
    var DOTENV_SUBSTITUTION_REGEX = /(\\)?(\$)(?!\()(\{?)([\w.]+)(?::?-((?:\$\{(?:\$\{(?:\$\{[^}]*\}|[^}])*}|[^}])*}|[^}])+))?(\}?)/gi;
    function _resolveEscapeSequences(value) {
      return value.replace(/\\\$/g, "$");
    }
    function interpolate(value, processEnv, parsed) {
      return value.replace(DOTENV_SUBSTITUTION_REGEX, (match, escaped, dollarSign, openBrace, key, defaultValue, closeBrace) => {
        if (escaped === "\\") {
          return match.slice(1);
        } else {
          if (processEnv[key]) {
            if (processEnv[key] === parsed[key]) {
              return processEnv[key];
            } else {
              return interpolate(processEnv[key], processEnv, parsed);
            }
          }
          if (parsed[key]) {
            if (parsed[key] === value) {
              return parsed[key];
            } else {
              return interpolate(parsed[key], processEnv, parsed);
            }
          }
          if (defaultValue) {
            if (defaultValue.startsWith("$")) {
              return interpolate(defaultValue, processEnv, parsed);
            } else {
              return defaultValue;
            }
          }
          return "";
        }
      });
    }
    function expand2(options) {
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      for (const key in options.parsed) {
        let value = options.parsed[key];
        const inProcessEnv = Object.prototype.hasOwnProperty.call(processEnv, key);
        if (inProcessEnv) {
          if (processEnv[key] === options.parsed[key]) {
            value = interpolate(value, processEnv, options.parsed);
          } else {
            value = processEnv[key];
          }
        } else {
          value = interpolate(value, processEnv, options.parsed);
        }
        options.parsed[key] = _resolveEscapeSequences(value);
      }
      for (const processKey in options.parsed) {
        processEnv[processKey] = options.parsed[processKey];
      }
      return options;
    }
    module.exports.expand = expand2;
  }
});

// src/loadEnv.ts
import fs3 from "fs";
import { join as join4 } from "path";
function loadEnv({
  cwd = process.cwd(),
  mode = getNodeEnv(),
  prefixes = ["PUBLIC_"]
} = {}) {
  if (mode === "local") {
    throw new Error(
      `'local' cannot be used as a value for env mode, because ".env.local" represents a temporary local file. Please use another value.`
    );
  }
  const filenames = [
    ".env",
    ".env.local",
    `.env.${mode}`,
    `.env.${mode}.local`
  ];
  const filePaths = filenames.map((filename) => join4(cwd, filename)).filter(isFileSync);
  const parsed = {};
  for (const envPath of filePaths) {
    Object.assign(parsed, (0, import_dotenv.parse)(fs3.readFileSync(envPath)));
  }
  if (parsed.NODE_ENV) {
    process.env.NODE_ENV = parsed.NODE_ENV;
  }
  (0, import_dotenv_expand.expand)({ parsed });
  const publicVars = {};
  for (const key of Object.keys(process.env)) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      const val = process.env[key];
      publicVars[`import.meta.env.${key}`] = JSON.stringify(val);
      publicVars[`process.env.${key}`] = JSON.stringify(val);
    }
  }
  let cleaned = false;
  const cleanup = () => {
    if (cleaned) {
      return;
    }
    for (const key of Object.keys(parsed)) {
      if (key === "NODE_ENV") {
        continue;
      }
      if (process.env[key] === parsed[key]) {
        delete process.env[key];
      }
    }
    cleaned = true;
  };
  return {
    parsed,
    cleanup,
    filePaths,
    publicVars
  };
}
var import_dotenv, import_dotenv_expand;
var init_loadEnv = __esm({
  "src/loadEnv.ts"() {
    "use strict";
    init_esm();
    import_dotenv = __toESM(require_main());
    import_dotenv_expand = __toESM(require_main2());
    init_helpers();
  }
});

// ../../node_modules/.pnpm/browserslist-load-config@0.1.1/node_modules/browserslist-load-config/dist/index.js
import fs4 from "fs";
import path4 from "path";
function isFile(file) {
  if (file in isFileCache) {
    return isFileCache[file];
  }
  const result = fs4.existsSync(file) && fs4.statSync(file).isFile();
  isFileCache[file] = result;
  return result;
}
function check(section) {
  const FORMAT = "Browserslist config should be a string or an array of strings with browser queries";
  if (Array.isArray(section)) {
    for (let i = 0; i < section.length; i++) {
      if (typeof section[i] !== "string") {
        throw new BrowserslistError(FORMAT);
      }
    }
  } else if (typeof section !== "string") {
    throw new BrowserslistError(FORMAT);
  }
}
function parsePackage(file) {
  const config = JSON.parse(
    fs4.readFileSync(file).toString().replace(/^\uFEFF/m, "")
  );
  if (config.browserlist && !config.browserslist) {
    throw new BrowserslistError(
      `\`browserlist\` key instead of \`browserslist\` in ${file}`
    );
  }
  let list = config.browserslist;
  if (Array.isArray(list)) {
    list = { defaults: list };
  }
  if (typeof list === "string") {
    list = parseConfig(list);
  }
  for (const i in list) {
    check(list[i]);
  }
  return list;
}
function parseConfig(string) {
  const result = { defaults: [] };
  let sections = ["defaults"];
  string.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map((line) => line.trim()).filter((line) => line !== "").forEach((line) => {
    const matched = line.match(IS_SECTION);
    if (matched) {
      sections = matched[1].trim().split(" ");
      sections.forEach((section) => {
        if (result[section]) {
          throw new BrowserslistError(
            `Duplicate section ${section} in Browserslist config`
          );
        }
        result[section] = [];
      });
    } else {
      sections.forEach((section) => {
        result[section].push(line);
      });
    }
  });
  return result;
}
function readConfig(file) {
  if (!isFile(file)) {
    throw new BrowserslistError(`Can't read ${file} config`);
  }
  return parseConfig(fs4.readFileSync(file, "utf-8"));
}
function parsePackageOrReadConfig(file) {
  if (path4.basename(file) === "package.json") {
    return parsePackage(file);
  }
  return readConfig(file);
}
function pickEnv(config, opts) {
  if (typeof config !== "object") {
    return config;
  }
  let name;
  if (typeof opts.env === "string") {
    name = opts.env;
  } else if (process.env.BROWSERSLIST_ENV) {
    name = process.env.BROWSERSLIST_ENV;
  } else if (process.env.NODE_ENV) {
    name = process.env.NODE_ENV;
  } else {
    name = "production";
  }
  return config[name] || config.defaults;
}
function eachParent(file, callback) {
  const dir = isFile(file) ? path4.dirname(file) : file;
  let loc = path4.resolve(dir);
  do {
    const result = callback(loc);
    if (typeof result !== "undefined")
      return result;
  } while (loc !== (loc = path4.dirname(loc)));
  return void 0;
}
function findConfigFile(from) {
  return eachParent(from, (dir) => {
    const config = path4.join(dir, "browserslist");
    const pkg = path4.join(dir, "package.json");
    const rc = path4.join(dir, ".browserslistrc");
    let pkgBrowserslist;
    if (isFile(pkg)) {
      try {
        pkgBrowserslist = parsePackage(pkg);
      } catch (e) {
        if (e instanceof BrowserslistError)
          throw e;
        console.warn(`[Browserslist] Could not parse ${pkg}. Ignoring it.`);
      }
    }
    if (isFile(config) && pkgBrowserslist) {
      throw new BrowserslistError(
        `${dir} contains both browserslist and package.json with browsers`
      );
    }
    if (isFile(rc) && pkgBrowserslist) {
      throw new BrowserslistError(
        `${dir} contains both .browserslistrc and package.json with browsers`
      );
    }
    if (isFile(config) && isFile(rc)) {
      throw new BrowserslistError(
        `${dir} contains both .browserslistrc and browserslist`
      );
    }
    if (isFile(config)) {
      return config;
    }
    if (isFile(rc)) {
      return rc;
    }
    if (pkgBrowserslist) {
      return pkg;
    }
  });
}
function findConfig(from) {
  from = path4.resolve(from);
  const fromDir = isFile(from) ? path4.dirname(from) : from;
  if (fromDir in configCache) {
    return configCache[fromDir];
  }
  let resolved;
  const configFile = findConfigFile(from);
  if (configFile) {
    resolved = parsePackageOrReadConfig(configFile);
  }
  const configDir = configFile && path4.dirname(configFile);
  eachParent(from, (dir) => {
    if (resolved) {
      configCache[dir] = resolved;
    }
    if (dir === configDir) {
      return null;
    }
  });
  return resolved;
}
function loadConfig2(opts) {
  if (opts.config) {
    return pickEnv(parsePackageOrReadConfig(opts.config), opts);
  }
  if (opts.path) {
    const config = findConfig(opts.path);
    if (!config) {
      return void 0;
    }
    return pickEnv(config, opts);
  }
  return void 0;
}
var BrowserslistError, isFileCache, IS_SECTION, configCache;
var init_dist = __esm({
  "../../node_modules/.pnpm/browserslist-load-config@0.1.1/node_modules/browserslist-load-config/dist/index.js"() {
    "use strict";
    init_esm();
    BrowserslistError = class _BrowserslistError extends Error {
      constructor(message) {
        super(message);
        this.name = "BrowserslistError";
        this.browserslist = true;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _BrowserslistError);
        }
      }
    };
    isFileCache = {};
    IS_SECTION = /^\s*\[(.+)]\s*$/;
    configCache = {};
  }
});

// src/pluginManager.ts
import color6 from "../compiled/picocolors/index.js";
function validatePlugin(plugin) {
  const type = typeof plugin;
  if (type !== "object" || plugin === null) {
    throw new Error(
      `Expect Rsbuild plugin instance to be an object, but got ${type}.`
    );
  }
  if (isFunction(plugin.setup)) {
    return;
  }
  if (isFunction(plugin.apply)) {
    const { name = "SomeWebpackPlugin" } = plugin.constructor || {};
    const messages = [
      `${color6.yellow(
        name
      )} looks like a Webpack or Rspack plugin, please use ${color6.yellow(
        "`tools.rspack`"
      )} to register it:`,
      color6.green(`
  // rsbuild.config.ts
  export default {
    tools: {
      rspack: {
        plugins: [new ${name}()]
      }
    }
  };
`)
    ];
    throw new Error(messages.join("\n"));
  }
  throw new Error(
    `Expect Rsbuild plugin.setup to be a function, but got ${type}.`
  );
}
function createPluginManager() {
  let plugins = [];
  const addPlugins = (newPlugins, options) => {
    const { before, environment = RSBUILD_ALL_ENVIRONMENT_SYMBOL } = options || {};
    for (const newPlugin of newPlugins) {
      if (!newPlugin) {
        continue;
      }
      validatePlugin(newPlugin);
      const existPlugin = plugins.find(
        (item) => item.instance.name === newPlugin.name && item.environment === environment
      );
      if (existPlugin) {
        logger.warn(
          `Rsbuild plugin "${newPlugin.name}" registered multiple times.`
        );
      } else if (before) {
        const index = plugins.findIndex(
          (item) => item.instance.name === before
        );
        if (index === -1) {
          logger.warn(`Plugin "${before}" does not exist.`);
          plugins.push({
            environment,
            instance: newPlugin
          });
        } else {
          plugins.splice(index, 0, {
            environment,
            instance: newPlugin
          });
        }
      } else {
        plugins.push({
          environment,
          instance: newPlugin
        });
      }
    }
  };
  const removePlugins = (pluginNames, options = {}) => {
    plugins = plugins.filter(
      (plugin) => !(pluginNames.includes(plugin.instance.name) && (!options.environment || plugin.environment === options.environment))
    );
  };
  const isPluginExists = (pluginName, options = {
    environment: RSBUILD_ALL_ENVIRONMENT_SYMBOL
  }) => Boolean(
    plugins.find(
      (plugin) => plugin.instance.name === pluginName && isPluginMatchEnvironment(plugin.environment, options.environment)
    )
  );
  const getPlugins = (options = {
    environment: RSBUILD_ALL_ENVIRONMENT_SYMBOL
  }) => {
    return plugins.filter(
      (p) => isPluginMatchEnvironment(p.environment, options.environment)
    ).map((p) => p.instance);
  };
  return {
    getPlugins,
    getAllPluginsWithMeta: () => plugins,
    addPlugins,
    removePlugins,
    isPluginExists
  };
}
async function initPlugins({
  getPluginAPI,
  pluginManager
}) {
  logger.debug("init plugins");
  const plugins = pluginDagSort(pluginManager.getAllPluginsWithMeta());
  const removedPlugins = plugins.reduce(
    (ret, plugin) => {
      if (plugin.instance.remove) {
        ret[plugin.environment] ??= [];
        ret[plugin.environment].push(...plugin.instance.remove);
      }
      return ret;
    },
    {}
  );
  for (const plugin of plugins) {
    const isGlobalPlugin = plugin.environment === "RSBUILD_ALL_ENVIRONMENT_SYMBOL";
    if (removedPlugins[plugin.environment]?.includes(plugin.instance.name) || !isGlobalPlugin && removedPlugins[RSBUILD_ALL_ENVIRONMENT_SYMBOL]?.includes(
      plugin.instance.name
    )) {
      continue;
    }
    const { instance, environment } = plugin;
    await instance.setup(getPluginAPI(environment));
  }
  logger.debug("init plugins done");
}
var RSBUILD_ALL_ENVIRONMENT_SYMBOL, isPluginMatchEnvironment, pluginDagSort;
var init_pluginManager = __esm({
  "src/pluginManager.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_logger();
    RSBUILD_ALL_ENVIRONMENT_SYMBOL = "RSBUILD_ALL_ENVIRONMENT_SYMBOL";
    isPluginMatchEnvironment = (pluginEnvironment, currentEnvironment) => pluginEnvironment === currentEnvironment || pluginEnvironment === RSBUILD_ALL_ENVIRONMENT_SYMBOL;
    pluginDagSort = (plugins) => {
      let allLines = [];
      function getPlugin(name) {
        const targets = plugins.filter((item) => item.instance.name === name);
        if (!targets.length) {
          throw new Error(`plugin ${name} not existed`);
        }
        return targets;
      }
      for (const plugin of plugins) {
        if (plugin.instance.pre) {
          for (const pre of plugin.instance.pre) {
            if (pre && plugins.some((item) => item.instance.name === pre)) {
              allLines.push([pre, plugin.instance.name]);
            }
          }
        }
        if (plugin.instance.post) {
          for (const post of plugin.instance.post) {
            if (post && plugins.some((item) => item.instance.name === post)) {
              allLines.push([plugin.instance.name, post]);
            }
          }
        }
      }
      let zeroEndPoints = plugins.filter(
        (item) => !allLines.find((l) => l[1] === item.instance.name)
      );
      const sortedPoint = [];
      while (zeroEndPoints.length) {
        const zep = zeroEndPoints.shift();
        sortedPoint.push(...getPlugin(zep.instance.name));
        allLines = allLines.filter(
          (l) => l[0] !== getPlugin(zep.instance.name)[0].instance.name
        );
        const restPoints = plugins.filter(
          (item) => !sortedPoint.find((sp) => sp.instance.name === item.instance.name)
        );
        zeroEndPoints = restPoints.filter(
          (item) => !allLines.find((l) => l[1] === item.instance.name)
        );
      }
      if (allLines.length) {
        const restInRingPoints = {};
        for (const l of allLines) {
          restInRingPoints[l[0]] = true;
          restInRingPoints[l[1]] = true;
        }
        throw new Error(
          `plugins dependencies has loop: ${Object.keys(restInRingPoints).join(
            ","
          )}`
        );
      }
      return sortedPoint;
    };
  }
});

// src/hooks.ts
function createEnvironmentAsyncHook() {
  const preGroup = [];
  const postGroup = [];
  const defaultGroup = [];
  const tapEnvironment = ({
    environment,
    handler: cb
  }) => {
    if (isFunction(cb)) {
      defaultGroup.push({
        environment,
        handler: cb
      });
    } else if (cb.order === "pre") {
      preGroup.push({
        environment,
        handler: cb.handler
      });
    } else if (cb.order === "post") {
      postGroup.push({
        environment,
        handler: cb.handler
      });
    } else {
      defaultGroup.push({
        environment,
        handler: cb.handler
      });
    }
  };
  const callInEnvironment = async ({
    environment,
    args: params
  }) => {
    const callbacks = [...preGroup, ...defaultGroup, ...postGroup];
    for (const callback of callbacks) {
      if (callback.environment && environment && !isPluginMatchEnvironment(callback.environment, environment)) {
        continue;
      }
      const result = await callback.handler(...params);
      if (result !== void 0) {
        params[0] = result;
      }
    }
    return params;
  };
  return {
    tapEnvironment,
    tap: (handler) => tapEnvironment({ handler }),
    callInEnvironment
  };
}
function createAsyncHook() {
  const preGroup = [];
  const postGroup = [];
  const defaultGroup = [];
  const tap = (cb) => {
    if (isFunction(cb)) {
      defaultGroup.push(cb);
    } else if (cb.order === "pre") {
      preGroup.push(cb.handler);
    } else if (cb.order === "post") {
      postGroup.push(cb.handler);
    } else {
      defaultGroup.push(cb.handler);
    }
  };
  const call = async (...params) => {
    const callbacks = [...preGroup, ...defaultGroup, ...postGroup];
    for (const callback of callbacks) {
      const result = await callback(...params);
      if (result !== void 0) {
        params[0] = result;
      }
    }
    return params;
  };
  return {
    tap,
    call
  };
}
function initHooks() {
  return {
    onExit: createAsyncHook(),
    onAfterBuild: createAsyncHook(),
    onBeforeBuild: createAsyncHook(),
    onDevCompileDone: createAsyncHook(),
    onCloseDevServer: createAsyncHook(),
    onAfterStartDevServer: createAsyncHook(),
    onBeforeStartDevServer: createAsyncHook(),
    onAfterStartProdServer: createAsyncHook(),
    onBeforeStartProdServer: createAsyncHook(),
    onAfterCreateCompiler: createAsyncHook(),
    onBeforeCreateCompiler: createAsyncHook(),
    modifyHTMLTags: createEnvironmentAsyncHook(),
    modifyRspackConfig: createEnvironmentAsyncHook(),
    modifyBundlerChain: createEnvironmentAsyncHook(),
    modifyWebpackChain: createEnvironmentAsyncHook(),
    modifyWebpackConfig: createEnvironmentAsyncHook(),
    modifyRsbuildConfig: createAsyncHook(),
    modifyEnvironmentConfig: createEnvironmentAsyncHook(),
    onBeforeEnvironmentCompile: createEnvironmentAsyncHook(),
    onAfterEnvironmentCompile: createEnvironmentAsyncHook()
  };
}
var onBeforeCompile, onCompileDone, registerBuildHook, registerDevHook;
var init_hooks = __esm({
  "src/hooks.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_pluginManager();
    onBeforeCompile = ({
      compiler,
      beforeCompile,
      beforeEnvironmentCompiler,
      isWatch
    }) => {
      const name = "rsbuild:beforeCompile";
      if (isMultiCompiler(compiler)) {
        const { compilers } = compiler;
        let doneCompilers = 0;
        let waitBeforeCompileDone;
        for (let index = 0; index < compilers.length; index++) {
          const compiler2 = compilers[index];
          let compilerDone = false;
          (isWatch ? compiler2.hooks.watchRun : compiler2.hooks.run).tapPromise(
            name,
            async () => {
              if (!compilerDone) {
                compilerDone = true;
                doneCompilers++;
              }
              if (!waitBeforeCompileDone) {
                waitBeforeCompileDone = beforeCompile?.();
              }
              await waitBeforeCompileDone;
              await beforeEnvironmentCompiler(index);
            }
          );
          compiler2.hooks.invalid.tap(name, () => {
            if (compilerDone) {
              compilerDone = false;
              doneCompilers--;
            }
            if (doneCompilers <= 0) {
              waitBeforeCompileDone = void 0;
            }
          });
        }
      } else {
        (isWatch ? compiler.hooks.watchRun : compiler.hooks.run).tapPromise(
          name,
          async () => {
            await beforeCompile?.();
            await beforeEnvironmentCompiler(0);
          }
        );
      }
    };
    onCompileDone = ({
      compiler,
      onDone,
      onEnvironmentDone,
      MultiStatsCtor
    }) => {
      if (isMultiCompiler(compiler)) {
        const { compilers } = compiler;
        const compilerStats = [];
        let doneCompilers = 0;
        for (let index = 0; index < compilers.length; index++) {
          const compiler2 = compilers[index];
          const compilerIndex = index;
          let compilerDone = false;
          compiler2.hooks.done.tapPromise("rsbuild:done", async (stats) => {
            if (!compilerDone) {
              compilerDone = true;
              doneCompilers++;
            }
            compilerStats[compilerIndex] = stats;
            const lastCompilerDone = doneCompilers === compilers.length;
            await onEnvironmentDone(index, stats);
            if (lastCompilerDone) {
              await onDone(new MultiStatsCtor(compilerStats));
            }
          });
          compiler2.hooks.invalid.tap("rsbuild:done", () => {
            if (compilerDone) {
              compilerDone = false;
              doneCompilers--;
            }
          });
        }
      } else {
        compiler.hooks.done.tapPromise("rsbuild:done", async (stats) => {
          await onEnvironmentDone(0, stats);
          await onDone(stats);
        });
      }
    };
    registerBuildHook = ({
      context,
      isWatch,
      compiler,
      bundlerConfigs,
      MultiStatsCtor
    }) => {
      let isFirstCompile = true;
      const environmentList = Object.values(context.environments).reduce((prev, curr) => {
        prev[curr.index] = curr;
        return prev;
      }, []);
      const beforeCompile = async () => await context.hooks.onBeforeBuild.call({
        bundlerConfigs,
        environments: context.environments,
        isWatch,
        isFirstCompile
      });
      const beforeEnvironmentCompiler = async (buildIndex) => await context.hooks.onBeforeEnvironmentCompile.callInEnvironment({
        environment: environmentList[buildIndex].name,
        args: [
          {
            bundlerConfig: bundlerConfigs?.[buildIndex],
            environment: environmentList[buildIndex],
            isWatch,
            isFirstCompile
          }
        ]
      });
      const onDone = async (stats) => {
        const p = context.hooks.onAfterBuild.call({
          isFirstCompile,
          stats,
          environments: context.environments,
          isWatch
        });
        isFirstCompile = false;
        await p;
      };
      const onEnvironmentDone = async (buildIndex, stats) => {
        await context.hooks.onAfterEnvironmentCompile.callInEnvironment({
          environment: environmentList[buildIndex].name,
          args: [
            {
              isFirstCompile,
              stats,
              environment: environmentList[buildIndex],
              isWatch
            }
          ]
        });
      };
      onBeforeCompile({
        compiler,
        beforeCompile,
        beforeEnvironmentCompiler,
        isWatch
      });
      onCompileDone({
        compiler,
        onDone,
        onEnvironmentDone,
        MultiStatsCtor
      });
    };
    registerDevHook = ({
      context,
      compiler,
      bundlerConfigs,
      MultiStatsCtor
    }) => {
      let isFirstCompile = true;
      const environmentList = Object.values(context.environments).reduce((prev, curr) => {
        prev[curr.index] = curr;
        return prev;
      }, []);
      const beforeEnvironmentCompiler = async (buildIndex) => await context.hooks.onBeforeEnvironmentCompile.callInEnvironment({
        environment: environmentList[buildIndex].name,
        args: [
          {
            bundlerConfig: bundlerConfigs?.[buildIndex],
            environment: environmentList[buildIndex],
            isWatch: true,
            isFirstCompile
          }
        ]
      });
      const onDone = async (stats) => {
        const p = context.hooks.onDevCompileDone.call({
          isFirstCompile,
          stats,
          environments: context.environments
        });
        isFirstCompile = false;
        await p;
      };
      const onEnvironmentDone = async (buildIndex, stats) => {
        await context.hooks.onAfterEnvironmentCompile.callInEnvironment({
          environment: environmentList[buildIndex].name,
          args: [
            {
              isFirstCompile,
              stats,
              environment: environmentList[buildIndex],
              isWatch: true
            }
          ]
        });
      };
      onBeforeCompile({
        compiler,
        beforeEnvironmentCompiler,
        isWatch: true
      });
      onCompileDone({
        compiler,
        onDone,
        onEnvironmentDone,
        MultiStatsCtor
      });
    };
  }
});

// src/initPlugins.ts
import { join as join5, posix as posix2 } from "path";
function getHTMLPathByEntry(entryName, config) {
  let filename;
  if (config.output.filename.html) {
    filename = config.output.filename.html.replace("[name]", entryName);
  } else if (config.html.outputStructure === "flat") {
    filename = `${entryName}.html`;
  } else {
    filename = `${entryName}/index.html`;
  }
  const prefix = config.output.distPath.html;
  if (prefix.startsWith("/")) {
    logger.warn(
      `Absolute path is not recommended at \`output.distPath.html\`: "${prefix}", please use relative path instead.`
    );
  }
  return removeLeadingSlash(posix2.join(prefix, filename));
}
function initPluginAPI({
  context,
  pluginManager
}) {
  const { hooks } = context;
  const publicContext = createPublicContext(context);
  function getNormalizedConfig(options) {
    if (context.normalizedConfig) {
      if (options?.environment) {
        const config = context.normalizedConfig.environments[options.environment];
        if (!config) {
          throw new Error(
            `Cannot find normalized config by environment: ${options.environment}.`
          );
        }
        return config;
      }
      return context.normalizedConfig;
    }
    throw new Error(
      "Cannot access normalized config until modifyRsbuildConfig is called."
    );
  }
  const getRsbuildConfig = (type = "current") => {
    switch (type) {
      case "original":
        return context.originalConfig;
      case "current":
        return context.config;
      case "normalized":
        return getNormalizedConfig();
    }
    throw new Error("`getRsbuildConfig` get an invalid type param.");
  };
  const exposed = [];
  const expose = (id, api) => {
    exposed.push({ id, api });
  };
  const useExposed = (id) => {
    const matched = exposed.find((item) => item.id === id);
    if (matched) {
      return matched.api;
    }
  };
  let transformId = 0;
  const transformer = {};
  const processAssetsFns = [];
  hooks.modifyBundlerChain.tap((chain, { target, environment }) => {
    const pluginName = "RsbuildCorePlugin";
    class RsbuildCorePlugin {
      apply(compiler) {
        compiler.__rsbuildTransformer = transformer;
        compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
          compilation.hooks.childCompiler.tap(pluginName, (childCompiler) => {
            childCompiler.__rsbuildTransformer = transformer;
          });
          const { sources } = compiler.webpack;
          for (const {
            descriptor,
            handler,
            environment: pluginEnvironment
          } of processAssetsFns) {
            if (descriptor.targets && !descriptor.targets.includes(target)) {
              return;
            }
            if (descriptor.environments && !descriptor.environments.includes(environment.name) || // the plugin is registered in a specific environment config
            pluginEnvironment && !isPluginMatchEnvironment(pluginEnvironment, environment.name)) {
              return;
            }
            compilation.hooks.processAssets.tapPromise(
              {
                name: pluginName,
                stage: mapProcessAssetsStage(compiler, descriptor.stage)
              },
              async (assets) => handler({
                assets,
                compiler,
                compilation,
                environment,
                sources
              })
            );
          }
        });
      }
    }
    chain.plugin(pluginName).use(RsbuildCorePlugin);
  });
  const getTransformFn = (environment) => (descriptor, handler) => {
    const id = `rsbuild-transform-${transformId++}`;
    transformer[id] = handler;
    hooks.modifyBundlerChain.tapEnvironment({
      environment,
      handler: (chain, { target, environment: environment2 }) => {
        if (descriptor.targets && !descriptor.targets.includes(target)) {
          return;
        }
        if (descriptor.environments && !descriptor.environments.includes(environment2.name)) {
          return;
        }
        const rule = chain.module.rule(id);
        if (descriptor.test) {
          rule.test(descriptor.test);
        }
        if (descriptor.resourceQuery) {
          rule.resourceQuery(descriptor.resourceQuery);
        }
        const loaderName = descriptor.raw ? "transformRawLoader.cjs" : "transformLoader.cjs";
        const loaderPath = join5(LOADER_PATH, loaderName);
        rule.use(id).loader(loaderPath).options({
          id,
          getEnvironment: () => environment2
        });
      }
    });
  };
  const setProcessAssets = (environment) => (descriptor, handler) => {
    processAssetsFns.push({ environment, descriptor, handler });
  };
  let onExitListened = false;
  const onExit = (cb) => {
    if (!onExitListened) {
      process.on("exit", () => {
        hooks.onExit.call();
      });
      onExitListened = true;
    }
    hooks.onExit.tap(cb);
  };
  return (environment) => ({
    context: publicContext,
    expose,
    transform: getTransformFn(environment),
    useExposed,
    processAssets: setProcessAssets(environment),
    getRsbuildConfig,
    getNormalizedConfig,
    isPluginExists: pluginManager.isPluginExists,
    // Hooks
    onExit,
    onAfterBuild: hooks.onAfterBuild.tap,
    onBeforeBuild: hooks.onBeforeBuild.tap,
    onCloseDevServer: hooks.onCloseDevServer.tap,
    onDevCompileDone: hooks.onDevCompileDone.tap,
    onAfterCreateCompiler: hooks.onAfterCreateCompiler.tap,
    onAfterStartDevServer: hooks.onAfterStartDevServer.tap,
    onBeforeCreateCompiler: hooks.onBeforeCreateCompiler.tap,
    onBeforeStartDevServer: hooks.onBeforeStartDevServer.tap,
    onAfterStartProdServer: hooks.onAfterStartProdServer.tap,
    onBeforeStartProdServer: hooks.onBeforeStartProdServer.tap,
    modifyRsbuildConfig: hooks.modifyRsbuildConfig.tap,
    modifyHTMLTags: (handler) => hooks.modifyHTMLTags.tapEnvironment({
      environment,
      handler
    }),
    modifyBundlerChain: (handler) => hooks.modifyBundlerChain.tapEnvironment({
      environment,
      handler
    }),
    modifyRspackConfig: (handler) => hooks.modifyRspackConfig.tapEnvironment({
      environment,
      handler
    }),
    modifyWebpackChain: (handler) => hooks.modifyWebpackChain.tapEnvironment({
      environment,
      handler
    }),
    modifyWebpackConfig: (handler) => hooks.modifyWebpackConfig.tapEnvironment({
      environment,
      handler
    }),
    modifyEnvironmentConfig: (handler) => hooks.modifyEnvironmentConfig.tapEnvironment({
      environment,
      handler
    }),
    onAfterEnvironmentCompile: (handler) => hooks.onAfterEnvironmentCompile.tapEnvironment({
      environment,
      handler
    }),
    onBeforeEnvironmentCompile: (handler) => hooks.onBeforeEnvironmentCompile.tapEnvironment({
      environment,
      handler
    })
  });
}
var mapProcessAssetsStage;
var init_initPlugins = __esm({
  "src/initPlugins.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_createContext();
    init_helpers();
    init_logger();
    init_pluginManager();
    mapProcessAssetsStage = (compiler, stage) => {
      const { Compilation } = compiler.webpack;
      switch (stage) {
        case "additional":
          return Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL;
        case "pre-process":
          return Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS;
        case "derived":
          return Compilation.PROCESS_ASSETS_STAGE_DERIVED;
        case "additions":
          return Compilation.PROCESS_ASSETS_STAGE_ADDITIONS;
        case "none":
          return Compilation.PROCESS_ASSETS_STAGE_NONE;
        case "optimize":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE;
        case "optimize-count":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT;
        case "optimize-compatibility":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY;
        case "optimize-size":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE;
        case "dev-tooling":
          return Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING;
        case "optimize-inline":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE;
        case "summarize":
          return Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE;
        case "optimize-hash":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH;
        case "optimize-transfer":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER;
        case "analyse":
          return Compilation.PROCESS_ASSETS_STAGE_ANALYSE;
        case "report":
          return Compilation.PROCESS_ASSETS_STAGE_REPORT;
        default:
          throw new Error(`Invalid process assets stage: ${stage}`);
      }
    };
  }
});

// src/createContext.ts
import { join as join6 } from "path";
function getAbsoluteDistPath(cwd, config) {
  const dirRoot = config.output?.distPath?.root ?? ROOT_DIST_DIR;
  return getAbsolutePath(cwd, dirRoot);
}
async function getBrowserslist(path22) {
  const env = process.env.NODE_ENV;
  const cacheKey = path22 + env;
  if (browsersListCache.has(cacheKey)) {
    return browsersListCache.get(cacheKey);
  }
  const result = loadConfig2({ path: path22, env });
  if (result) {
    browsersListCache.set(cacheKey, result);
    return result;
  }
  return null;
}
async function getBrowserslistByEnvironment(path22, config) {
  const { target, overrideBrowserslist } = config.output;
  if (Array.isArray(overrideBrowserslist)) {
    return overrideBrowserslist;
  }
  if (target === "web" || target === "web-worker") {
    const browserslistrc = await getBrowserslist(path22);
    if (browserslistrc) {
      return browserslistrc;
    }
  }
  return DEFAULT_BROWSERSLIST[target];
}
async function updateEnvironmentContext(context, configs) {
  context.environments ||= {};
  for (const [index, [name, config]] of Object.entries(configs).entries()) {
    const tsconfigPath = config.source.tsconfigPath ? getAbsolutePath(context.rootPath, config.source.tsconfigPath) : void 0;
    const browserslist = await getBrowserslistByEnvironment(
      context.rootPath,
      config
    );
    const entry = config.source.entry ?? {};
    const htmlPaths = getEnvironmentHTMLPaths(entry, config);
    const environmentContext = {
      index,
      name,
      distPath: getAbsoluteDistPath(context.rootPath, config),
      entry,
      browserslist,
      htmlPaths,
      tsconfigPath,
      config
    };
    context.environments[name] = new Proxy(environmentContext, {
      get(target, prop) {
        return target[prop];
      },
      set(_, prop) {
        logger.error(
          `EnvironmentContext is readonly, you can not assign to the "environment.${prop}" prop.`
        );
        return true;
      }
    });
  }
}
function updateContextByNormalizedConfig(context) {
  const distPaths = Object.values(context.environments).map(
    (item) => item.distPath
  );
  context.distPath = getCommonParentPath(distPaths);
}
function createPublicContext(context) {
  const exposedKeys = [
    "version",
    "rootPath",
    "distPath",
    "devServer",
    "cachePath",
    "bundlerType"
  ];
  return new Proxy(context, {
    get(target, prop) {
      if (exposedKeys.includes(prop)) {
        return target[prop];
      }
      return void 0;
    },
    set(_, prop) {
      logger.error(
        `Context is readonly, you can not assign to the "context.${prop}" prop.`
      );
      return true;
    }
  });
}
async function createContext(options, userConfig, bundlerType) {
  const { cwd } = options;
  const rootPath = userConfig.root ? getAbsolutePath(cwd, userConfig.root) : cwd;
  const rsbuildConfig = await withDefaultConfig(rootPath, userConfig);
  const cachePath = join6(rootPath, "node_modules", ".cache");
  return {
    version: "1.0.13",
    rootPath,
    distPath: "",
    cachePath,
    bundlerType,
    environments: {},
    hooks: initHooks(),
    config: { ...rsbuildConfig },
    originalConfig: userConfig,
    specifiedEnvironments: options.environment
  };
}
var browsersListCache, getEnvironmentHTMLPaths;
var init_createContext = __esm({
  "src/createContext.ts"() {
    "use strict";
    init_esm();
    init_dist();
    init_config();
    init_constants();
    init_path();
    init_hooks();
    init_initPlugins();
    init_logger();
    browsersListCache = /* @__PURE__ */ new Map();
    getEnvironmentHTMLPaths = (entry, config) => {
      if (config.output.target !== "web" || config.tools.htmlPlugin === false) {
        return {};
      }
      return Object.keys(entry).reduce((prev, key) => {
        const entryValue = entry[key];
        if (typeof entryValue === "string" || Array.isArray(entryValue) || entryValue.html !== false) {
          prev[key] = getHTMLPathByEntry(key, config);
        }
        return prev;
      }, {});
    };
  }
});

// src/pluginHelper.ts
import rspack from "@rspack/core";
var htmlPlugin, setHTMLPlugin, getHTMLPlugin, cssExtractPlugin, setCssExtractPlugin, getCssExtractPlugin;
var init_pluginHelper = __esm({
  "src/pluginHelper.ts"() {
    "use strict";
    init_esm();
    setHTMLPlugin = (plugin) => {
      if (plugin) {
        htmlPlugin = plugin;
      }
    };
    getHTMLPlugin = () => {
      if (!htmlPlugin) {
        htmlPlugin = __require("../compiled/html-rspack-plugin/index.js");
      }
      return htmlPlugin;
    };
    setCssExtractPlugin = (plugin) => {
      cssExtractPlugin = plugin;
    };
    getCssExtractPlugin = () => {
      if (cssExtractPlugin) {
        return cssExtractPlugin;
      }
      return rspack.CssExtractRspackPlugin;
    };
  }
});

// src/provider/inspectConfig.ts
var inspectConfig_exports = {};
__export(inspectConfig_exports, {
  inspectConfig: () => inspectConfig
});
import { isAbsolute as isAbsolute3, join as join7 } from "path";
async function inspectConfig({
  context,
  pluginManager,
  rsbuildOptions,
  bundlerConfigs,
  inspectOptions = {}
}) {
  if (inspectOptions.mode) {
    setNodeEnv(inspectOptions.mode);
  } else if (!getNodeEnv()) {
    setNodeEnv("development");
  }
  const rspackConfigs = bundlerConfigs || (await initConfigs({
    context,
    pluginManager,
    rsbuildOptions
  })).rspackConfigs;
  const rawBundlerConfigs = rspackConfigs.map((config, index) => ({
    name: config.name || String(index),
    content: stringifyConfig(config, inspectOptions.verbose)
  }));
  const {
    rsbuildConfig,
    rawRsbuildConfig,
    environmentConfigs,
    rawEnvironmentConfigs
  } = getRsbuildInspectConfig({
    normalizedConfig: context.normalizedConfig,
    inspectOptions,
    pluginManager
  });
  const outputPath = getInspectOutputPath(context, inspectOptions);
  if (inspectOptions.writeToDisk) {
    await outputInspectConfigFiles({
      rawBundlerConfigs,
      rawEnvironmentConfigs,
      inspectOptions: {
        ...inspectOptions,
        outputPath
      },
      configType: "rspack"
    });
  }
  return {
    rsbuildConfig: rawRsbuildConfig,
    environmentConfigs: rawEnvironmentConfigs.map((r) => r.content),
    bundlerConfigs: rawBundlerConfigs.map((r) => r.content),
    origin: {
      rsbuildConfig,
      environmentConfigs,
      bundlerConfigs: rspackConfigs
    }
  };
}
var getInspectOutputPath;
var init_inspectConfig = __esm({
  "src/provider/inspectConfig.ts"() {
    "use strict";
    init_esm();
    init_config();
    init_constants();
    init_helpers();
    init_initConfigs();
    getInspectOutputPath = (context, inspectOptions) => {
      if (inspectOptions.outputPath) {
        if (isAbsolute3(inspectOptions.outputPath)) {
          return inspectOptions.outputPath;
        }
        return join7(context.distPath, inspectOptions.outputPath);
      }
      return join7(context.distPath, RSBUILD_OUTPUTS_PATH);
    };
  }
});

// ../../node_modules/.pnpm/reduce-configs@1.0.0/node_modules/reduce-configs/dist/index.js
function reduceConfigs({
  initial,
  config,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return config(initial) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigs({ initial: initial2, config: config2, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
async function reduceConfigsAsyncWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return await config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsMergeContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return config({ value: initial, ...ctx }) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsMergeContext({
        initial: initial2,
        config: config2,
        ctx,
        mergeFn
      }),
      initial
    );
  }
  return config ?? initial;
}
var isNil, isFunction2, isObject2, isPlainObject2;
var init_dist2 = __esm({
  "../../node_modules/.pnpm/reduce-configs@1.0.0/node_modules/reduce-configs/dist/index.js"() {
    "use strict";
    init_esm();
    isNil = (o) => o === void 0 || o === null;
    isFunction2 = (func) => typeof func === "function";
    isObject2 = (obj) => obj !== null && typeof obj === "object";
    isPlainObject2 = (obj) => isObject2(obj) && Object.prototype.toString.call(obj) === "[object Object]";
  }
});

// src/configChain.ts
import RspackChain2 from "../compiled/rspack-chain/index.js";
function getBundlerChain() {
  const bundlerChain = new RspackChain2();
  return bundlerChain;
}
async function modifyBundlerChain(context, utils) {
  logger.debug("modify bundler chain");
  const bundlerChain = getBundlerChain();
  const [modifiedBundlerChain] = await context.hooks.modifyBundlerChain.callInEnvironment({
    environment: utils.environment.name,
    args: [bundlerChain, utils]
  });
  if (utils.environment.config.tools?.bundlerChain) {
    for (const item of castArray(utils.environment.config.tools.bundlerChain)) {
      await item(modifiedBundlerChain, utils);
    }
  }
  logger.debug("modify bundler chain done");
  return modifiedBundlerChain;
}
function chainToConfig(chain) {
  const config = chain.toConfig();
  const { entry } = config;
  if (!isPlainObject(entry)) {
    return config;
  }
  const formattedEntry = {};
  for (const [entryName, entryValue] of Object.entries(entry)) {
    const entryImport = [];
    let entryDescription = null;
    for (const item of castArray(entryValue)) {
      if (typeof item === "string") {
        entryImport.push(item);
        continue;
      }
      if (item.import) {
        entryImport.push(...castArray(item.import));
      }
      if (entryDescription) {
        Object.assign(entryDescription, item);
      } else {
        entryDescription = item;
      }
    }
    formattedEntry[entryName] = entryDescription ? {
      ...entryDescription,
      import: entryImport
    } : entryImport;
  }
  config.entry = formattedEntry;
  return config;
}
var CHAIN_ID;
var init_configChain = __esm({
  "src/configChain.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_logger();
    CHAIN_ID = {
      /** Predefined rules */
      RULE: {
        /** Rule for .mjs */
        MJS: "mjs",
        /** Rule for fonts */
        FONT: "font",
        /** Rule for images */
        IMAGE: "image",
        /** Rule for media */
        MEDIA: "media",
        /** Rule for js */
        JS: "js",
        /** Rule for data uri encoded javascript */
        JS_DATA_URI: "js-data-uri",
        /** Rule for ts */
        TS: "ts",
        /** Rule for css */
        CSS: "css",
        /** Rule for less */
        LESS: "less",
        /** Rule for sass */
        SASS: "sass",
        /** Rule for stylus */
        STYLUS: "stylus",
        /** Rule for svg */
        SVG: "svg",
        /** Rule for pug */
        PUG: "pug",
        /** Rule for Vue */
        VUE: "vue",
        /** Rule for wasm */
        WASM: "wasm",
        /** Rule for svelte */
        SVELTE: "svelte"
      },
      /** Predefined rule groups */
      ONE_OF: {
        SVG: "svg",
        SVG_URL: "svg-asset-url",
        SVG_ASSET: "svg-asset",
        SVG_REACT: "svg-react",
        SVG_INLINE: "svg-asset-inline"
      },
      /** Predefined loaders */
      USE: {
        /** ts-loader */
        TS: "ts",
        /** css-loader */
        CSS: "css",
        /** sass-loader */
        SASS: "sass",
        /** less-loader */
        LESS: "less",
        /** stylus-loader */
        STYLUS: "stylus",
        /** url-loader */
        URL: "url",
        /** pug-loader */
        PUG: "pug",
        /** vue-loader */
        VUE: "vue",
        /** swc-loader */
        SWC: "swc",
        /** svgr */
        SVGR: "svgr",
        /** babel-loader */
        BABEL: "babel",
        /** style-loader */
        STYLE: "style-loader",
        /** svelte-loader */
        SVELTE: "svelte",
        /** postcss-loader */
        POSTCSS: "postcss",
        /** lightningcss-loader */
        LIGHTNINGCSS: "lightningcss",
        /** ignore-css-loader */
        IGNORE_CSS: "ignore-css",
        /** css-modules-typescript-loader */
        CSS_MODULES_TS: "css-modules-typescript",
        /** CssExtractRspackPlugin.loader */
        MINI_CSS_EXTRACT: "mini-css-extract",
        /** resolve-url-loader */
        RESOLVE_URL: "resolve-url-loader"
      },
      /** Predefined plugins */
      PLUGIN: {
        /** HotModuleReplacementPlugin */
        HMR: "hmr",
        /** CopyRspackPlugin */
        COPY: "copy",
        /** HtmlRspackPlugin */
        HTML: "html",
        /** DefinePlugin */
        DEFINE: "define",
        /** ProgressPlugin */
        PROGRESS: "progress",
        /** WebpackManifestPlugin */
        MANIFEST: "webpack-manifest",
        /** ForkTsCheckerWebpackPlugin */
        TS_CHECKER: "ts-checker",
        /** WebpackBundleAnalyzer */
        BUNDLE_ANALYZER: "bundle-analyze",
        /** ModuleFederationPlugin */
        MODULE_FEDERATION: "module-federation",
        /** htmlPrefetchPlugin */
        HTML_PREFETCH: "html-prefetch-plugin",
        /** htmlPreloadPlugin */
        HTML_PRELOAD: "html-preload-plugin",
        /** CssExtractRspackPlugin */
        MINI_CSS_EXTRACT: "mini-css-extract",
        /** VueLoaderPlugin */
        VUE_LOADER_PLUGIN: "vue-loader-plugin",
        /** ReactFastRefreshPlugin */
        REACT_FAST_REFRESH: "react-fast-refresh",
        /** WebpackSRIPlugin */
        SUBRESOURCE_INTEGRITY: "subresource-integrity",
        /** AutoSetRootFontSizePlugin */
        AUTO_SET_ROOT_SIZE: "auto-set-root-size"
      },
      /** Predefined minimizers */
      MINIMIZER: {
        /** SwcJsMinimizerRspackPlugin */
        JS: "js",
        /** LightningCssMinimizerRspackPlugin */
        CSS: "css"
      },
      /** Predefined resolve plugins */
      RESOLVE_PLUGIN: {
        /** TsConfigPathsPlugin */
        TS_CONFIG_PATHS: "ts-config-paths"
      }
    };
  }
});

// src/provider/rspackConfig.ts
import { rspack as rspack2 } from "@rspack/core";
import color7 from "../compiled/picocolors/index.js";
async function modifyRspackConfig(context, rspackConfig, utils) {
  logger.debug("modify Rspack config");
  let [modifiedConfig] = await context.hooks.modifyRspackConfig.callInEnvironment({
    environment: utils.environment.name,
    args: [rspackConfig, utils]
  });
  if (utils.environment.config.tools?.rspack) {
    modifiedConfig = await reduceConfigsAsyncWithContext({
      initial: modifiedConfig,
      config: utils.environment.config.tools.rspack,
      ctx: utils,
      mergeFn: utils.mergeConfig
    });
  }
  logger.debug("modify Rspack config done");
  return modifiedConfig;
}
async function getConfigUtils(config, chainUtils) {
  const { merge: merge2 } = await import("../compiled/webpack-merge/index.js");
  return {
    ...chainUtils,
    rspack: rspack2,
    mergeConfig: merge2,
    addRules(rules) {
      const ruleArr = castArray(rules);
      if (!config.module) {
        config.module = {};
      }
      if (!config.module.rules) {
        config.module.rules = [];
      }
      config.module.rules.unshift(...ruleArr);
    },
    prependPlugins(plugins) {
      const pluginArr = castArray(plugins);
      if (!config.plugins) {
        config.plugins = [];
      }
      config.plugins.unshift(...pluginArr);
    },
    appendPlugins(plugins) {
      const pluginArr = castArray(plugins);
      if (!config.plugins) {
        config.plugins = [];
      }
      config.plugins.push(...pluginArr);
    },
    removePlugin(pluginName) {
      if (!config.plugins) {
        return;
      }
      config.plugins = config.plugins.filter((plugin) => {
        if (!plugin) {
          return true;
        }
        const name = plugin.name || plugin.constructor.name;
        return name !== pluginName;
      });
    }
  };
}
function getChainUtils(target, environment) {
  const nodeEnv = getNodeEnv();
  return {
    environment,
    env: nodeEnv,
    target,
    isDev: environment.config.mode === "development",
    isProd: environment.config.mode === "production",
    isServer: target === "node",
    isWebWorker: target === "web-worker",
    CHAIN_ID,
    HtmlPlugin: getHTMLPlugin()
  };
}
async function generateRspackConfig({
  target,
  context,
  environment
}) {
  const chainUtils = getChainUtils(target, context.environments[environment]);
  const {
    BannerPlugin,
    DefinePlugin,
    IgnorePlugin,
    ProvidePlugin,
    HotModuleReplacementPlugin
  } = rspack2;
  const chain = await modifyBundlerChain(context, {
    ...chainUtils,
    bundler: {
      BannerPlugin,
      DefinePlugin,
      IgnorePlugin,
      ProvidePlugin,
      HotModuleReplacementPlugin
    }
  });
  let rspackConfig = chainToConfig(chain);
  rspackConfig = await modifyRspackConfig(
    context,
    rspackConfig,
    await getConfigUtils(rspackConfig, chainUtils)
  );
  if (rspackConfig.plugins) {
    for (const plugin of rspackConfig.plugins) {
      if (plugin && plugin.apply === void 0 && "name" in plugin && "setup" in plugin) {
        const name = color7.bold(color7.yellow(plugin.name));
        throw new Error(
          `${name} appears to be an Rsbuild plugin. It cannot be used as an Rspack plugin.`
        );
      }
    }
  }
  return rspackConfig;
}
var init_rspackConfig = __esm({
  "src/provider/rspackConfig.ts"() {
    "use strict";
    init_esm();
    init_dist2();
    init_configChain();
    init_helpers();
    init_logger();
    init_pluginHelper();
  }
});

// src/provider/initConfigs.ts
import color8 from "../compiled/picocolors/index.js";
async function modifyRsbuildConfig(context) {
  logger.debug("modify Rsbuild config");
  const [modified] = await context.hooks.modifyRsbuildConfig.call(
    context.config,
    { mergeRsbuildConfig }
  );
  context.config = modified;
  logger.debug("modify Rsbuild config done");
}
async function modifyEnvironmentConfig(context, config, name) {
  logger.debug(`modify Rsbuild environment(${name}) config`);
  const [modified] = await context.hooks.modifyEnvironmentConfig.callInEnvironment({
    environment: name,
    args: [
      config,
      {
        name,
        mergeEnvironmentConfig: mergeRsbuildConfig
      }
    ]
  });
  logger.debug(`modify Rsbuild environment(${name}) config done`);
  return modified;
}
async function initRsbuildConfig({
  context,
  pluginManager
}) {
  if (context.normalizedConfig) {
    return context.normalizedConfig;
  }
  await initPlugins({
    getPluginAPI: context.getPluginAPI,
    pluginManager
  });
  await modifyRsbuildConfig(context);
  const normalizeBaseConfig = normalizeConfig(context.config);
  const environments = {};
  const mergedEnvironments = initEnvironmentConfigs(
    normalizeBaseConfig,
    context.rootPath,
    context.specifiedEnvironments
  );
  const {
    dev: {
      hmr,
      assetPrefix,
      progressBar,
      lazyCompilation,
      ...rsbuildSharedDev
    },
    server
  } = normalizeBaseConfig;
  for (const [name, config] of Object.entries(mergedEnvironments)) {
    const environmentConfig = await modifyEnvironmentConfig(
      context,
      config,
      name
    );
    environments[name] = {
      ...environmentConfig,
      dev: {
        ...environmentConfig.dev,
        ...rsbuildSharedDev
      },
      server
    };
  }
  context.normalizedConfig = {
    ...normalizeBaseConfig,
    environments
  };
  await updateEnvironmentContext(context, environments);
  updateContextByNormalizedConfig(context);
  return context.normalizedConfig;
}
async function initConfigs({
  context,
  pluginManager,
  rsbuildOptions
}) {
  const normalizedConfig = await initRsbuildConfig({ context, pluginManager });
  const rspackConfigs = await Promise.all(
    Object.entries(normalizedConfig.environments).map(
      ([environment, config]) => generateRspackConfig({
        target: config.output.target,
        context,
        environment
      })
    )
  );
  if (isDebug()) {
    const inspect = () => {
      const inspectOptions = {
        verbose: true,
        writeToDisk: true
      };
      inspectConfig({
        context,
        pluginManager,
        inspectOptions,
        rsbuildOptions,
        bundlerConfigs: rspackConfigs
      });
    };
    context.hooks.onBeforeBuild.tap(({ isFirstCompile }) => {
      if (isFirstCompile) {
        inspect();
      }
    });
    context.hooks.onAfterStartDevServer.tap(inspect);
  }
  return {
    rspackConfigs
  };
}
var initEnvironmentConfigs;
var init_initConfigs = __esm({
  "src/provider/initConfigs.ts"() {
    "use strict";
    init_esm();
    init_config();
    init_constants();
    init_createContext();
    init_helpers();
    init_logger();
    init_mergeConfig();
    init_pluginManager();
    init_inspectConfig();
    init_rspackConfig();
    initEnvironmentConfigs = (normalizedConfig, rootPath, specifiedEnvironments) => {
      let defaultEntry;
      const getDefaultEntryWithMemo = () => {
        if (!defaultEntry) {
          defaultEntry = getDefaultEntry(rootPath);
        }
        return defaultEntry;
      };
      const { environments, dev, server, provider, ...rsbuildSharedConfig } = normalizedConfig;
      const isEnvironmentEnabled = (name) => !specifiedEnvironments || specifiedEnvironments.includes(name);
      const applyEnvironmentDefaultConfig = (config) => {
        if (!config.source.entry || Object.keys(config.source.entry).length === 0) {
          config.source.entry = getDefaultEntryWithMemo();
        }
        const isServer = config.output.target === "node";
        if (config.output.distPath.js === void 0) {
          config.output.distPath.js = isServer ? "" : JS_DIST_DIR;
        }
        return config;
      };
      if (environments && Object.keys(environments).length) {
        const resolvedEnvironments = Object.fromEntries(
          Object.entries(environments).filter(([name]) => isEnvironmentEnabled(name)).map(([name, config]) => {
            const environmentConfig = {
              ...mergeRsbuildConfig(
                {
                  ...rsbuildSharedConfig,
                  dev: pick(dev, [
                    "hmr",
                    "assetPrefix",
                    "progressBar",
                    "lazyCompilation"
                  ])
                },
                config
              )
            };
            return [name, applyEnvironmentDefaultConfig(environmentConfig)];
          })
        );
        if (!Object.keys(resolvedEnvironments).length) {
          throw new Error(
            `The current build is specified to run only in the ${color8.yellow(specifiedEnvironments?.join(","))} environment, but the configuration of the specified environment was not found.`
          );
        }
        return resolvedEnvironments;
      }
      const defaultEnvironmentName = camelCase(rsbuildSharedConfig.output.target);
      if (!isEnvironmentEnabled(defaultEnvironmentName)) {
        throw new Error(
          `The current build is specified to run only in the ${color8.yellow(specifiedEnvironments?.join(","))} environment, but the configuration of the specified environment was not found.`
        );
      }
      return {
        [defaultEnvironmentName]: applyEnvironmentDefaultConfig({
          ...rsbuildSharedConfig,
          dev: pick(dev, ["hmr", "assetPrefix", "progressBar", "lazyCompilation"])
        })
      };
    };
  }
});

// src/provider/createCompiler.ts
var createCompiler_exports = {};
__export(createCompiler_exports, {
  createCompiler: () => createCompiler
});
import { rspack as rspack3 } from "@rspack/core";
import color9 from "../compiled/picocolors/index.js";
async function createCompiler(options) {
  logger.debug("create compiler");
  const { context } = options;
  const { rspackConfigs } = await initConfigs(options);
  await context.hooks.onBeforeCreateCompiler.call({
    bundlerConfigs: rspackConfigs,
    environments: context.environments
  });
  if (!await isSatisfyRspackVersion(rspack3.rspackVersion)) {
    throw new Error(
      `The current Rspack version does not meet the requirements, the minimum supported version of Rspack is ${color9.green(
        rspackMinVersion
      )}`
    );
  }
  const compiler = rspackConfigs.length === 1 ? rspack3(rspackConfigs[0]) : rspack3(rspackConfigs);
  let isVersionLogged = false;
  let isCompiling = false;
  const logRspackVersion = () => {
    if (!isVersionLogged) {
      logger.debug(`Use Rspack v${rspack3.rspackVersion}`);
      isVersionLogged = true;
    }
  };
  compiler.hooks.watchRun.tap("rsbuild:compiling", () => {
    logRspackVersion();
    if (!isCompiling) {
      logger.start("Building...");
    }
    isCompiling = true;
  });
  if (context.normalizedConfig?.mode === "production") {
    compiler.hooks.run.tap("rsbuild:run", logRspackVersion);
  }
  const done = (stats) => {
    const statsOptions = getStatsOptions(compiler);
    const statsJson = stats.toJson({
      children: true,
      // get the compilation time
      timings: true,
      ...typeof statsOptions === "string" ? { preset: statsOptions } : { preset: "errors-warnings" },
      ...typeof statsOptions === "object" ? statsOptions : {}
    });
    const printTime = (c, index) => {
      if (c.time) {
        const time = prettyTime(c.time / 1e3);
        const { name } = rspackConfigs[index];
        const suffix = name ? color9.gray(` (${name})`) : "";
        logger.ready(`Built in ${time}${suffix}`);
      }
    };
    const hasErrors = stats.hasErrors();
    if (!hasErrors) {
      if (rspackConfigs.length > 1 && statsJson.children?.length) {
        statsJson.children.forEach((c, index) => {
          printTime(c, index);
        });
      } else {
        printTime(statsJson, 0);
      }
    }
    const { message, level } = formatStats(statsJson, hasErrors);
    if (level === "error") {
      logger.error(message);
    }
    if (level === "warning") {
      logger.warn(message);
    }
    isCompiling = false;
  };
  compiler.hooks.done.tap(
    "rsbuild:done",
    (stats) => {
      done(stats);
    }
  );
  if (context.normalizedConfig?.mode === "development") {
    registerDevHook({
      context,
      compiler,
      bundlerConfigs: rspackConfigs,
      MultiStatsCtor: rspack3.MultiStats
    });
  }
  await context.hooks.onAfterCreateCompiler.call({
    compiler,
    environments: context.environments
  });
  logger.debug("create compiler done");
  return {
    compiler,
    rspackConfigs
  };
}
var init_createCompiler = __esm({
  "src/provider/createCompiler.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_hooks();
    init_logger();
    init_initConfigs();
  }
});

// src/server/cliShortcuts.ts
import readline from "readline";
import color10 from "../compiled/picocolors/index.js";
function setupCliShortcuts({
  openPage,
  closeServer,
  printUrls,
  restartServer,
  customShortcuts
}) {
  let shortcuts = [
    {
      key: "c",
      description: `${color10.bold("c + enter")}  ${color10.dim("clear console")}`,
      action: () => {
        console.clear();
      }
    },
    {
      key: "o",
      description: `${color10.bold("o + enter")}  ${color10.dim("open in browser")}`,
      action: openPage
    },
    {
      key: "q",
      description: `${color10.bold("q + enter")}  ${color10.dim("quit process")}`,
      action: async () => {
        try {
          await closeServer();
        } finally {
          process.exit(0);
        }
      }
    },
    restartServer ? {
      key: "r",
      description: `${color10.bold("r + enter")}  ${color10.dim("restart server")}`,
      action: restartServer
    } : null,
    {
      key: "u",
      description: `${color10.bold("u + enter")}  ${color10.dim("show urls")}`,
      action: printUrls
    }
  ].filter(Boolean);
  if (customShortcuts) {
    shortcuts = customShortcuts(shortcuts);
    if (!Array.isArray(shortcuts)) {
      throw new Error("`dev.cliShortcuts` must return an array of shortcuts.");
    }
  }
  logger.log(
    `  ➜ ${color10.dim("press")} ${color10.bold("h + enter")} ${color10.dim("to show shortcuts")}
`
  );
  const rl = readline.createInterface({
    input: process.stdin
  });
  rl.on("line", (input) => {
    if (input === "h") {
      let message = `
  ${color10.bold(color10.blue("Shortcuts:"))}
`;
      for (const shortcut of shortcuts) {
        message += `  ${shortcut.description}
`;
      }
      logger.log(message);
    }
    for (const shortcut of shortcuts) {
      if (input === shortcut.key) {
        shortcut.action();
        return;
      }
    }
  });
  onBeforeRestartServer(() => {
    rl.close();
  });
}
var isCliShortcutsEnabled;
var init_cliShortcuts = __esm({
  "src/server/cliShortcuts.ts"() {
    "use strict";
    init_esm();
    init_logger();
    init_restart();
    isCliShortcutsEnabled = (devConfig) => devConfig.cliShortcuts && process.stdin.isTTY && !process.env.CI;
  }
});

// src/server/runner/asModule.ts
import vm from "vm";
var SYNTHETIC_MODULES_STORE, asModule;
var init_asModule = __esm({
  "src/server/runner/asModule.ts"() {
    "use strict";
    init_esm();
    SYNTHETIC_MODULES_STORE = "__SYNTHETIC_MODULES_STORE";
    asModule = async (something, context, unlinked) => {
      if (something instanceof vm.Module) {
        return something;
      }
      context[SYNTHETIC_MODULES_STORE] = context[SYNTHETIC_MODULES_STORE] || [];
      const i = context[SYNTHETIC_MODULES_STORE].length;
      context[SYNTHETIC_MODULES_STORE].push(something);
      const code = [.../* @__PURE__ */ new Set(["default", ...Object.keys(something)])].map(
        (name) => `const _${name} = ${SYNTHETIC_MODULES_STORE}[${i}]${name === "default" ? "" : `[${JSON.stringify(name)}]`}; export { _${name} as ${name}};`
      ).join("\n");
      const m = new vm.SourceTextModule(code, {
        context
      });
      if (unlinked)
        return m;
      await m.link(() => {
      });
      if (m.instantiate)
        m.instantiate();
      await m.evaluate();
      return m;
    };
  }
});

// src/server/runner/basic.ts
import path5 from "path";
var isRelativePath, getSubPath, BasicRunner;
var init_basic = __esm({
  "src/server/runner/basic.ts"() {
    "use strict";
    init_esm();
    isRelativePath = (p) => /^\.\.?\//.test(p);
    getSubPath = (p) => {
      const lastSlash = p.lastIndexOf("/");
      let firstSlash = p.indexOf("/");
      if (lastSlash !== -1 && firstSlash !== lastSlash) {
        if (firstSlash !== -1) {
          let next = p.indexOf("/", firstSlash + 1);
          let dir = p.slice(firstSlash + 1, next);
          while (dir === ".") {
            firstSlash = next;
            next = p.indexOf("/", firstSlash + 1);
            dir = p.slice(firstSlash + 1, next);
          }
        }
        return p.slice(firstSlash + 1, lastSlash + 1);
      }
      return "";
    };
    BasicRunner = class {
      constructor(_options) {
        this._options = _options;
        __publicField(this, "globalContext", null);
        __publicField(this, "baseModuleScope", null);
        __publicField(this, "requirers", /* @__PURE__ */ new Map());
      }
      run(file) {
        if (!this.globalContext) {
          this.globalContext = this.createGlobalContext();
        }
        this.baseModuleScope = this.createBaseModuleScope();
        this.createRunner();
        const res = this.getRequire()(
          this._options.dist,
          file.startsWith("./") ? file : `./${file}`
        );
        if (typeof res === "object" && "then" in res) {
          return res;
        }
        return Promise.resolve(res);
      }
      getRequire() {
        const entryRequire = this.requirers.get("entry");
        return (currentDirectory, modulePath, context = {}) => {
          const p = Array.isArray(modulePath) ? modulePath : modulePath.split("?")[0];
          return entryRequire(currentDirectory, p, context);
        };
      }
      getFile(modulePath, currentDirectory) {
        if (Array.isArray(modulePath)) {
          return {
            path: path5.join(currentDirectory, ".array-require.js"),
            content: `module.exports = (${modulePath.map((arg) => {
              return `require(${JSON.stringify(`./${arg}`)})`;
            }).join(", ")});`,
            subPath: ""
          };
        }
        if (isRelativePath(modulePath)) {
          const p = path5.join(currentDirectory, modulePath);
          return {
            path: p,
            content: this._options.readFileSync(p),
            subPath: getSubPath(modulePath)
          };
        }
        return null;
      }
      preExecute(_code, _file) {
      }
      postExecute(_m, _file) {
      }
      createRunner() {
        this.requirers.set(
          "entry",
          (_currentDirectory, _modulePath, _context = {}) => {
            throw new Error("Not implement");
          }
        );
      }
    };
  }
});

// src/server/runner/cjs.ts
import path6 from "path";
import vm2 from "vm";
var define, CommonJsRunner;
var init_cjs = __esm({
  "src/server/runner/cjs.ts"() {
    "use strict";
    init_esm();
    init_basic();
    define = (...args) => {
      const factory = args.pop();
      factory();
    };
    CommonJsRunner = class extends BasicRunner {
      createGlobalContext() {
        return {
          console,
          setTimeout: (cb, ms, ...args) => {
            const timeout = setTimeout(cb, ms, ...args);
            timeout.unref();
            return timeout;
          },
          clearTimeout
        };
      }
      createBaseModuleScope() {
        const baseModuleScope = {
          console: this.globalContext.console,
          setTimeout: this.globalContext.setTimeout,
          clearTimeout: this.globalContext.clearTimeout,
          nsObj: (m) => {
            Object.defineProperty(m, Symbol.toStringTag, {
              value: "Module"
            });
            return m;
          }
        };
        return baseModuleScope;
      }
      createModuleScope(requireFn, m, file) {
        return {
          ...this.baseModuleScope,
          require: requireFn.bind(null, path6.dirname(file.path)),
          module: m,
          exports: m.exports,
          __dirname: path6.dirname(file.path),
          __filename: file.path,
          define
        };
      }
      createRunner() {
        this.requirers.set("miss", this.createMissRequirer());
        this.requirers.set("entry", this.createCjsRequirer());
      }
      createMissRequirer() {
        return (_currentDirectory, modulePath, _context = {}) => {
          const modulePathStr = modulePath;
          return modulePathStr.startsWith("node:") ? __require(modulePathStr.slice(5)) : __require(modulePathStr);
        };
      }
      createCjsRequirer() {
        const requireCache = /* @__PURE__ */ Object.create(null);
        return (currentDirectory, modulePath, context = {}) => {
          const file = context.file || this.getFile(modulePath, currentDirectory);
          if (!file) {
            return this.requirers.get("miss")(currentDirectory, modulePath);
          }
          if (file.path in requireCache) {
            return requireCache[file.path].exports;
          }
          const m = {
            exports: {}
          };
          requireCache[file.path] = m;
          const currentModuleScope = this.createModuleScope(
            this.getRequire(),
            m,
            file
          );
          const args = Object.keys(currentModuleScope);
          const argValues = args.map((arg) => currentModuleScope[arg]);
          const code = `(function(${args.join(", ")}) {
        ${file.content}
      })`;
          this.preExecute(code, file);
          const fn = this._options.runInNewContext ? vm2.runInNewContext(code, this.globalContext, file.path) : vm2.runInThisContext(code, file.path);
          fn.call(m.exports, ...argValues);
          this.postExecute(m, file);
          return m.exports;
        };
      }
    };
  }
});

// src/server/runner/type.ts
var init_type = __esm({
  "src/server/runner/type.ts"() {
    "use strict";
    init_esm();
  }
});

// src/server/runner/esm.ts
import path7 from "path";
import { fileURLToPath as fileURLToPath2, pathToFileURL } from "url";
import vm3 from "vm";
var EsmRunner;
var init_esm3 = __esm({
  "src/server/runner/esm.ts"() {
    "use strict";
    init_esm();
    init_asModule();
    init_cjs();
    init_type();
    EsmRunner = class extends CommonJsRunner {
      createRunner() {
        super.createRunner();
        this.requirers.set("cjs", this.getRequire());
        this.requirers.set("esm", this.createEsmRequirer());
        this.requirers.set("entry", (currentDirectory, modulePath, context) => {
          const file = this.getFile(modulePath, currentDirectory);
          if (!file) {
            return this.requirers.get("miss")(currentDirectory, modulePath);
          }
          if (file.path.endsWith(".mjs") && this._options.compilerOptions.experiments?.outputModule) {
            return this.requirers.get("esm")(currentDirectory, modulePath, {
              ...context,
              file
            });
          }
          return this.requirers.get("cjs")(currentDirectory, modulePath, {
            ...context,
            file
          });
        });
      }
      createEsmRequirer() {
        const esmContext = vm3.createContext(this.baseModuleScope, {
          name: "context for esm"
        });
        const esmCache = /* @__PURE__ */ new Map();
        const esmIdentifier = this._options.name;
        return (currentDirectory, modulePath, context = {}) => {
          if (!vm3.SourceTextModule) {
            throw new Error(
              "Running esm bundle needs add Node.js option '--experimental-vm-modules'."
            );
          }
          const _require = this.getRequire();
          const file = context.file || this.getFile(modulePath, currentDirectory);
          if (!file) {
            return this.requirers.get("miss")(currentDirectory, modulePath);
          }
          let esm = esmCache.get(file.path);
          if (!esm) {
            esm = new vm3.SourceTextModule(file.content, {
              identifier: `${esmIdentifier}-${file.path}`,
              // no attribute
              url: `${pathToFileURL(file.path).href}?${esmIdentifier}`,
              context: esmContext,
              initializeImportMeta: (meta, _) => {
                meta.url = pathToFileURL(file.path).href;
              },
              importModuleDynamically: async (specifier, module) => {
                const result = await _require(path7.dirname(file.path), specifier, {
                  esmMode: 1 /* Evaluated */
                });
                return await asModule(result, module.context);
              }
            });
            esmCache.set(file.path, esm);
          }
          if (context.esmMode === 2 /* Unlinked */)
            return esm;
          return (async () => {
            await esm.link(async (specifier, referencingModule) => {
              return await asModule(
                await _require(
                  path7.dirname(
                    referencingModule.identifier ? referencingModule.identifier.slice(esmIdentifier.length + 1) : fileURLToPath2(referencingModule.url)
                  ),
                  specifier,
                  {
                    esmMode: 2 /* Unlinked */
                  }
                ),
                referencingModule.context,
                true
              );
            });
            if (esm.instantiate)
              esm.instantiate();
            await esm.evaluate();
            if (context.esmMode === 1 /* Evaluated */) {
              return esm;
            }
            const ns = esm.namespace;
            return ns.default && ns.default instanceof Promise ? ns.default : ns;
          })();
        };
      }
    };
  }
});

// src/server/runner/index.ts
var BasicRunnerFactory, run;
var init_runner = __esm({
  "src/server/runner/index.ts"() {
    "use strict";
    init_esm();
    init_esm3();
    BasicRunnerFactory = class {
      constructor(name) {
        this.name = name;
      }
      create(compilerOptions, dist, readFileSync) {
        const runner = this.createRunner(compilerOptions, dist, readFileSync);
        return runner;
      }
      createRunner(compilerOptions, dist, readFileSync) {
        const runnerOptions = {
          name: this.name,
          dist,
          compilerOptions,
          readFileSync
        };
        if (compilerOptions.target === "web" || compilerOptions.target === "webworker") {
          throw new Error(
            `not support run ${compilerOptions.target} resource in rsbuild server`
          );
        }
        return new EsmRunner(runnerOptions);
      }
    };
    run = async (bundlePath, outputPath, compilerOptions, readFileSync) => {
      const runnerFactory = new BasicRunnerFactory(bundlePath);
      const runner = runnerFactory.create(
        compilerOptions,
        outputPath,
        readFileSync
      );
      const mod = runner.run(bundlePath);
      return mod;
    };
  }
});

// src/server/environment.ts
import { join as join8 } from "path";
var loadBundle, getTransformedHtml;
var init_environment = __esm({
  "src/server/environment.ts"() {
    "use strict";
    init_esm();
    init_runner();
    loadBundle = async (stats, entryName, utils) => {
      const { chunks, entrypoints, outputPath } = stats.toJson({
        all: false,
        chunks: true,
        entrypoints: true,
        outputPath: true
      });
      if (!entrypoints?.[entryName]) {
        throw new Error(`can't find entry(${entryName})`);
      }
      const { chunks: entryChunks = [] } = entrypoints[entryName];
      const files = entryChunks.reduce((prev, entryChunkName) => {
        const chunk = chunks?.find(
          (chunk2) => chunk2.entry && chunk2.names?.includes(String(entryChunkName))
        );
        return chunk?.files ? prev.concat(chunk.files.filter((file) => !file.endsWith(".css"))) : prev;
      }, []);
      if (files.length === 0) {
        throw new Error(`can't get bundle by entryName(${entryName})`);
      }
      if (files.length > 1) {
        throw new Error(
          `only support load single entry chunk, but got ${files.length}: ${files.join(",")}`
        );
      }
      const res = await run(
        files[0],
        outputPath,
        stats.compilation.options,
        utils.readFileSync
      );
      return res;
    };
    getTransformedHtml = async (entryName, utils) => {
      const { htmlPaths, distPath } = utils.environment;
      const htmlPath = htmlPaths[entryName];
      if (!htmlPath) {
        throw new Error(`can't get html file by entryName(${entryName})`);
      }
      const fileName = join8(distPath, htmlPath);
      const fileContent = utils.readFileSync(fileName);
      return fileContent;
    };
  }
});

// src/server/helper.ts
import net from "net";
import os from "os";
import { posix as posix3 } from "path";
import color11 from "../compiled/picocolors/index.js";
function getURLMessages(urls, routes) {
  if (routes.length === 1) {
    return urls.map(({ label, url: url2 }) => {
      const pathname = normalizeUrl(`${url2}${routes[0].pathname}`);
      const prefix = `➜ ${color11.dim(label.padEnd(10))}`;
      return `  ${prefix}${color11.cyan(pathname)}
`;
    }).join("");
  }
  let message = "";
  const maxNameLength = Math.max(...routes.map((r) => r.entryName.length));
  urls.forEach(({ label, url: url2 }, index) => {
    if (index > 0) {
      message += "\n";
    }
    message += `  ${`➜ ${label}`}
`;
    for (const r of routes) {
      message += `  ${color11.dim("-")} ${color11.dim(
        r.entryName.padEnd(maxNameLength + 4)
      )}${color11.cyan(normalizeUrl(`${url2}${r.pathname}`))}
`;
    }
  });
  return message;
}
function printServerURLs({
  urls: originalUrls,
  port,
  routes,
  protocol,
  printUrls,
  trailingLineBreak = true
}) {
  if (printUrls === false) {
    return null;
  }
  let urls = originalUrls;
  if (isFunction(printUrls)) {
    const newUrls = printUrls({
      urls: urls.map((item) => item.url),
      port,
      routes,
      protocol
    });
    if (!newUrls) {
      return null;
    }
    if (!Array.isArray(newUrls)) {
      throw new Error(
        `"server.printUrls" must return an array, but got ${typeof newUrls}.`
      );
    }
    urls = newUrls.map((url2) => ({
      url: url2,
      label: getUrlLabel(url2)
    }));
  }
  if (urls.length === 0 || routes.length === 0) {
    return null;
  }
  let message = getURLMessages(urls, routes);
  if (trailingLineBreak === false && message.endsWith("\n")) {
    message = message.slice(0, -1);
  }
  logger.log(message);
  return message;
}
function getServerTerminator(server) {
  let listened = false;
  const pendingSockets = /* @__PURE__ */ new Set();
  const onConnection = (socket) => {
    pendingSockets.add(socket);
    socket.on("close", () => {
      pendingSockets.delete(socket);
    });
  };
  server.on("connection", onConnection);
  server.on("secureConnection", onConnection);
  server.once("listening", () => {
    listened = true;
  });
  return () => new Promise((resolve2, reject) => {
    for (const socket of pendingSockets) {
      socket.destroy();
    }
    if (listened) {
      server.close((err) => err ? reject(err) : resolve2());
    } else {
      resolve2();
    }
  });
}
var normalizeUrl, formatPrefix, joinUrlSegments, stripBase, getRoutes, formatRoutes, getPort, getServerConfig, getIpv4Interfaces, isLoopbackHost, getHostInUrl, concatUrl, LOCAL_LABEL, NETWORK_LABEL, getUrlLabel, getAddressUrls, COMPILATION_ID_REGEX, getCompilationId;
var init_helper = __esm({
  "src/server/helper.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    init_logger();
    normalizeUrl = (url2) => url2.replace(/([^:]\/)\/+/g, "$1");
    formatPrefix = (input) => {
      let prefix = input;
      if (prefix?.startsWith("./")) {
        prefix = prefix.replace("./", "");
      }
      if (!prefix) {
        return "/";
      }
      const hasLeadingSlash = prefix.startsWith("/");
      const hasTailSlash = prefix.endsWith("/");
      return `${hasLeadingSlash ? "" : "/"}${prefix}${hasTailSlash ? "" : "/"}`;
    };
    joinUrlSegments = (s1, s2) => {
      if (!s1 || !s2) {
        return s1 || s2 || "";
      }
      return addTrailingSlash(s1) + removeLeadingSlash(s2);
    };
    stripBase = (path22, base) => {
      if (path22 === base) {
        return "/";
      }
      const trailingSlashBase = addTrailingSlash(base);
      return path22.startsWith(trailingSlashBase) ? path22.slice(trailingSlashBase.length - 1) : path22;
    };
    getRoutes = (context) => {
      return Object.values(context.environments).reduce(
        (prev, environmentContext) => {
          const { distPath, config } = environmentContext;
          const distPrefix = posix3.relative(context.distPath, distPath);
          const routes = formatRoutes(
            environmentContext.htmlPaths,
            context.normalizedConfig.server.base,
            posix3.join(distPrefix, config.output.distPath.html),
            config.html.outputStructure
          );
          return prev.concat(...routes);
        },
        []
      );
    };
    formatRoutes = (entry, base, distPathPrefix, outputStructure) => {
      const prefix = joinUrlSegments(base, formatPrefix(distPathPrefix));
      return Object.keys(entry).map((entryName) => {
        const isIndex = entryName === "index" && outputStructure !== "nested";
        const displayName = isIndex ? "" : entryName;
        return {
          entryName,
          pathname: prefix + displayName
        };
      }).sort((a) => a.entryName === "index" ? -1 : 1);
    };
    getPort = async ({
      host,
      port,
      strictPort,
      tryLimits = 20
    }) => {
      if (typeof port === "string") {
        port = Number.parseInt(port, 10);
      }
      if (strictPort) {
        tryLimits = 1;
      }
      const original = port;
      let found = false;
      let attempts = 0;
      while (!found && attempts <= tryLimits) {
        try {
          await new Promise((resolve2, reject) => {
            const server = net.createServer();
            server.unref();
            server.on("error", reject);
            server.listen({ port, host }, () => {
              found = true;
              server.close(resolve2);
            });
          });
        } catch (e) {
          if (e.code !== "EADDRINUSE") {
            throw e;
          }
          port++;
          attempts++;
        }
      }
      if (port !== original) {
        if (strictPort) {
          throw new Error(
            `Port "${original}" is occupied, please choose another one.`
          );
        }
      }
      return port;
    };
    getServerConfig = async ({
      config
    }) => {
      const host = config.server.host || DEFAULT_DEV_HOST;
      const originalPort = config.server.port || DEFAULT_PORT;
      const port = await getPort({
        host,
        port: originalPort,
        strictPort: config.server.strictPort || false
      });
      const https = Boolean(config.server.https) || false;
      const portTip = port !== originalPort ? `Port ${originalPort} is in use, ${color11.yellow(`using port ${port}.`)}` : void 0;
      return {
        port,
        host,
        https,
        portTip
      };
    };
    getIpv4Interfaces = () => {
      const interfaces = os.networkInterfaces();
      const ipv4Interfaces = /* @__PURE__ */ new Map();
      for (const key of Object.keys(interfaces)) {
        for (const detail of interfaces[key]) {
          const familyV4Value = typeof detail.family === "string" ? "IPv4" : 4;
          if (detail.family === familyV4Value && !ipv4Interfaces.has(detail.address)) {
            ipv4Interfaces.set(detail.address, detail);
          }
        }
      }
      return Array.from(ipv4Interfaces.values());
    };
    isLoopbackHost = (host) => {
      const loopbackHosts = [
        "localhost",
        "127.0.0.1",
        "::1",
        "0000:0000:0000:0000:0000:0000:0000:0001"
      ];
      return loopbackHosts.includes(host);
    };
    getHostInUrl = (host) => {
      if (net.isIPv6(host)) {
        return host === "::" ? "[::1]" : `[${host}]`;
      }
      return host;
    };
    concatUrl = ({
      host,
      port,
      protocol
    }) => `${protocol}://${host}:${port}`;
    LOCAL_LABEL = "Local:  ";
    NETWORK_LABEL = "Network:  ";
    getUrlLabel = (url2) => {
      try {
        const { host } = new URL(url2);
        return isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL;
      } catch (err) {
        return NETWORK_LABEL;
      }
    };
    getAddressUrls = ({
      protocol = "http",
      port,
      host
    }) => {
      if (host && host !== DEFAULT_DEV_HOST) {
        return [
          {
            label: isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL,
            url: concatUrl({
              port,
              host: getHostInUrl(host),
              protocol
            })
          }
        ];
      }
      const ipv4Interfaces = getIpv4Interfaces();
      const addressUrls = [];
      let hasLocalUrl = false;
      for (const detail of ipv4Interfaces) {
        if (isLoopbackHost(detail.address) || detail.internal) {
          if (hasLocalUrl) {
            continue;
          }
          addressUrls.push({
            label: LOCAL_LABEL,
            url: concatUrl({ host: "localhost", port, protocol })
          });
          hasLocalUrl = true;
        } else {
          addressUrls.push({
            label: NETWORK_LABEL,
            url: concatUrl({ host: detail.address, port, protocol })
          });
        }
      }
      return addressUrls;
    };
    COMPILATION_ID_REGEX = /[^a-zA-Z0-9_-]/g;
    getCompilationId = (compiler) => {
      const uniqueName = compiler.options.output.uniqueName ?? "";
      return `${compiler.name ?? ""}_${uniqueName.replace(COMPILATION_ID_REGEX, "_")}`;
    };
  }
});

// src/server/middlewares.ts
import path8 from "path";
import color12 from "../compiled/picocolors/index.js";
var faviconFallbackMiddleware, getStatusCodeColor, getRequestLoggerMiddleware, notFoundMiddleware, isFileExists2, maybeHTMLRequest, postfixRE, getUrlPathname, getHtmlCompletionMiddleware, getBaseMiddleware, getHtmlFallbackMiddleware;
var init_middlewares = __esm({
  "src/server/middlewares.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_logger();
    init_helper();
    faviconFallbackMiddleware = (req, res, next) => {
      if (req.url === "/favicon.ico") {
        res.statusCode = 204;
        res.end();
      } else {
        next();
      }
    };
    getStatusCodeColor = (status) => {
      if (status >= 500) {
        return color12.red;
      }
      if (status >= 400) {
        return color12.yellow;
      }
      if (status >= 300) {
        return color12.cyan;
      }
      if (status >= 200) {
        return color12.green;
      }
      return (res) => res;
    };
    getRequestLoggerMiddleware = async () => {
      const { default: onFinished } = await import("../compiled/on-finished/index.js");
      return (req, res, next) => {
        const _startAt = process.hrtime();
        const logRequest = () => {
          const method = req.method;
          const url2 = req.originalUrl || req.url;
          const status = Number(res.statusCode);
          const statusColor = getStatusCodeColor(status);
          const endAt = process.hrtime();
          const totalTime = (endAt[0] - _startAt[0]) * 1e3 + (endAt[1] - _startAt[1]) * 1e-6;
          logger.debug(
            `${statusColor(status)} ${method} ${color12.gray(url2)} ${color12.gray(
              `${totalTime.toFixed(3)} ms`
            )}`
          );
        };
        onFinished(res, logRequest);
        next();
      };
    };
    notFoundMiddleware = (_req, res, _next) => {
      res.statusCode = 404;
      res.end();
    };
    isFileExists2 = async (filePath, outputFileSystem) => new Promise((resolve2) => {
      outputFileSystem.stat(filePath, (_error, stats) => {
        resolve2(stats?.isFile());
      });
    });
    maybeHTMLRequest = (req) => {
      if (
        // require headers and url
        !req.url || !req.headers || // only accept GET or HEAD
        req.method !== "GET" && req.method !== "HEAD"
      ) {
        return false;
      }
      const { accept } = req.headers;
      return typeof accept === "string" && (accept.includes("text/html") || accept.includes("*/*"));
    };
    postfixRE = /[?#].*$/;
    getUrlPathname = (url2) => {
      return url2.replace(postfixRE, "");
    };
    getHtmlCompletionMiddleware = ({ distPath, callback, outputFileSystem }) => {
      return async (req, res, next) => {
        if (!maybeHTMLRequest(req)) {
          return next();
        }
        const url2 = req.url;
        const pathname = getUrlPathname(url2);
        const rewrite = (newUrl) => {
          req.url = newUrl;
          return callback(req, res, (...args) => {
            next(...args);
          });
        };
        if (pathname.endsWith("/")) {
          const newUrl = `${pathname}index.html`;
          const filePath = path8.join(distPath, newUrl);
          if (await isFileExists2(filePath, outputFileSystem)) {
            return rewrite(newUrl);
          }
        } else if (!path8.extname(pathname)) {
          const newUrl = `${pathname}.html`;
          const filePath = path8.join(distPath, newUrl);
          if (await isFileExists2(filePath, outputFileSystem)) {
            return rewrite(newUrl);
          }
        }
        next();
      };
    };
    getBaseMiddleware = ({
      base
    }) => {
      return async (req, res, next) => {
        const url2 = req.url;
        const pathname = getUrlPathname(url2);
        if (pathname.startsWith(base)) {
          req.url = stripBase(url2, base);
          return next();
        }
        const redirectPath = addTrailingSlash(url2) !== base ? joinUrlSegments(base, url2) : base;
        if (pathname === "/" || pathname === "/index.html") {
          res.writeHead(302, {
            Location: redirectPath
          });
          res.end();
          return;
        }
        if (req.headers.accept?.includes("text/html")) {
          res.writeHead(404, {
            "Content-Type": "text/html"
          });
          res.end(
            `The server is configured with a base URL of ${base} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`
          );
          return;
        }
        res.writeHead(404, {
          "Content-Type": "text/plain"
        });
        res.end(
          `The server is configured with a base URL of ${base} - did you mean to visit ${redirectPath} instead?`
        );
        return;
      };
    };
    getHtmlFallbackMiddleware = ({ htmlFallback, distPath, callback, outputFileSystem }) => {
      return async (req, res, next) => {
        if (!maybeHTMLRequest(req) || "/favicon.ico" === req.url || htmlFallback !== "index") {
          return next();
        }
        const filePath = path8.join(distPath, "index.html");
        if (await isFileExists2(filePath, outputFileSystem)) {
          const newUrl = "/index.html";
          if (logger.level === "verbose") {
            logger.debug(
              `${req.method} ${color12.gray(
                `${req.url} ${color12.yellow("fallback")} to ${newUrl}`
              )}`
            );
          }
          req.url = newUrl;
          return callback(req, res, (...args) => next(...args));
        }
        next();
      };
    };
  }
});

// src/server/gzipMiddleware.ts
var gzipMiddleware_exports = {};
__export(gzipMiddleware_exports, {
  gzipMiddleware: () => gzipMiddleware
});
import zlib from "zlib";
var ENCODING_REGEX, CONTENT_TYPE_REGEX, shouldCompress, gzipMiddleware;
var init_gzipMiddleware = __esm({
  "src/server/gzipMiddleware.ts"() {
    "use strict";
    init_esm();
    ENCODING_REGEX = /\bgzip\b/;
    CONTENT_TYPE_REGEX = /text|javascript|\/json|xml/i;
    shouldCompress = (res) => {
      if (res.getHeader("Content-Encoding")) {
        return false;
      }
      const contentType = String(res.getHeader("Content-Type"));
      if (contentType && !CONTENT_TYPE_REGEX.test(contentType)) {
        return false;
      }
      const size = res.getHeader("Content-Length");
      return size === void 0 || Number(size) > 1024;
    };
    gzipMiddleware = ({
      level = zlib.constants.Z_BEST_SPEED
    } = {}) => (req, res, next) => {
      const accept = req.headers["accept-encoding"];
      const encoding = typeof accept === "string" && ENCODING_REGEX.test(accept);
      if (req.method === "HEAD" || !encoding) {
        next();
        return;
      }
      let gzip2;
      let writeHeadStatus;
      let started = false;
      const { end, write, on, writeHead } = res;
      const listeners = [];
      const start = () => {
        if (started) {
          return;
        }
        started = true;
        if (shouldCompress(res)) {
          res.setHeader("Content-Encoding", "gzip");
          res.removeHeader("Content-Length");
          gzip2 = zlib.createGzip({ level });
          gzip2.on("data", (chunk) => {
            if (write.call(res, chunk) === false) {
              gzip2.pause();
            }
          });
          on.call(res, "drain", () => gzip2.resume());
          gzip2.on("end", () => {
            end.call(res);
          });
          for (const listener of listeners) {
            gzip2.on.apply(gzip2, listener);
          }
        } else {
          for (const listener of listeners) {
            on.apply(res, listener);
          }
        }
        writeHead.call(res, writeHeadStatus ?? res.statusCode);
      };
      res.writeHead = (status, reason, headers) => {
        if (reason) {
          for (const [key, value] of Object.entries(headers || reason)) {
            res.setHeader(key, value);
          }
        }
        writeHeadStatus = status;
        return res;
      };
      res.write = (...args) => {
        start();
        return gzip2 ? gzip2.write(...args) : write.apply(res, args);
      };
      res.end = (...args) => {
        start();
        return gzip2 ? gzip2.end(...args) : end.apply(res, args);
      };
      res.on = (type, listener) => {
        if (started) {
          if (!gzip2 || type !== "drain") {
            on.call(res, type, listener);
          } else {
            gzip2.on(type, listener);
          }
        } else {
          listeners.push([type, listener]);
        }
        return res;
      };
      next();
    };
  }
});

// src/server/proxy.ts
var proxy_exports = {};
__export(proxy_exports, {
  createProxyMiddleware: () => createProxyMiddleware
});
function formatProxyOptions(proxyOptions) {
  const ret = [];
  if (Array.isArray(proxyOptions)) {
    ret.push(...proxyOptions);
  } else if ("target" in proxyOptions) {
    ret.push(proxyOptions);
  } else {
    for (const [context, options] of Object.entries(proxyOptions)) {
      const opts = {
        context,
        changeOrigin: true,
        logLevel: "warn"
      };
      if (typeof options === "string") {
        opts.target = options;
      } else {
        Object.assign(opts, options);
      }
      ret.push(opts);
    }
  }
  const handleError = (err) => logger.error(err);
  for (const opts of ret) {
    opts.onError ??= handleError;
  }
  return ret;
}
var createProxyMiddleware;
var init_proxy = __esm({
  "src/server/proxy.ts"() {
    "use strict";
    init_esm();
    init_logger();
    createProxyMiddleware = async (proxyOptions) => {
      const formattedOptions = formatProxyOptions(proxyOptions);
      const proxyMiddlewares = [];
      const middlewares = [];
      const { createProxyMiddleware: baseMiddleware } = await import("../compiled/http-proxy-middleware/index.js");
      for (const opts of formattedOptions) {
        const proxyMiddleware = baseMiddleware(opts.context, opts);
        const middleware = async (req, res, next) => {
          const bypassUrl = typeof opts.bypass === "function" ? opts.bypass(req, res, opts) : null;
          if (bypassUrl === false) {
            res.statusCode = 404;
            next();
          } else if (typeof bypassUrl === "string") {
            req.url = bypassUrl;
            next();
          } else if (bypassUrl === true) {
            next();
          } else {
            proxyMiddleware(req, res, next);
          }
        };
        middlewares.push(middleware);
        opts.ws && proxyMiddlewares.push(proxyMiddleware);
      }
      const handleUpgrade = (req, socket, head) => {
        for (const middleware of proxyMiddlewares) {
          if (typeof middleware.upgrade === "function") {
            middleware.upgrade(req, socket, head);
          }
        }
      };
      return {
        middlewares,
        upgrade: handleUpgrade
      };
    };
  }
});

// src/server/getDevMiddlewares.ts
import { isAbsolute as isAbsolute4, join as join9 } from "path";
import url from "url";
var applySetupMiddlewares, applyDefaultMiddlewares, getMiddlewares;
var init_getDevMiddlewares = __esm({
  "src/server/getDevMiddlewares.ts"() {
    "use strict";
    init_esm();
    init_config();
    init_logger();
    init_middlewares();
    applySetupMiddlewares = (dev, environments, compileMiddlewareAPI) => {
      const setupMiddlewares = dev.setupMiddlewares || [];
      const serverOptions = {
        sockWrite: (type, data) => compileMiddlewareAPI?.sockWrite(type, data),
        environments
      };
      const before = [];
      const after = [];
      for (const handler of setupMiddlewares) {
        handler(
          {
            unshift: (...handlers) => before.unshift(...handlers),
            push: (...handlers) => after.push(...handlers)
          },
          serverOptions
        );
      }
      return { before, after };
    };
    applyDefaultMiddlewares = async ({
      middlewares,
      server,
      compileMiddlewareAPI,
      output,
      pwd,
      outputFileSystem
    }) => {
      const upgradeEvents = [];
      if (server.compress) {
        const { gzipMiddleware: gzipMiddleware2 } = await Promise.resolve().then(() => (init_gzipMiddleware(), gzipMiddleware_exports));
        middlewares.push(gzipMiddleware2());
      }
      middlewares.push((req, res, next) => {
        res.setHeader("Access-Control-Allow-Origin", "*");
        const path22 = req.url ? url.parse(req.url).pathname : "";
        if (path22?.includes("hot-update")) {
          res.setHeader("Access-Control-Allow-Credentials", "false");
        }
        const confHeaders = server.headers;
        if (confHeaders) {
          for (const [key, value] of Object.entries(confHeaders)) {
            res.setHeader(key, value);
          }
        }
        next();
      });
      if (server.proxy) {
        const { createProxyMiddleware: createProxyMiddleware2 } = await Promise.resolve().then(() => (init_proxy(), proxy_exports));
        const { middlewares: proxyMiddlewares, upgrade } = await createProxyMiddleware2(server.proxy);
        upgradeEvents.push(upgrade);
        for (const middleware of proxyMiddlewares) {
          middlewares.push(middleware);
        }
      }
      if (server.base && server.base !== "/") {
        middlewares.push(getBaseMiddleware({ base: server.base }));
      }
      const { default: launchEditorMiddleware } = await import("../compiled/launch-editor-middleware/index.js");
      middlewares.push(["/__open-in-editor", launchEditorMiddleware()]);
      if (compileMiddlewareAPI) {
        middlewares.push(compileMiddlewareAPI.middleware);
        upgradeEvents.push(
          compileMiddlewareAPI.onUpgrade.bind(compileMiddlewareAPI)
        );
        middlewares.push((req, res, next) => {
          if (req.url?.endsWith(".hot-update.json") && req.method !== "OPTIONS") {
            res.statusCode = 404;
            res.end();
          } else {
            next();
          }
        });
      }
      const distPath = isAbsolute4(output.distPath) ? output.distPath : join9(pwd, output.distPath);
      if (compileMiddlewareAPI) {
        middlewares.push(
          getHtmlCompletionMiddleware({
            distPath,
            callback: compileMiddlewareAPI.middleware,
            outputFileSystem
          })
        );
      }
      const publicDirs = normalizePublicDirs(server?.publicDir);
      for (const publicDir of publicDirs) {
        const { default: sirv } = await import("../compiled/sirv/index.js");
        const { name } = publicDir;
        const normalizedPath = isAbsolute4(name) ? name : join9(pwd, name);
        const assetMiddleware = sirv(normalizedPath, {
          etag: true,
          dev: true
        });
        middlewares.push(assetMiddleware);
      }
      if (compileMiddlewareAPI) {
        middlewares.push(
          getHtmlFallbackMiddleware({
            distPath,
            callback: compileMiddlewareAPI.middleware,
            htmlFallback: server.htmlFallback,
            outputFileSystem
          })
        );
      }
      if (server.historyApiFallback) {
        const { default: connectHistoryApiFallback } = await import("../compiled/connect-history-api-fallback/index.js");
        const historyApiFallbackMiddleware = connectHistoryApiFallback(
          server.historyApiFallback === true ? {} : server.historyApiFallback
        );
        middlewares.push(historyApiFallbackMiddleware);
        compileMiddlewareAPI?.middleware && middlewares.push(compileMiddlewareAPI.middleware);
      }
      middlewares.push(faviconFallbackMiddleware);
      middlewares.push((req, res, next) => {
        if (req.method === "OPTIONS") {
          res.statusCode = 204;
          res.setHeader("Content-Length", "0");
          res.end();
          return;
        }
        next();
      });
      return {
        onUpgrade: (...args) => {
          for (const cb of upgradeEvents) {
            cb(...args);
          }
        }
      };
    };
    getMiddlewares = async (options) => {
      const middlewares = [];
      const { environments, compileMiddlewareAPI } = options;
      if (logger.level === "verbose") {
        middlewares.push(await getRequestLoggerMiddleware());
      }
      const { before, after } = applySetupMiddlewares(
        options.dev,
        environments,
        compileMiddlewareAPI
      );
      middlewares.push(...before);
      const { onUpgrade } = await applyDefaultMiddlewares({
        ...options,
        middlewares
      });
      middlewares.push(...after);
      return {
        close: async () => {
          compileMiddlewareAPI?.close();
        },
        onUpgrade,
        middlewares
      };
    };
  }
});

// src/server/httpServer.ts
var createHttpServer;
var init_httpServer = __esm({
  "src/server/httpServer.ts"() {
    "use strict";
    init_esm();
    createHttpServer = async ({
      serverConfig,
      middlewares
    }) => {
      if (serverConfig.https) {
        if (serverConfig.proxy) {
          const { createServer: createServer2 } = await import("https");
          return createServer2(serverConfig.https, middlewares);
        }
        const { createSecureServer } = await import("http2");
        return createSecureServer(
          {
            allowHTTP1: true,
            // increase the maximum memory (MiB)
            maxSessionMemory: 1024,
            ...serverConfig.https
          },
          // @ts-expect-error req type mismatch
          middlewares
        );
      }
      const { createServer } = await import("http");
      return createServer(middlewares);
    };
  }
});

// src/server/open.ts
import { exec } from "child_process";
import { promisify } from "util";
async function openBrowser(url2) {
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin";
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      const targetBrowser = await getTargetBrowser();
      if (targetBrowser) {
        await execAsync(
          `osascript openChrome.applescript "${encodeURI(
            url2
          )}" "${targetBrowser}"`,
          {
            cwd: STATIC_PATH
          }
        );
        return true;
      }
      logger.debug("Failed to find the target browser.");
    } catch (err) {
      logger.debug("Failed to open start URL with apple script.");
      logger.debug(err);
    }
  }
  try {
    const { default: open2 } = await import("../compiled/open/index.js");
    await open2(url2);
    return true;
  } catch (err) {
    logger.error("Failed to open start URL.");
    logger.error(err);
    return false;
  }
}
function resolveUrl(str, base) {
  if (canParse(str)) {
    return str;
  }
  try {
    const url2 = new URL(str, base);
    return url2.href;
  } catch (e) {
    throw new Error(
      "[rsbuild:open]: Invalid input: not a valid URL or pathname"
    );
  }
}
async function open({
  https,
  port,
  routes,
  config,
  clearCache
}) {
  const { targets, before } = normalizeOpenConfig(config);
  const isCodesandbox = process.env.CSB === "true";
  if (isCodesandbox) {
    return;
  }
  if (clearCache) {
    clearOpenedURLs();
  }
  const urls = [];
  const protocol = https ? "https" : "http";
  const baseUrl = `${protocol}://localhost:${port}`;
  if (!targets.length) {
    if (routes.length) {
      urls.push(`${baseUrl}${routes[0].pathname}`);
    }
  } else {
    urls.push(
      ...targets.map(
        (target) => resolveUrl(replacePortPlaceholder(target, port), baseUrl)
      )
    );
  }
  if (before) {
    await before();
  }
  for (const url2 of urls) {
    if (!openedURLs.includes(url2)) {
      openBrowser(url2);
      openedURLs.push(url2);
    }
  }
}
var execAsync, supportedChromiumBrowsers, getTargetBrowser, openedURLs, clearOpenedURLs, replacePortPlaceholder, normalizeOpenConfig;
var init_open = __esm({
  "src/server/open.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    init_logger();
    execAsync = promisify(exec);
    supportedChromiumBrowsers = [
      "Google Chrome Canary",
      "Google Chrome Dev",
      "Google Chrome Beta",
      "Google Chrome",
      "Microsoft Edge",
      "Brave Browser",
      "Vivaldi",
      "Chromium"
    ];
    getTargetBrowser = async () => {
      let targetBrowser = process.env.BROWSER;
      if (!targetBrowser || !supportedChromiumBrowsers.includes(targetBrowser)) {
        const { stdout: ps } = await execAsync("ps cax");
        targetBrowser = supportedChromiumBrowsers.find((b) => ps.includes(b));
      }
      return targetBrowser;
    };
    openedURLs = [];
    clearOpenedURLs = () => {
      openedURLs = [];
    };
    replacePortPlaceholder = (url2, port) => url2.replace(/<port>/g, String(port));
    normalizeOpenConfig = (config) => {
      const { open: open2 } = config.server;
      if (typeof open2 === "boolean") {
        return { targets: [] };
      }
      if (typeof open2 === "string") {
        return { targets: [open2] };
      }
      if (Array.isArray(open2)) {
        return { targets: open2 };
      }
      return {
        targets: open2.target ? castArray(open2.target) : [],
        before: open2.before
      };
    };
  }
});

// src/server/watchFiles.ts
async function setupWatchFiles(options) {
  const { dev, server, compileMiddlewareAPI } = options;
  const { hmr, liveReload } = dev;
  if (!hmr && !liveReload || !compileMiddlewareAPI) {
    return;
  }
  const closeDevFilesWatcher = await watchDevFiles(dev, compileMiddlewareAPI);
  const serverFilesWatcher = await watchServerFiles(
    server,
    compileMiddlewareAPI
  );
  return {
    async close() {
      await Promise.all([
        closeDevFilesWatcher?.(),
        serverFilesWatcher?.close()
      ]);
    }
  };
}
async function watchDevFiles(devConfig, compileMiddlewareAPI) {
  const { watchFiles } = devConfig;
  if (!watchFiles) {
    return;
  }
  const watchers = [];
  for (const { paths, options, type } of castArray(watchFiles)) {
    const watchOptions = prepareWatchOptions(paths, options, type);
    const watcher = await startWatchFiles(watchOptions, compileMiddlewareAPI);
    if (watcher) {
      watchers.push(watcher);
    }
  }
  return async () => {
    for (const watcher of watchers) {
      await watcher.close();
    }
  };
}
function watchServerFiles(serverConfig, compileMiddlewareAPI) {
  const publicDirs = normalizePublicDirs(serverConfig.publicDir);
  if (!publicDirs.length) {
    return;
  }
  const watchPaths = publicDirs.filter((item) => item.watch).map((item) => item.name);
  if (!watchPaths.length) {
    return;
  }
  const watchOptions = prepareWatchOptions(watchPaths);
  return startWatchFiles(watchOptions, compileMiddlewareAPI);
}
function prepareWatchOptions(paths, options = {}, type) {
  return {
    paths: typeof paths === "string" ? [paths] : paths,
    options,
    type
  };
}
async function startWatchFiles({ paths, options, type }, compileMiddlewareAPI) {
  if (type === "reload-server") {
    return;
  }
  const chokidar = await import("../compiled/chokidar/index.js");
  const watcher = chokidar.watch(paths, options);
  watcher.on("change", () => {
    compileMiddlewareAPI.sockWrite("static-changed");
  });
  return watcher;
}
var init_watchFiles = __esm({
  "src/server/watchFiles.ts"() {
    "use strict";
    init_esm();
    init_config();
    init_helpers();
  }
});

// src/server/devMiddleware.ts
function applyHMREntry({
  compiler,
  clientPaths,
  clientConfig = {},
  liveReload = true
}) {
  if (!isClientCompiler(compiler)) {
    return;
  }
  new compiler.webpack.DefinePlugin({
    RSBUILD_COMPILATION_NAME: JSON.stringify(getCompilationId(compiler)),
    RSBUILD_CLIENT_CONFIG: JSON.stringify(clientConfig),
    RSBUILD_DEV_LIVE_RELOAD: liveReload
  }).apply(compiler);
  for (const clientPath of clientPaths) {
    new compiler.webpack.EntryPlugin(compiler.context, clientPath, {
      name: void 0
    }).apply(compiler);
  }
}
var isClientCompiler, isNodeCompiler, setupServerHooks, getDevMiddleware;
var init_devMiddleware = __esm({
  "src/server/devMiddleware.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_helper();
    isClientCompiler = (compiler) => {
      const { target } = compiler.options;
      if (target) {
        return Array.isArray(target) ? target.includes("web") : target === "web";
      }
      return false;
    };
    isNodeCompiler = (compiler) => {
      const { target } = compiler.options;
      if (target) {
        return Array.isArray(target) ? target.includes("node") : target === "node";
      }
      return false;
    };
    setupServerHooks = (compiler, hookCallbacks) => {
      if (isNodeCompiler(compiler)) {
        return;
      }
      const { compile, invalid, done } = compiler.hooks;
      compile.tap(
        "rsbuild-dev-server",
        () => hookCallbacks.onInvalid(getCompilationId(compiler))
      );
      invalid.tap(
        "rsbuild-dev-server",
        () => hookCallbacks.onInvalid(getCompilationId(compiler))
      );
      done.tap("rsbuild-dev-server", hookCallbacks.onDone);
    };
    getDevMiddleware = async (multiCompiler) => {
      const { default: rsbuildDevMiddleware } = await import("../compiled/rsbuild-dev-middleware/index.js");
      return (options) => {
        const { clientPaths, clientConfig, callbacks, liveReload, ...restOptions } = options;
        const setupCompiler = (compiler) => {
          if (clientPaths) {
            applyHMREntry({
              compiler,
              clientPaths,
              clientConfig,
              liveReload
            });
          }
          setupServerHooks(compiler, callbacks);
        };
        applyToCompiler(multiCompiler, setupCompiler);
        return rsbuildDevMiddleware(multiCompiler, restOptions);
      };
    };
  }
});

// src/server/socketServer.ts
import { parse as parse2 } from "querystring";
function isEqualSet(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const v of a.values()) {
    if (!b.has(v)) {
      return false;
    }
  }
  return true;
}
var SocketServer;
var init_socketServer = __esm({
  "src/server/socketServer.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_logger();
    init_helper();
    SocketServer = class {
      constructor(options) {
        __publicField(this, "wsServer");
        __publicField(this, "sockets", []);
        __publicField(this, "options");
        __publicField(this, "stats");
        __publicField(this, "initialChunks");
        __publicField(this, "timer", null);
        this.options = options;
        this.stats = {};
        this.initialChunks = {};
      }
      upgrade(req, sock, head) {
        if (!this.wsServer.shouldHandle(req)) {
          return;
        }
        this.wsServer.handleUpgrade(req, sock, head, (connection) => {
          this.wsServer.emit("connection", connection, req);
        });
      }
      // create socket, install socket handler, bind socket event
      async prepare() {
        const { default: ws } = await import("../compiled/ws/index.js");
        this.wsServer = new ws.Server({
          noServer: true,
          path: this.options.client?.path
        });
        this.wsServer.on("error", (err) => {
          logger.error(err);
        });
        this.timer = setInterval(() => {
          for (const socket of this.wsServer.clients) {
            const extWs = socket;
            if (!extWs.isAlive) {
              extWs.terminate();
            } else {
              extWs.isAlive = false;
              extWs.ping(() => {
              });
            }
          }
        }, 3e4);
        this.wsServer.on("connection", (socket, req) => {
          const queryStr = req.url ? req.url.split("?")[1] : "";
          this.onConnect(
            socket,
            queryStr ? parse2(queryStr) : {}
          );
        });
      }
      updateStats(stats) {
        const compilationId = getCompilationId(stats.compilation);
        this.stats[compilationId] = stats;
        this.sendStats({
          compilationId
        });
      }
      // write message to each socket
      sockWrite({
        type,
        compilationId,
        data
      }) {
        for (const socket of this.sockets) {
          this.send(socket, JSON.stringify({ type, data, compilationId }));
        }
      }
      singleWrite(socket, {
        type,
        data,
        compilationId
      }) {
        this.send(socket, JSON.stringify({ type, data, compilationId }));
      }
      close() {
        for (const socket of this.sockets) {
          socket.close();
        }
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
      }
      onConnect(socket, params) {
        const connection = socket;
        connection.isAlive = true;
        connection.on("pong", () => {
          connection.isAlive = true;
        });
        if (!connection) {
          return;
        }
        this.sockets.push(connection);
        connection.on("close", () => {
          const idx = this.sockets.indexOf(connection);
          if (idx >= 0) {
            this.sockets.splice(idx, 1);
          }
        });
        if (this.options.hmr || this.options.liveReload) {
          this.singleWrite(connection, {
            type: "hot",
            compilationId: params.compilationId
          });
        }
        if (this.stats) {
          this.sendStats({
            force: true,
            compilationId: params.compilationId
          });
        }
      }
      // get standard stats
      getStats(name) {
        const curStats = this.stats[name];
        if (!curStats) {
          return null;
        }
        const defaultStats = {
          all: false,
          hash: true,
          assets: true,
          warnings: true,
          warningsCount: true,
          errors: true,
          errorsCount: true,
          errorDetails: false,
          entrypoints: true,
          children: true
        };
        return curStats.toJson(defaultStats);
      }
      // determine what message should send by stats
      sendStats({
        force = false,
        compilationId
      }) {
        const stats = this.getStats(compilationId);
        if (!stats) {
          return null;
        }
        const newInitialChunks = /* @__PURE__ */ new Set();
        if (stats.entrypoints) {
          for (const entrypoint of Object.values(stats.entrypoints)) {
            const chunks = entrypoint.chunks;
            if (!Array.isArray(chunks)) {
              continue;
            }
            for (const chunkName of chunks) {
              if (!chunkName) {
                continue;
              }
              newInitialChunks.add(String(chunkName));
            }
          }
        }
        const initialChunks = this.initialChunks[compilationId];
        const shouldReload = Boolean(stats.entrypoints) && Boolean(initialChunks) && !isEqualSet(initialChunks, newInitialChunks);
        this.initialChunks[compilationId] = newInitialChunks;
        if (shouldReload) {
          return this.sockWrite({
            type: "content-changed",
            compilationId
          });
        }
        const shouldEmit = !force && stats && !stats.errorsCount && stats.assets && stats.assets.every((asset) => !asset.emitted);
        if (shouldEmit) {
          return this.sockWrite({
            type: "still-ok",
            compilationId
          });
        }
        this.sockWrite({
          type: "hash",
          compilationId,
          data: stats.hash
        });
        if (stats.errorsCount) {
          return this.sockWrite({
            type: "errors",
            compilationId,
            data: getAllStatsErrors(stats)
          });
        }
        if (stats.warningsCount) {
          return this.sockWrite({
            type: "warnings",
            compilationId,
            data: getAllStatsWarnings(stats)
          });
        }
        return this.sockWrite({
          type: "ok",
          compilationId
        });
      }
      // send message to connecting socket
      send(connection, message) {
        if (connection.readyState !== 1) {
          return;
        }
        connection.send(message);
      }
    };
  }
});

// src/server/compilerDevMiddleware.ts
var compilerDevMiddleware_exports = {};
__export(compilerDevMiddleware_exports, {
  CompilerDevMiddleware: () => CompilerDevMiddleware
});
function getClientPaths(devConfig) {
  const clientPaths = [];
  if (!devConfig.hmr && !devConfig.liveReload) {
    return clientPaths;
  }
  clientPaths.push(__require.resolve("@rsbuild/core/client/hmr"));
  if (devConfig.client?.overlay) {
    clientPaths.push(`${__require.resolve("@rsbuild/core/client/overlay")}`);
  }
  return clientPaths;
}
var noop, CompilerDevMiddleware;
var init_compilerDevMiddleware = __esm({
  "src/server/compilerDevMiddleware.ts"() {
    "use strict";
    init_esm();
    init_path();
    init_devMiddleware();
    init_helper();
    init_socketServer();
    noop = () => {
    };
    CompilerDevMiddleware = class {
      constructor({ dev, server, compiler, publicPaths }) {
        __publicField(this, "middleware");
        __publicField(this, "devConfig");
        __publicField(this, "serverConfig");
        __publicField(this, "compiler");
        __publicField(this, "publicPaths");
        __publicField(this, "socketServer");
        this.devConfig = dev;
        this.serverConfig = server;
        this.compiler = compiler;
        this.publicPaths = publicPaths;
        this.socketServer = new SocketServer(dev);
      }
      async init() {
        const devMiddleware = await getDevMiddleware(this.compiler);
        this.middleware = this.setupDevMiddleware(devMiddleware, this.publicPaths);
        await this.socketServer.prepare();
      }
      upgrade(req, sock, head) {
        this.socketServer.upgrade(req, sock, head);
      }
      close() {
        this.socketServer.close();
        this.middleware?.close(noop);
      }
      sockWrite(type, data) {
        this.socketServer.sockWrite({
          type,
          data
        });
      }
      setupDevMiddleware(devMiddleware, publicPaths) {
        const {
          devConfig,
          serverConfig: { headers, base }
        } = this;
        const callbacks = {
          onInvalid: (compilationId) => {
            this.socketServer.sockWrite({
              type: "invalid",
              compilationId
            });
          },
          onDone: (stats) => {
            this.socketServer.updateStats(stats);
          }
        };
        const clientPaths = getClientPaths(devConfig);
        const middleware = devMiddleware({
          headers,
          publicPath: "/",
          stats: false,
          callbacks,
          clientPaths,
          clientConfig: devConfig.client,
          liveReload: devConfig.liveReload,
          writeToDisk: devConfig.writeToDisk,
          serverSideRender: true,
          // weak is enough in dev
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests#weak_validation
          etag: "weak"
        });
        const assetPrefixes = publicPaths.map(pathnameParse).map(
          (prefix) => base && base !== "/" ? stripBase(prefix, base) : prefix
        );
        const warp = async (req, res, next) => {
          const { url: url2 } = req;
          const assetPrefix = url2 && assetPrefixes.find((prefix) => url2.startsWith(prefix));
          if (assetPrefix && assetPrefix !== "/") {
            req.url = url2.slice(assetPrefix.length - 1);
            middleware(req, res, (...args) => {
              req.url = url2;
              next(...args);
            });
          } else {
            middleware(req, res, next);
          }
        };
        warp.close = middleware.close;
        return warp;
      }
    };
  }
});

// src/server/devServer.ts
var devServer_exports = {};
__export(devServer_exports, {
  createDevServer: () => createDevServer
});
import fs5 from "fs";
async function createDevServer(options, createCompiler2, config, {
  compiler: customCompiler,
  getPortSilently,
  runCompile = true
} = {}) {
  logger.debug("create dev server");
  const { port, host, https, portTip } = await getServerConfig({
    config
  });
  const devConfig = formatDevConfig(config.dev, port);
  const routes = getRoutes(options.context);
  options.context.devServer = {
    hostname: host,
    port,
    https
  };
  let outputFileSystem = fs5;
  let lastStats;
  const waitFirstCompileDone = runCompile ? new Promise((resolve2) => {
    options.context.hooks.onDevCompileDone.tap(
      ({ stats, isFirstCompile }) => {
        lastStats = "stats" in stats ? stats.stats : [stats];
        if (!isFirstCompile) {
          return;
        }
        resolve2();
      }
    );
  }) : Promise.resolve();
  const startCompile = async () => {
    const compiler = customCompiler || await createCompiler2();
    if (!compiler) {
      throw new Error("Failed to get compiler instance.");
    }
    const { CompilerDevMiddleware: CompilerDevMiddleware2 } = await Promise.resolve().then(() => (init_compilerDevMiddleware(), compilerDevMiddleware_exports));
    const publicPaths = isMultiCompiler(compiler) ? compiler.compilers.map(getPublicPathFromCompiler) : [getPublicPathFromCompiler(compiler)];
    const compilerDevMiddleware = new CompilerDevMiddleware2({
      dev: devConfig,
      server: config.server,
      publicPaths,
      compiler
    });
    await compilerDevMiddleware.init();
    outputFileSystem = (isMultiCompiler(compiler) ? compiler.compilers[0].outputFileSystem : compiler.outputFileSystem) || fs5;
    return {
      middleware: compilerDevMiddleware.middleware,
      sockWrite: (...args) => compilerDevMiddleware.sockWrite(...args),
      onUpgrade: (...args) => compilerDevMiddleware.upgrade(...args),
      close: () => compilerDevMiddleware?.close()
    };
  };
  const protocol = https ? "https" : "http";
  const urls = getAddressUrls({ protocol, port, host });
  await options.context.hooks.onBeforeStartDevServer.call({
    environments: options.context.environments
  });
  const cliShortcutsEnabled = isCliShortcutsEnabled(devConfig);
  const printUrls = () => printServerURLs({
    urls,
    port,
    routes,
    protocol,
    printUrls: config.server.printUrls,
    trailingLineBreak: !cliShortcutsEnabled
  });
  const openPage = async () => {
    return open({
      https,
      port,
      routes,
      config,
      clearCache: true
    });
  };
  const closeServer = async () => {
    await options.context.hooks.onCloseDevServer.call();
    await Promise.all([devMiddlewares.close(), fileWatcher?.close()]);
  };
  const beforeCreateCompiler = () => {
    printUrls();
    if (cliShortcutsEnabled) {
      setupCliShortcuts({
        openPage,
        closeServer,
        printUrls,
        restartServer: () => restartDevServer({ clear: false }),
        customShortcuts: typeof devConfig.cliShortcuts === "boolean" ? void 0 : devConfig.cliShortcuts.custom
      });
    }
    if (!getPortSilently && portTip) {
      logger.info(portTip);
    }
  };
  if (runCompile) {
    options.context.hooks.onBeforeCreateCompiler.tap(beforeCreateCompiler);
  } else {
    beforeCreateCompiler();
  }
  const compileMiddlewareAPI = runCompile ? await startCompile() : void 0;
  const fileWatcher = await setupWatchFiles({
    dev: devConfig,
    server: config.server,
    compileMiddlewareAPI
  });
  const pwd = options.context.rootPath;
  const readFileSync = (fileName) => {
    if ("readFileSync" in outputFileSystem) {
      return outputFileSystem.readFileSync(fileName, "utf-8");
    }
    return fs5.readFileSync(fileName, "utf-8");
  };
  const environmentAPI = Object.fromEntries(
    Object.entries(options.context.environments).map(([name, environment]) => {
      return [
        name,
        {
          getStats: async () => {
            if (!runCompile) {
              throw new Error("can't get stats info when runCompile is false");
            }
            await waitFirstCompileDone;
            return lastStats[environment.index];
          },
          loadBundle: async (entryName) => {
            await waitFirstCompileDone;
            return loadBundle(lastStats[environment.index], entryName, {
              readFileSync,
              environment
            });
          },
          getTransformedHtml: async (entryName) => {
            await waitFirstCompileDone;
            return getTransformedHtml(entryName, {
              readFileSync,
              environment
            });
          }
        }
      ];
    })
  );
  const devMiddlewares = await getMiddlewares({
    pwd,
    compileMiddlewareAPI,
    dev: devConfig,
    server: config.server,
    environments: environmentAPI,
    output: {
      distPath: options.context.distPath || ROOT_DIST_DIR
    },
    outputFileSystem
  });
  const { default: connect } = await import("../compiled/connect/index.js");
  const middlewares = connect();
  for (const item of devMiddlewares.middlewares) {
    if (Array.isArray(item)) {
      middlewares.use(...item);
    } else {
      middlewares.use(item);
    }
  }
  const devServerAPI = {
    port,
    middlewares,
    environments: environmentAPI,
    listen: async () => {
      const httpServer = await createHttpServer({
        serverConfig: config.server,
        middlewares
      });
      const serverTerminator = getServerTerminator(httpServer);
      logger.debug("listen dev server");
      options.context.hooks.onCloseDevServer.tap(serverTerminator);
      return new Promise((resolve2) => {
        httpServer.listen(
          {
            host,
            port
          },
          async (err) => {
            if (err) {
              throw err;
            }
            middlewares.use(notFoundMiddleware);
            httpServer.on("upgrade", devMiddlewares.onUpgrade);
            logger.debug("listen dev server done");
            await devServerAPI.afterListen();
            onBeforeRestartServer(devServerAPI.close);
            resolve2({
              port,
              urls: urls.map((item) => item.url),
              server: {
                close: devServerAPI.close
              }
            });
          }
        );
      });
    },
    afterListen: async () => {
      await options.context.hooks.onAfterStartDevServer.call({
        port,
        routes,
        environments: options.context.environments
      });
    },
    connectWebSocket: ({ server }) => {
      server.on("upgrade", devMiddlewares.onUpgrade);
    },
    close: closeServer,
    printUrls,
    open: openPage
  };
  logger.debug("create dev server done");
  return devServerAPI;
}
var formatDevConfig;
var init_devServer = __esm({
  "src/server/devServer.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    init_logger();
    init_cliShortcuts();
    init_environment();
    init_getDevMiddlewares();
    init_helper();
    init_httpServer();
    init_middlewares();
    init_open();
    init_restart();
    init_watchFiles();
    formatDevConfig = (config, port) => {
      if (config.client.port === "<port>") {
        config.client.port = String(port);
      }
      return config;
    };
  }
});

// src/provider/build.ts
var build_exports = {};
__export(build_exports, {
  build: () => build
});
import { rspack as rspack4 } from "@rspack/core";
var build;
var init_build = __esm({
  "src/provider/build.ts"() {
    "use strict";
    init_esm();
    init_hooks();
    init_logger();
    init_createCompiler();
    build = async (initOptions, { watch, compiler: customCompiler } = {}) => {
      const { context } = initOptions;
      let compiler;
      let bundlerConfigs;
      if (customCompiler) {
        compiler = customCompiler;
      } else {
        const result = await createCompiler(initOptions);
        compiler = result.compiler;
        bundlerConfigs = result.rspackConfigs;
      }
      registerBuildHook({
        context,
        bundlerConfigs,
        compiler,
        isWatch: Boolean(watch),
        MultiStatsCtor: rspack4.MultiStats
      });
      if (watch) {
        const watching = compiler.watch({}, (err) => {
          if (err) {
            logger.error(err);
          }
        });
        return {
          close: () => new Promise((resolve2) => {
            watching.close(() => {
              resolve2();
            });
          })
        };
      }
      const { stats } = await new Promise((resolve2, reject) => {
        compiler.run((err, stats2) => {
          if (err) {
            reject(err);
          } else if (stats2?.hasErrors()) {
            reject(new Error("Rspack build failed!"));
          } else {
            compiler.close((closeErr) => {
              if (closeErr) {
                logger.error(closeErr);
              }
              resolve2({ stats: stats2 });
            });
          }
        });
      });
      return {
        stats,
        // This close method is a noop in non-watch mode
        // In watch mode, it's defined above to stop watching
        close: async () => {
        }
      };
    };
  }
});

// src/provider/provider.ts
var provider_exports = {};
__export(provider_exports, {
  rspackProvider: () => rspackProvider
});
var rspackProvider;
var init_provider = __esm({
  "src/provider/provider.ts"() {
    "use strict";
    init_esm();
    init_initConfigs();
    rspackProvider = async ({
      context,
      pluginManager,
      rsbuildOptions
    }) => {
      const createCompiler2 = async () => {
        const { createCompiler: createCompiler3 } = await Promise.resolve().then(() => (init_createCompiler(), createCompiler_exports));
        const result = await createCompiler3({
          context,
          pluginManager,
          rsbuildOptions
        });
        return result.compiler;
      };
      return {
        bundler: "rspack",
        createCompiler: createCompiler2,
        async createDevServer(options) {
          const { createDevServer: createDevServer2 } = await Promise.resolve().then(() => (init_devServer(), devServer_exports));
          const config = await initRsbuildConfig({ context, pluginManager });
          return createDevServer2(
            { context, pluginManager, rsbuildOptions },
            createCompiler2,
            config,
            options
          );
        },
        async startDevServer(options) {
          const { createDevServer: createDevServer2 } = await Promise.resolve().then(() => (init_devServer(), devServer_exports));
          const config = await initRsbuildConfig({ context, pluginManager });
          const server = await createDevServer2(
            { context, pluginManager, rsbuildOptions },
            createCompiler2,
            config,
            options
          );
          return server.listen();
        },
        async build(options) {
          const { build: build2 } = await Promise.resolve().then(() => (init_build(), build_exports));
          return build2({ context, pluginManager, rsbuildOptions }, options);
        },
        async initConfigs() {
          const { rspackConfigs } = await initConfigs({
            context,
            pluginManager,
            rsbuildOptions
          });
          return rspackConfigs;
        },
        async inspectConfig(inspectOptions) {
          const { inspectConfig: inspectConfig2 } = await Promise.resolve().then(() => (init_inspectConfig(), inspectConfig_exports));
          return inspectConfig2({
            context,
            pluginManager,
            rsbuildOptions,
            inspectOptions
          });
        }
      };
    };
  }
});

// src/plugins/basic.ts
var basic_exports = {};
__export(basic_exports, {
  pluginBasic: () => pluginBasic
});
import path9 from "path";
var getJsSourceMap, pluginBasic;
var init_basic2 = __esm({
  "src/plugins/basic.ts"() {
    "use strict";
    init_esm();
    getJsSourceMap = (config) => {
      const { sourceMap } = config.output;
      if (sourceMap.js === void 0) {
        return config.mode === "production" ? false : "cheap-module-source-map";
      }
      return sourceMap.js;
    };
    pluginBasic = () => ({
      name: "rsbuild:basic",
      setup(api) {
        api.modifyBundlerChain(
          (chain, { env, isDev, target, bundler, environment, CHAIN_ID: CHAIN_ID2 }) => {
            const { config } = environment;
            chain.name(environment.name);
            chain.devtool(getJsSourceMap(config));
            chain.context(api.context.rootPath);
            chain.mode(environment.config.mode);
            chain.merge({
              infrastructureLogging: {
                // Using `error` level to avoid `cache.PackFileCacheStrategy` logs
                level: "error"
              }
            });
            chain.performance.hints(false);
            chain.module.parser.merge({
              javascript: {
                exportsPresence: "error"
              }
            });
            const usingHMR = isDev && config.dev.hmr && target === "web";
            if (usingHMR) {
              chain.plugin(CHAIN_ID2.PLUGIN.HMR).use(bundler.HotModuleReplacementPlugin);
            }
            if (env === "development") {
              chain.output.devtoolModuleFilenameTemplate(
                (info) => path9.resolve(info.absoluteResourcePath).replace(/\\/g, "/")
              );
            }
            process.env.RSPACK_CONFIG_VALIDATE ||= "loose-unrecognized-keys";
            process.env.WATCHPACK_WATCHER_LIMIT ||= "20";
          }
        );
      }
    });
  }
});

// src/plugins/entry.ts
var entry_exports = {};
__export(entry_exports, {
  pluginEntry: () => pluginEntry
});
import color13 from "../compiled/picocolors/index.js";
var pluginEntry;
var init_entry = __esm({
  "src/plugins/entry.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    pluginEntry = () => ({
      name: "rsbuild:entry",
      setup(api) {
        api.modifyBundlerChain(async (chain, { environment, isServer }) => {
          const { config, entry } = environment;
          const { preEntry } = config.source;
          const injectCoreJsEntry = config.output.polyfill === "entry" && !isServer;
          for (const entryName of Object.keys(entry)) {
            const entryPoint = chain.entry(entryName);
            const addEntry = (item) => {
              if (typeof item === "object" && "html" in item) {
                const { html, ...rest } = item;
                entryPoint.add(rest);
              } else {
                entryPoint.add(item);
              }
            };
            preEntry.forEach(addEntry);
            if (injectCoreJsEntry) {
              addEntry(createVirtualModule('import "core-js";'));
            }
            castArray(entry[entryName]).forEach(addEntry);
          }
        });
        api.onBeforeCreateCompiler(({ bundlerConfigs }) => {
          if (bundlerConfigs.every((config) => !config.entry)) {
            throw new Error(
              `Could not find any entry module, please make sure that ${color13.cyan(
                "src/index.(ts|js|tsx|jsx|mjs|cjs)"
              )} exists, or customize entry through the ${color13.cyan(
                "source.entry"
              )} configuration.`
            );
          }
        });
      }
    });
  }
});

// src/plugins/cache.ts
var cache_exports = {};
__export(cache_exports, {
  pluginCache: () => pluginCache
});
import crypto from "crypto";
import fs6 from "fs";
import { isAbsolute as isAbsolute5, join as join10 } from "path";
async function validateCache(cacheDirectory, buildDependencies) {
  const configFile = join10(cacheDirectory, "buildDependencies.json");
  if (await isFileExists(configFile)) {
    const rawConfigFile = await fs6.promises.readFile(configFile, "utf-8");
    const prevBuildDependencies = JSON.parse(rawConfigFile);
    if (JSON.stringify(prevBuildDependencies) === JSON.stringify(buildDependencies)) {
      return;
    }
    await fs6.promises.rm(cacheDirectory, { force: true, recursive: true });
  }
  await fs6.promises.mkdir(cacheDirectory, { recursive: true });
  await fs6.promises.writeFile(configFile, JSON.stringify(buildDependencies));
}
function getDigestHash(digest) {
  const fsHash = crypto.createHash("md5");
  const md5 = fsHash.update(JSON.stringify(digest)).digest("hex").slice(0, 8);
  return md5;
}
function getCacheDirectory({ cacheDirectory }, context) {
  if (cacheDirectory) {
    return isAbsolute5(cacheDirectory) ? cacheDirectory : join10(context.rootPath, cacheDirectory);
  }
  return join10(context.cachePath, context.bundlerType);
}
async function getBuildDependencies(context, config, environmentContext) {
  const rootPackageJson = join10(context.rootPath, "package.json");
  const browserslistConfig = join10(context.rootPath, ".browserslistrc");
  const buildDependencies = {};
  if (await isFileExists(rootPackageJson)) {
    buildDependencies.packageJson = [rootPackageJson];
  }
  const { tsconfigPath } = environmentContext;
  if (tsconfigPath) {
    buildDependencies.tsconfig = [tsconfigPath];
  }
  if (config._privateMeta?.configFilePath) {
    buildDependencies.rsbuildConfig = [config._privateMeta.configFilePath];
  }
  if (await isFileExists(browserslistConfig)) {
    buildDependencies.browserslistrc = [browserslistConfig];
  }
  const tailwindExts = ["ts", "js", "cjs", "mjs"];
  const configs = tailwindExts.map(
    (ext) => join10(context.rootPath, `tailwind.config.${ext}`)
  );
  const tailwindConfig = findExists(configs);
  if (tailwindConfig) {
    buildDependencies.tailwindcss = [tailwindConfig];
  }
  return buildDependencies;
}
var pluginCache;
var init_cache = __esm({
  "src/plugins/cache.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    pluginCache = () => ({
      name: "rsbuild:cache",
      setup(api) {
        if (api.context.bundlerType === "rspack") {
          return;
        }
        api.modifyBundlerChain(async (chain, { environment, env }) => {
          const { config } = environment;
          const { buildCache } = config.performance;
          if (buildCache === false) {
            chain.cache(false);
            return;
          }
          const { context } = api;
          const cacheConfig = typeof buildCache === "boolean" ? {} : buildCache;
          const cacheDirectory = getCacheDirectory(cacheConfig, context);
          const buildDependencies = await getBuildDependencies(
            context,
            config,
            environment
          );
          await validateCache(cacheDirectory, buildDependencies);
          const useDigest = Array.isArray(cacheConfig.cacheDigest) && cacheConfig.cacheDigest.length;
          chain.cache({
            // The default cache name of webpack is '${name}-${env}', and the `name` is `default` by default.
            // We set cache name to avoid cache conflicts of different targets.
            name: useDigest ? `${environment.name}-${env}-${getDigestHash(cacheConfig.cacheDigest)}` : `${environment.name}-${env}`,
            type: "filesystem",
            cacheDirectory,
            buildDependencies
          });
        });
      }
    });
  }
});

// src/plugins/target.ts
var target_exports = {};
__export(target_exports, {
  pluginTarget: () => pluginTarget
});
var pluginTarget;
var init_target = __esm({
  "src/plugins/target.ts"() {
    "use strict";
    init_esm();
    init_constants();
    pluginTarget = () => ({
      name: "rsbuild:target",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, { target, environment }) => {
            if (target === "node") {
              chain.target("node");
              return;
            }
            const { browserslist } = environment;
            const isDefaultBrowserslist = browserslist.join(",") === DEFAULT_WEB_BROWSERSLIST.join(",");
            if (target === "web-worker") {
              chain.target(
                isDefaultBrowserslist ? ["webworker", "es2017"] : (
                  // TODO: Rspack should support `browserslist:` for webworker target
                  ["webworker", "es5"]
                )
              );
              return;
            }
            const esQuery = isDefaultBrowserslist ? "es2017" : `browserslist:${browserslist.join(",")}`;
            chain.target(["web", esQuery]);
          }
        });
      }
    });
  }
});

// src/plugins/css.ts
var css_exports = {};
__export(css_exports, {
  isUseCssExtract: () => isUseCssExtract,
  normalizeCssLoaderOptions: () => normalizeCssLoaderOptions,
  pluginCss: () => pluginCss
});
import path10 from "path";
async function loadUserPostcssrc(root) {
  const cached = userPostcssrcCache.get(root);
  if (cached) {
    return clonePostCSSConfig(await cached);
  }
  const { default: postcssrc } = await import("../compiled/postcss-load-config/index.js");
  const promise = postcssrc({}, root).catch((err) => {
    if (err.message?.includes("No PostCSS Config found")) {
      return {};
    }
    throw err;
  });
  userPostcssrcCache.set(root, promise);
  return promise.then((config) => {
    userPostcssrcCache.set(root, config);
    return clonePostCSSConfig(config);
  });
}
async function applyCSSRule({
  rule,
  config,
  context,
  utils: { target, isProd, CHAIN_ID: CHAIN_ID2, environment }
}) {
  const enableExtractCSS = isUseCssExtract(config, target);
  if (target === "web") {
    if (enableExtractCSS) {
      rule.use(CHAIN_ID2.USE.MINI_CSS_EXTRACT).loader(getCssExtractPlugin().loader).options(config.tools.cssExtract.loaderOptions);
    } else {
      const styleLoaderOptions = reduceConfigs({
        initial: {},
        config: config.tools.styleLoader
      });
      rule.use(CHAIN_ID2.USE.STYLE).loader(getCompiledPath("style-loader")).options(styleLoaderOptions);
    }
  } else {
    rule.use(CHAIN_ID2.USE.IGNORE_CSS).loader(path10.join(LOADER_PATH, "ignoreCssLoader.cjs"));
  }
  let importLoaders = 0;
  rule.use(CHAIN_ID2.USE.CSS).loader(getCompiledPath("css-loader"));
  if (target === "web") {
    if (context.bundlerType === "rspack" && config.tools.lightningcssLoader !== false) {
      importLoaders++;
      const userOptions = config.tools.lightningcssLoader === true ? {} : config.tools.lightningcssLoader;
      const initialOptions = {
        targets: environment.browserslist
      };
      if (config.mode === "production" && config.output.injectStyles) {
        initialOptions.minify = true;
      }
      const loaderOptions = reduceConfigs({
        initial: initialOptions,
        config: userOptions
      });
      rule.use(CHAIN_ID2.USE.LIGHTNINGCSS).loader("builtin:lightningcss-loader").options(loaderOptions);
    }
    const postcssLoaderOptions = await getPostcssLoaderOptions({
      config,
      root: context.rootPath
    });
    if (postcssLoaderOptions.postcssOptions?.plugins?.length) {
      importLoaders++;
      rule.use(CHAIN_ID2.USE.POSTCSS).loader(getCompiledPath("postcss-loader")).options(postcssLoaderOptions);
    }
  }
  const localIdentName = getCSSModulesLocalIdentName(config, isProd);
  const cssLoaderOptions = getCSSLoaderOptions({
    config,
    importLoaders,
    target,
    localIdentName
  });
  rule.use(CHAIN_ID2.USE.CSS).options(cssLoaderOptions);
  rule.merge({ sideEffects: true });
  rule.resolve.preferRelative(true);
}
var import_deepmerge2, isUseCssExtract, getCSSModulesLocalIdentName, normalizeCssLoaderOptions, userPostcssrcCache, clonePostCSSConfig, isPostcssPluginCreator, getPostcssLoaderOptions, getCSSLoaderOptions, pluginCss;
var init_css = __esm({
  "src/plugins/css.ts"() {
    "use strict";
    init_esm();
    import_deepmerge2 = __toESM(require_cjs());
    init_dist2();
    init_constants();
    init_path();
    init_pluginHelper();
    isUseCssExtract = (config, target) => !config.output.injectStyles && target !== "node" && target !== "web-worker";
    getCSSModulesLocalIdentName = (config, isProd) => config.output.cssModules.localIdentName || // Using shorter classname in production to reduce bundle size
    (isProd ? "[local]-[hash:base64:6]" : "[path][name]__[local]-[hash:base64:6]");
    normalizeCssLoaderOptions = (options, exportOnlyLocals) => {
      if (options.modules && exportOnlyLocals) {
        let { modules } = options;
        if (modules === true) {
          modules = { exportOnlyLocals: true };
        } else if (typeof modules === "string") {
          modules = {
            mode: modules,
            exportOnlyLocals: true
          };
        } else {
          modules = {
            ...modules,
            exportOnlyLocals: true
          };
        }
        return {
          ...options,
          modules
        };
      }
      return options;
    };
    userPostcssrcCache = /* @__PURE__ */ new Map();
    clonePostCSSConfig = (config) => ({
      ...config,
      plugins: config.plugins ? [...config.plugins] : void 0
    });
    isPostcssPluginCreator = (plugin) => typeof plugin === "function" && plugin.postcss === true;
    getPostcssLoaderOptions = async ({
      config,
      root
    }) => {
      const extraPlugins = [];
      const utils = {
        addPlugins(plugins) {
          if (Array.isArray(plugins)) {
            extraPlugins.push(...plugins);
          } else {
            extraPlugins.push(plugins);
          }
        }
      };
      const userPostcssConfig = await loadUserPostcssrc(root);
      userPostcssConfig.plugins ||= [];
      const defaultPostcssConfig = {
        implementation: getCompiledPath("postcss"),
        postcssOptions: userPostcssConfig,
        sourceMap: config.output.sourceMap.css
      };
      const merged = reduceConfigsWithContext({
        initial: defaultPostcssConfig,
        config: config.tools.postcss,
        ctx: utils
      });
      merged.postcssOptions ||= {};
      merged.postcssOptions.plugins ||= [];
      if (extraPlugins.length) {
        merged.postcssOptions.plugins.push(...extraPlugins);
      }
      merged.postcssOptions.plugins = merged.postcssOptions.plugins.map(
        (plugin) => isPostcssPluginCreator(plugin) ? plugin() : plugin
      );
      merged.postcssOptions.config = false;
      return merged;
    };
    getCSSLoaderOptions = ({
      config,
      importLoaders,
      target,
      localIdentName
    }) => {
      const { cssModules } = config.output;
      const defaultOptions2 = {
        importLoaders,
        modules: {
          ...cssModules,
          localIdentName
        },
        sourceMap: config.output.sourceMap.css
      };
      const mergedCssLoaderOptions = reduceConfigs({
        initial: defaultOptions2,
        config: config.tools.cssLoader,
        mergeFn: import_deepmerge2.default
      });
      const cssLoaderOptions = normalizeCssLoaderOptions(
        mergedCssLoaderOptions,
        target !== "web"
      );
      return cssLoaderOptions;
    };
    pluginCss = () => ({
      name: "rsbuild:css",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, utils) => {
            const rule = chain.module.rule(utils.CHAIN_ID.RULE.CSS);
            const { config } = utils.environment;
            rule.test(CSS_REGEX).type("javascript/auto");
            await applyCSSRule({
              rule,
              utils,
              config,
              context: api.context
            });
          }
        });
      }
    });
  }
});

// src/plugins/output.ts
var output_exports = {};
__export(output_exports, {
  pluginOutput: () => pluginOutput
});
import { posix as posix4 } from "path";
import { rspack as rspack5 } from "@rspack/core";
function getPublicPath({
  isProd,
  config,
  context
}) {
  const { dev, output } = config;
  let publicPath = DEFAULT_ASSET_PREFIX;
  const port = context.devServer?.port || DEFAULT_PORT;
  if (isProd) {
    if (typeof output.assetPrefix === "string") {
      publicPath = output.assetPrefix;
    }
  } else if (typeof dev.assetPrefix === "string") {
    publicPath = dev.assetPrefix;
  } else if (dev.assetPrefix === true) {
    const protocol = context.devServer?.https ? "https" : "http";
    const hostname = context.devServer?.hostname || DEFAULT_DEV_HOST;
    if (hostname === DEFAULT_DEV_HOST) {
      const localHostname = "localhost";
      publicPath = `${protocol}://${localHostname}:<port>/`;
    } else {
      publicPath = `${protocol}://${hostname}:<port>/`;
    }
  }
  return formatPublicPath(replacePortPlaceholder(publicPath, port));
}
var getJsAsyncPath, pluginOutput;
var init_output = __esm({
  "src/plugins/output.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    init_pluginHelper();
    init_open();
    init_css();
    getJsAsyncPath = (jsPath, isServer, jsAsync) => {
      if (jsAsync !== void 0) {
        return jsAsync;
      }
      if (isServer) {
        return jsPath;
      }
      return jsPath ? `${jsPath}/async` : "async";
    };
    pluginOutput = () => ({
      name: "rsbuild:output",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { CHAIN_ID: CHAIN_ID2, target, isProd, isServer, environment }) => {
            const { distPath, config } = environment;
            const publicPath = getPublicPath({
              config,
              isProd,
              context: api.context
            });
            const jsPath = config.output.distPath.js;
            const jsAsyncPath = getJsAsyncPath(
              jsPath,
              isServer,
              config.output.distPath.jsAsync
            );
            const jsFilename = getFilename2(config, "js", isProd, isServer);
            const isJsFilenameFn = typeof jsFilename === "function";
            chain.output.path(distPath).filename(
              isJsFilenameFn ? (...args) => {
                const name = jsFilename(...args);
                return posix4.join(jsPath, name);
              } : posix4.join(jsPath, jsFilename)
            ).chunkFilename(
              isJsFilenameFn ? (...args) => {
                const name = jsFilename(...args);
                return posix4.join(jsAsyncPath, name);
              } : posix4.join(jsAsyncPath, jsFilename)
            ).publicPath(publicPath).pathinfo(false).hashFunction("xxhash64");
            if (isServer) {
              chain.output.library({
                type: "commonjs2",
                ...chain.output.get("library") || {}
              });
            }
            if (config.output.copy && api.context.bundlerType === "rspack") {
              const { copy } = config.output;
              const options = Array.isArray(copy) ? { patterns: copy } : copy;
              chain.plugin(CHAIN_ID2.PLUGIN.COPY).use(rspack5.CopyRspackPlugin, [options]);
            }
            if (isUseCssExtract(config, target)) {
              const extractPluginOptions = config.tools.cssExtract.pluginOptions;
              const cssPath = config.output.distPath.css;
              const cssFilename = getFilename2(config, "css", isProd);
              const cssAsyncPath = config.output.distPath.cssAsync ?? (cssPath ? `${cssPath}/async` : "async");
              chain.plugin(CHAIN_ID2.PLUGIN.MINI_CSS_EXTRACT).use(getCssExtractPlugin(), [
                {
                  filename: posix4.join(cssPath, cssFilename),
                  chunkFilename: posix4.join(cssAsyncPath, cssFilename),
                  ...extractPluginOptions
                }
              ]);
            }
          }
        );
      }
    });
  }
});

// src/plugins/resolve.ts
var resolve_exports = {};
__export(resolve_exports, {
  pluginResolve: () => pluginResolve
});
function applyFullySpecified({
  chain,
  CHAIN_ID: CHAIN_ID2
}) {
  chain.module.rule(CHAIN_ID2.RULE.MJS).test(/\.m?js/).resolve.set("fullySpecified", false);
}
function applyExtensions({ chain }) {
  const extensions = [
    // most projects are using TypeScript, resolve .ts(x) files first to reduce resolve time.
    ".ts",
    ".tsx",
    ".mjs",
    ".js",
    ".jsx",
    ".json"
  ];
  chain.resolve.extensions.merge(extensions);
}
function applyAlias({
  chain,
  config,
  rootPath
}) {
  const { alias } = config.source;
  if (!alias) {
    return;
  }
  const mergedAlias = reduceConfigs({
    initial: {},
    config: alias
  });
  for (const name of Object.keys(mergedAlias)) {
    const values = castArray(mergedAlias[name]);
    const formattedValues = values.map((value) => {
      if (typeof value === "string" && value.startsWith(".")) {
        return ensureAbsolutePath(rootPath, value);
      }
      return value;
    });
    chain.resolve.alias.set(
      name,
      formattedValues.length === 1 ? formattedValues[0] : formattedValues
    );
  }
}
var pluginResolve;
var init_resolve = __esm({
  "src/plugins/resolve.ts"() {
    "use strict";
    init_esm();
    init_dist2();
    init_helpers();
    init_path();
    pluginResolve = () => ({
      name: "rsbuild:resolve",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: (chain, { environment, CHAIN_ID: CHAIN_ID2 }) => {
            const { config, tsconfigPath } = environment;
            applyExtensions({ chain });
            applyAlias({
              chain,
              config,
              rootPath: api.context.rootPath
            });
            applyFullySpecified({ chain, config, CHAIN_ID: CHAIN_ID2 });
            if (tsconfigPath && // Only Rspack has the tsConfig option
            api.context.bundlerType === "rspack" && config.source.aliasStrategy === "prefer-tsconfig") {
              chain.resolve.tsConfig({
                configFile: tsconfigPath
              });
            }
          }
        });
      }
    });
  }
});

// src/plugins/fileSize.ts
var fileSize_exports = {};
__export(fileSize_exports, {
  filterAsset: () => filterAsset,
  pluginFileSize: () => pluginFileSize
});
import fs7 from "fs";
import path11 from "path";
import { promisify as promisify2 } from "util";
import zlib2 from "zlib";
import color14 from "../compiled/picocolors/index.js";
async function gzipSize(input) {
  const data = await gzip(input);
  return data.length;
}
function getHeader(longestFileLength, longestLabelLength, options, environmentName) {
  const longestLengths = [longestFileLength, longestLabelLength];
  const rowTypes = [`File (${environmentName})`, "Size"];
  if (options.compressed) {
    rowTypes.push("Gzip");
  }
  const headerRow = rowTypes.reduce((prev, cur, index) => {
    const length = longestLengths[index];
    let curLabel = cur;
    if (length) {
      curLabel = cur.length < length ? cur + " ".repeat(length - cur.length) : cur;
    }
    return `${prev + curLabel}    `;
  }, "  ");
  return color14.blue(headerRow);
}
async function printFileSizes(options, stats, rootPath, environmentName) {
  const logs = [];
  if (options.detail === false && options.total === false) {
    return logs;
  }
  const formatAsset = async (asset, distPath, distFolder) => {
    const fileName = asset.name.split("?")[0];
    const contents = await fs7.promises.readFile(path11.join(distPath, fileName));
    const size = contents.length;
    const gzippedSize = options.compressed ? await gzipSize(contents) : null;
    const gzipSizeLabel = gzippedSize ? getAssetColor(gzippedSize)(calcFileSize(gzippedSize)) : null;
    return {
      size,
      folder: path11.join(distFolder, path11.dirname(fileName)),
      name: path11.basename(fileName),
      gzippedSize,
      sizeLabel: calcFileSize(size),
      gzipSizeLabel
    };
  };
  const getAssets = async () => {
    const distPath = stats.compilation.outputOptions.path;
    if (!distPath) {
      return [];
    }
    const origin = stats.toJson({
      all: false,
      assets: true,
      cachedAssets: true,
      groupAssetsByInfo: false,
      groupAssetsByPath: false,
      groupAssetsByChunk: false,
      groupAssetsByExtension: false,
      groupAssetsByEmitStatus: false
    });
    const filteredAssets = origin.assets.filter(
      (asset) => filterAsset(asset.name)
    );
    const distFolder = path11.relative(rootPath, distPath);
    return Promise.all(
      filteredAssets.map((asset) => formatAsset(asset, distPath, distFolder))
    );
  };
  const assets = await getAssets();
  if (assets.length === 0) {
    return logs;
  }
  logs.push("");
  assets.sort((a, b) => a.size - b.size);
  const longestLabelLength = Math.max(...assets.map((a) => a.sizeLabel.length));
  const longestFileLength = Math.max(
    ...assets.map((a) => (a.folder + path11.sep + a.name).length)
  );
  if (options.detail !== false) {
    logs.push(
      getHeader(
        longestFileLength,
        longestLabelLength,
        options,
        environmentName
      )
    );
  }
  let totalSize = 0;
  let totalGzipSize = 0;
  for (const asset of assets) {
    let { sizeLabel } = asset;
    const { name, folder, gzipSizeLabel } = asset;
    const fileNameLength = (folder + path11.sep + name).length;
    const sizeLength = sizeLabel.length;
    totalSize += asset.size;
    if (asset.gzippedSize) {
      totalGzipSize += asset.gzippedSize;
    }
    if (options.detail !== false) {
      if (sizeLength < longestLabelLength) {
        const rightPadding = " ".repeat(longestLabelLength - sizeLength);
        sizeLabel += rightPadding;
      }
      let fileNameLabel = color14.dim(asset.folder + path11.sep) + coloringAssetName(asset.name);
      if (fileNameLength < longestFileLength) {
        const rightPadding = " ".repeat(longestFileLength - fileNameLength);
        fileNameLabel += rightPadding;
      }
      let log = `  ${fileNameLabel}    ${sizeLabel}`;
      if (gzipSizeLabel) {
        log += `    ${gzipSizeLabel}`;
      }
      logs.push(log);
    }
  }
  if (options.total !== false) {
    const totalSizeLabel = `${color14.blue("Total:")} ${calcFileSize(totalSize)}`;
    let log = `
  ${totalSizeLabel}`;
    if (options.compressed) {
      log += color14.dim(` (gzip: ${calcFileSize(totalGzipSize)})`);
    }
    log += "\n";
    logs.push(log);
  }
  return logs;
}
var gzip, filterAsset, getAssetColor, calcFileSize, coloringAssetName, pluginFileSize;
var init_fileSize = __esm({
  "src/plugins/fileSize.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_logger();
    gzip = promisify2(zlib2.gzip);
    filterAsset = (asset) => !/\.map$/.test(asset) && !/\.LICENSE\.txt$/.test(asset);
    getAssetColor = (size) => {
      if (size > 300 * 1e3) {
        return color14.red;
      }
      if (size > 100 * 1e3) {
        return color14.yellow;
      }
      return color14.green;
    };
    calcFileSize = (len) => {
      const val = len / 1e3;
      return `${val.toFixed(val < 1 ? 2 : 1)} kB`;
    };
    coloringAssetName = (assetName) => {
      if (JS_REGEX.test(assetName)) {
        return color14.cyan(assetName);
      }
      if (CSS_REGEX.test(assetName)) {
        return color14.yellow(assetName);
      }
      if (HTML_REGEX.test(assetName)) {
        return color14.green(assetName);
      }
      return color14.magenta(assetName);
    };
    pluginFileSize = () => ({
      name: "rsbuild:file-size",
      setup(api) {
        api.onAfterBuild(async ({ stats, environments, isFirstCompile }) => {
          if (!stats || stats.hasErrors() || !isFirstCompile) {
            return;
          }
          const logs = [];
          await Promise.all(
            Object.values(environments).map(async (environment, index) => {
              const { printFileSize } = environment.config.performance;
              if (printFileSize === false) {
                return;
              }
              const multiStats = "stats" in stats ? stats.stats : [stats];
              const defaultConfig = {
                total: true,
                detail: true,
                compressed: true
              };
              const mergedConfig = printFileSize === true ? defaultConfig : {
                ...defaultConfig,
                ...printFileSize
              };
              const statsLogs = await printFileSizes(
                mergedConfig,
                multiStats[index],
                api.context.rootPath,
                environment.name
              );
              if (logs.length) {
                logs.push(color14.dim("  -----"));
              }
              logs.push(...statsLogs);
            })
          ).catch((err) => {
            logger.warn("Failed to print file size.");
            logger.warn(err);
          });
          logger.log(logs.join("\n"));
        });
      }
    });
  }
});

// src/plugins/cleanOutput.ts
var cleanOutput_exports = {};
__export(cleanOutput_exports, {
  dedupeCleanPaths: () => dedupeCleanPaths,
  pluginCleanOutput: () => pluginCleanOutput
});
import { join as join11, sep as sep2 } from "path";
import color15 from "../compiled/picocolors/index.js";
var addTrailingSep, isStrictSubdir, dedupeCleanPaths, pluginCleanOutput;
var init_cleanOutput = __esm({
  "src/plugins/cleanOutput.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    init_logger();
    addTrailingSep = (dir) => dir.endsWith(sep2) ? dir : dir + sep2;
    isStrictSubdir = (parent, child) => {
      const parentDir = addTrailingSep(parent);
      const childDir = addTrailingSep(child);
      return parentDir !== childDir && childDir.startsWith(parentDir);
    };
    dedupeCleanPaths = (paths) => {
      return paths.sort((p1, p2) => p2.length > p1.length ? -1 : 1).reduce((prev, curr) => {
        const isSub = prev.find((p) => curr.startsWith(p) || curr === p);
        if (isSub) {
          return prev;
        }
        return prev.concat(curr);
      }, []);
    };
    pluginCleanOutput = () => ({
      name: "rsbuild:clean-output",
      setup(api) {
        const getRsbuildCleanPath = () => {
          const { rootPath, distPath } = api.context;
          const config = api.getNormalizedConfig();
          const cleanPath = join11(distPath, RSBUILD_OUTPUTS_PATH);
          const { cleanDistPath } = config.output;
          if (cleanDistPath === true || cleanDistPath === "auto" && isStrictSubdir(rootPath, cleanPath)) {
            return cleanPath;
          }
          return void 0;
        };
        const getCleanPath = (environment) => {
          const { rootPath } = api.context;
          const { config, distPath } = environment;
          let { cleanDistPath } = config.output;
          if (cleanDistPath === "auto") {
            cleanDistPath = isStrictSubdir(rootPath, distPath);
            if (!cleanDistPath) {
              logger.warn(
                "The dist path is not a subdir of root path, Rsbuild will not empty it."
              );
              logger.warn(
                `Please set ${color15.yellow("`output.cleanDistPath`")} config manually.`
              );
              logger.warn(`Current root path: ${color15.dim(rootPath)}`);
              logger.warn(`Current dist path: ${color15.dim(distPath)}`);
            }
          }
          if (cleanDistPath) {
            return distPath;
          }
          return void 0;
        };
        const cleanAll = async (params) => {
          const environments = Object.values(params.environments).reduce((total, curr) => {
            if (!total.find((t) => t.distPath === curr.distPath)) {
              total.push(curr);
            }
            return total;
          }, []);
          const cleanPaths = environments.map((e) => getCleanPath(e)).concat(getRsbuildCleanPath()).filter((p) => !!p);
          await Promise.all(dedupeCleanPaths(cleanPaths).map((p) => emptyDir(p)));
        };
        api.onBeforeBuild(async ({ isFirstCompile, environments }) => {
          if (isFirstCompile) {
            await cleanAll({ environments });
          }
        });
        api.onBeforeStartDevServer(cleanAll);
      }
    });
  }
});

// src/plugins/asset.ts
var asset_exports = {};
__export(asset_exports, {
  getRegExpForExts: () => getRegExpForExts,
  pluginAsset: () => pluginAsset
});
import path12 from "path";
function getRegExpForExts(exts) {
  const matcher = exts.map((ext) => ext.trim()).map((ext) => ext.startsWith(".") ? ext.slice(1) : ext).join("|");
  return new RegExp(
    exts.length === 1 ? `\\.${matcher}$` : `\\.(?:${matcher})$`,
    "i"
  );
}
var chainStaticAssetRule, pluginAsset;
var init_asset = __esm({
  "src/plugins/asset.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    chainStaticAssetRule = ({
      emit,
      rule,
      maxSize,
      filename,
      assetType
    }) => {
      const generatorOptions = {
        filename
      };
      if (emit === false) {
        generatorOptions.emit = false;
      }
      rule.oneOf(`${assetType}-asset-url`).type("asset/resource").resourceQuery(/(__inline=false|url)/).set("generator", generatorOptions);
      rule.oneOf(`${assetType}-asset-inline`).type("asset/inline").resourceQuery(/inline/);
      rule.oneOf(`${assetType}-asset`).type("asset").parser({
        dataUrlCondition: {
          maxSize
        }
      }).set("generator", generatorOptions);
    };
    pluginAsset = () => ({
      name: "rsbuild:asset",
      setup(api) {
        api.modifyBundlerChain((chain, { isProd, environment }) => {
          const { config } = environment;
          const createAssetRule = (assetType, exts, emit) => {
            const regExp = getRegExpForExts(exts);
            const distDir = config.output.distPath[assetType];
            const filename = getFilename2(config, assetType, isProd);
            const { dataUriLimit } = config.output;
            const maxSize = typeof dataUriLimit === "number" ? dataUriLimit : dataUriLimit[assetType];
            const rule = chain.module.rule(assetType).test(regExp);
            chainStaticAssetRule({
              emit,
              rule,
              maxSize,
              filename: path12.posix.join(distDir, filename),
              assetType
            });
          };
          const { emitAssets } = config.output;
          createAssetRule("image", IMAGE_EXTENSIONS, emitAssets);
          createAssetRule("svg", ["svg"], emitAssets);
          createAssetRule(
            "media",
            [...VIDEO_EXTENSIONS, ...AUDIO_EXTENSIONS],
            emitAssets
          );
          createAssetRule("font", FONT_EXTENSIONS, emitAssets);
        });
      }
    });
  }
});

// src/rspack/RsbuildHtmlPlugin.ts
var RsbuildHtmlPlugin_exports = {};
__export(RsbuildHtmlPlugin_exports, {
  FILE_ATTRS: () => FILE_ATTRS,
  RsbuildHtmlPlugin: () => RsbuildHtmlPlugin,
  hasTitle: () => hasTitle
});
import path13 from "path";
import { promisify as promisify3 } from "util";
var VOID_TAGS, HEAD_TAGS, FILE_ATTRS, hasTitle, getTagPriority, formatBasicTag, fromBasicTag, formatTags, applyTagConfig, addTitleTag, RsbuildHtmlPlugin;
var init_RsbuildHtmlPlugin = __esm({
  "src/rspack/RsbuildHtmlPlugin.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_pluginHelper();
    VOID_TAGS = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    HEAD_TAGS = [
      "title",
      "base",
      "link",
      "style",
      "meta",
      "script",
      "noscript",
      "template"
    ];
    FILE_ATTRS = {
      link: "href",
      script: "src"
    };
    hasTitle = (html) => html ? /<title/i.test(html) && /<\/title/i.test(html) : false;
    getTagPriority = (tag, tagConfig) => {
      const head = tag.head ?? HEAD_TAGS.includes(tag.tag);
      let priority = head ? -2 : 2;
      const append = tag.append ?? tagConfig.append;
      if (typeof append === "boolean") {
        priority += append ? 1 : -1;
      }
      return priority;
    };
    formatBasicTag = (tag) => ({
      tag: tag.tagName,
      attrs: tag.attributes,
      children: tag.innerHTML
    });
    fromBasicTag = (tag) => ({
      meta: {},
      tagName: tag.tag,
      attributes: tag.attrs ?? {},
      voidTag: VOID_TAGS.includes(tag.tag),
      innerHTML: tag.children
    });
    formatTags = (tags, override) => tags.map((tag) => ({
      ...formatBasicTag(tag),
      publicPath: false,
      ...override
    }));
    applyTagConfig = (data, tagConfig, compilationHash, entryName) => {
      if (!tagConfig.tags?.length) {
        return data;
      }
      const fromInjectTags = (tags2) => {
        const ret = [];
        for (const tag of tags2) {
          const attrs = { ...tag.attrs };
          const filenameTag = FILE_ATTRS[tag.tag];
          let filename = attrs[filenameTag];
          if (typeof filename === "string") {
            const optPublicPath = tag.publicPath ?? tagConfig.publicPath;
            if (typeof optPublicPath === "function") {
              filename = optPublicPath(filename, data.publicPath);
            } else if (typeof optPublicPath === "string") {
              filename = ensureAssetPrefix(filename, optPublicPath);
            } else if (optPublicPath !== false) {
              filename = ensureAssetPrefix(filename, data.publicPath);
            }
            const optHash = tag.hash ?? tagConfig.hash;
            if (typeof optHash === "function") {
              if (compilationHash.length) {
                filename = optHash(filename, compilationHash);
              }
            } else if (typeof optHash === "string") {
              if (optHash.length) {
                filename = `${filename}?${optHash}`;
              }
            } else if (optHash === true) {
              if (compilationHash.length) {
                filename = `${filename}?${compilationHash}`;
              }
            }
            attrs[filenameTag] = filename;
            tag.attrs = attrs;
          }
          ret.push(fromBasicTag(tag));
        }
        return ret;
      };
      let tags = [
        ...formatTags(data.headTags, { head: true }),
        ...formatTags(data.bodyTags, { head: false })
      ];
      const context = {
        hash: compilationHash,
        entryName,
        outputName: data.outputName,
        publicPath: data.publicPath
      };
      for (const item of tagConfig.tags) {
        if (isFunction(item)) {
          tags = item(tags, context) || tags;
        } else {
          tags.push(item);
        }
        tags = tags.sort(
          (tag1, tag2) => getTagPriority(tag1, tagConfig) - getTagPriority(tag2, tagConfig)
        );
      }
      const [headTags, bodyTags] = partition(
        tags,
        (tag) => tag.head ?? HEAD_TAGS.includes(tag.tag)
      );
      data.headTags = fromInjectTags(headTags);
      data.bodyTags = fromInjectTags(bodyTags);
      return data;
    };
    addTitleTag = (headTags, title = "") => {
      headTags.unshift({
        tagName: "title",
        innerHTML: title,
        attributes: {},
        voidTag: false,
        meta: {}
      });
    };
    RsbuildHtmlPlugin = class {
      constructor(options, getEnvironment, modifyTagsFn) {
        __publicField(this, "name");
        __publicField(this, "getEnvironment");
        __publicField(this, "options");
        __publicField(this, "modifyTagsFn");
        this.name = "RsbuildHtmlPlugin";
        this.options = options;
        this.modifyTagsFn = modifyTagsFn;
        this.getEnvironment = getEnvironment;
      }
      apply(compiler) {
        const emitFavicon = async (compilation, favicon) => {
          const name = path13.basename(favicon);
          if (compilation.assets[name]) {
            return name;
          }
          if (!compilation.inputFileSystem) {
            throw new Error(
              `[RsbuildHtmlPlugin] 'compilation.inputFileSystem' is not available.`
            );
          }
          const filename = path13.resolve(compilation.compiler.context, favicon);
          const buf = await promisify3(compilation.inputFileSystem.readFile)(
            filename
          );
          if (!buf) {
            throw new Error(
              `[RsbuildHtmlPlugin] Failed to read the favicon, please check if the '${filename}' file exists'.`
            );
          }
          const source = new compiler.webpack.sources.RawSource(buf, false);
          compilation.emitAsset(name, source);
          return name;
        };
        const addFavicon = async (headTags, favicon, compilation, publicPath) => {
          let href = favicon;
          if (!isURL(favicon)) {
            const name = await emitFavicon(compilation, favicon);
            href = ensureAssetPrefix(name, publicPath);
          }
          const tag = {
            tagName: "link",
            voidTag: true,
            attributes: {
              rel: "icon",
              href
            },
            meta: {}
          };
          if (href.endsWith(".svg")) {
            tag.attributes.type = "image/svg+xml";
          }
          headTags.unshift(tag);
        };
        compiler.hooks.compilation.tap(this.name, (compilation) => {
          getHTMLPlugin().getHooks(compilation).alterAssetTagGroups.tapPromise(this.name, async (data) => {
            const entryName = data.plugin.options?.entryName;
            if (!entryName) {
              return data;
            }
            const { headTags, bodyTags } = data;
            const { favicon, tagConfig, templateContent } = this.options[entryName];
            if (!hasTitle(templateContent)) {
              addTitleTag(headTags, data.plugin.options?.title);
            }
            if (favicon) {
              await addFavicon(headTags, favicon, compilation, data.publicPath);
            }
            const tags = {
              headTags: headTags.map(formatBasicTag),
              bodyTags: bodyTags.map(formatBasicTag)
            };
            const modified = this.modifyTagsFn ? await this.modifyTagsFn(tags, {
              compiler,
              compilation,
              assetPrefix: data.publicPath,
              filename: data.outputName,
              environment: this.getEnvironment()
            }) : tags;
            Object.assign(data, {
              headTags: modified.headTags.map(fromBasicTag),
              bodyTags: modified.bodyTags.map(fromBasicTag)
            });
            if (tagConfig) {
              const hash = compilation.hash ?? "";
              applyTagConfig(data, tagConfig, hash, entryName);
            }
            return data;
          });
        });
      }
    };
  }
});

// src/plugins/html.ts
var html_exports = {};
__export(html_exports, {
  getTemplate: () => getTemplate,
  pluginHtml: () => pluginHtml
});
import fs8 from "fs";
import path14, { isAbsolute as isAbsolute6 } from "path";
import color16 from "../compiled/picocolors/index.js";
function getTitle(entryName, config) {
  return reduceConfigsMergeContext({
    initial: "",
    config: config.html.title,
    ctx: { entryName }
  });
}
function getInject(entryName, config) {
  return reduceConfigsMergeContext({
    initial: "head",
    config: config.html.inject,
    ctx: { entryName }
  });
}
async function getTemplate(entryName, config, rootPath) {
  const templatePath = reduceConfigsMergeContext({
    initial: "",
    config: config.html.template,
    ctx: { entryName }
  });
  if (!templatePath) {
    return {
      templatePath: void 0,
      templateContent: getDefaultTemplateContent(config.html.mountId)
    };
  }
  const absolutePath = isAbsolute6(templatePath) ? templatePath : path14.resolve(rootPath, templatePath);
  if (!existTemplatePath.has(absolutePath)) {
    if (!await isFileExists(absolutePath)) {
      throw new Error(
        `Failed to resolve HTML template, please check if the file exists: ${color16.cyan(
          absolutePath
        )}`
      );
    }
    existTemplatePath.add(absolutePath);
  }
  const templateContent = await fs8.promises.readFile(absolutePath, "utf-8");
  return {
    templatePath: absolutePath,
    templateContent
  };
}
function getFavicon(entryName, config) {
  return reduceConfigsMergeContext({
    initial: "",
    config: config.html.favicon,
    ctx: { entryName }
  });
}
function getMetaTags(entryName, config, templateContent) {
  const metaTags = reduceConfigsMergeContext({
    initial: {},
    config: config.html.meta,
    ctx: { entryName }
  });
  if (templateContent && metaTags.charset) {
    const charsetRegExp = /<meta[^>]+charset=["'][^>]*>/i;
    if (charsetRegExp.test(templateContent)) {
      delete metaTags.charset;
    }
  }
  return metaTags;
}
function getTemplateParameters(entryName, config, assetPrefix) {
  return (compilation, assets, assetTags, pluginOptions) => {
    const { mountId, templateParameters } = config.html;
    const rspackConfig = compilation.options;
    const htmlPlugin2 = {
      tags: assetTags,
      files: assets,
      options: pluginOptions
    };
    const defaultOptions2 = {
      mountId,
      entryName,
      assetPrefix,
      compilation,
      htmlPlugin: htmlPlugin2,
      rspackConfig,
      /**
       * compatible with html-webpack-plugin
       * @deprecated may be removed in a future major version, use `rspackConfig` instead
       */
      webpackConfig: rspackConfig,
      /**
       * compatible with html-webpack-plugin
       * @deprecated may be removed in a future major version, use `htmlPlugin` instead
       */
      htmlWebpackPlugin: htmlPlugin2
    };
    return reduceConfigsWithContext({
      initial: defaultOptions2,
      config: templateParameters,
      ctx: { entryName }
    });
  };
}
function getChunks(entryName, entryValue) {
  const chunks = [entryName];
  for (const item of entryValue) {
    if (!isPlainObject(item)) {
      continue;
    }
    const { dependOn } = item;
    if (!dependOn) {
      continue;
    }
    if (typeof dependOn === "string") {
      chunks.unshift(dependOn);
    } else {
      chunks.unshift(...dependOn);
    }
  }
  return chunks;
}
var getDefaultTemplateContent, existTemplatePath, getTagConfig, pluginHtml;
var init_html = __esm({
  "src/plugins/html.ts"() {
    "use strict";
    init_esm();
    init_dist2();
    init_helpers();
    getDefaultTemplateContent = (mountId) => `<!doctype html><html><head></head><body><div id="${mountId}"></div></body></html>`;
    existTemplatePath = /* @__PURE__ */ new Set();
    getTagConfig = (config) => {
      const tags = castArray(config.html.tags).filter(Boolean);
      if (!tags.length) {
        return void 0;
      }
      return {
        append: true,
        hash: false,
        publicPath: true,
        tags
      };
    };
    pluginHtml = (modifyTagsFn) => ({
      name: "rsbuild:html",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { HtmlPlugin, CHAIN_ID: CHAIN_ID2, environment }) => {
            const { config, htmlPaths } = environment;
            if (Object.keys(htmlPaths).length === 0) {
              return;
            }
            const assetPrefix = getPublicPathFromChain(chain, false);
            const entries = chain.entryPoints.entries() || {};
            const entryNames = Object.keys(entries).filter(
              (entryName) => Boolean(htmlPaths[entryName])
            );
            const htmlInfoMap = {};
            const finalOptions = await Promise.all(
              entryNames.map(async (entryName) => {
                const entryValue = entries[entryName].values();
                const chunks = getChunks(entryName, entryValue);
                const inject = getInject(entryName, config);
                const filename = htmlPaths[entryName];
                const { templatePath, templateContent } = await getTemplate(
                  entryName,
                  config,
                  api.context.rootPath
                );
                const templateParameters = getTemplateParameters(
                  entryName,
                  config,
                  assetPrefix
                );
                const metaTags = getMetaTags(entryName, config, templateContent);
                const pluginOptions = {
                  meta: metaTags,
                  chunks,
                  inject,
                  filename,
                  entryName,
                  templateParameters,
                  scriptLoading: config.html.scriptLoading
                };
                if (templatePath) {
                  pluginOptions.template = templatePath;
                }
                if (chunks.length > 1) {
                  pluginOptions.chunksSortMode = "manual";
                }
                const htmlInfo = {};
                htmlInfoMap[entryName] = htmlInfo;
                if (templateContent) {
                  htmlInfo.templateContent = templateContent;
                }
                const tagConfig = getTagConfig(environment.config);
                if (tagConfig) {
                  htmlInfo.tagConfig = tagConfig;
                }
                pluginOptions.title = getTitle(entryName, config);
                const favicon = getFavicon(entryName, config);
                if (favicon) {
                  htmlInfo.favicon = favicon;
                }
                const finalOptions2 = reduceConfigsWithContext({
                  initial: pluginOptions,
                  config: typeof config.tools.htmlPlugin === "boolean" ? {} : config.tools.htmlPlugin,
                  ctx: { entryName, entryValue }
                });
                if (!finalOptions2.template && !finalOptions2.templateContent) {
                  pluginOptions.template = "";
                  pluginOptions.templateContent = templateContent;
                }
                return finalOptions2;
              })
            );
            entryNames.forEach((entryName, index) => {
              chain.plugin(`${CHAIN_ID2.PLUGIN.HTML}-${entryName}`).use(HtmlPlugin, [finalOptions[index]]);
            });
            const { RsbuildHtmlPlugin: RsbuildHtmlPlugin2 } = await Promise.resolve().then(() => (init_RsbuildHtmlPlugin(), RsbuildHtmlPlugin_exports));
            chain.plugin("rsbuild-html-plugin").use(RsbuildHtmlPlugin2, [
              htmlInfoMap,
              () => environment,
              modifyTagsFn?.(environment.name)
            ]);
            if (config.html) {
              const { crossorigin } = config.html;
              if (crossorigin) {
                const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
                chain.output.crossOriginLoading(formattedCrossorigin);
              }
            }
          }
        );
        api.modifyHTMLTags({
          // ensure `crossorigin` and `nonce` can be applied to all tags
          order: "post",
          handler: ({ headTags, bodyTags }, { environment }) => {
            const { config } = environment;
            const { crossorigin } = config.html;
            const allTags = [...headTags, ...bodyTags];
            if (crossorigin) {
              const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
              for (const tag of allTags) {
                if (tag.tag === "script" && tag.attrs?.src || tag.tag === "link" && tag.attrs?.rel === "stylesheet") {
                  tag.attrs.crossorigin ??= formattedCrossorigin;
                }
              }
            }
            return { headTags, bodyTags };
          }
        });
      }
    });
  }
});

// src/plugins/appIcon.ts
var appIcon_exports = {};
__export(appIcon_exports, {
  pluginAppIcon: () => pluginAppIcon
});
import path15 from "path";
import { promisify as promisify4 } from "util";
import { lookup } from "../compiled/mrmime/index.js";
var pluginAppIcon;
var init_appIcon = __esm({
  "src/plugins/appIcon.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    pluginAppIcon = () => ({
      name: "rsbuild:app-icon",
      setup(api) {
        const htmlTagsMap = /* @__PURE__ */ new Map();
        const iconFormatMap = /* @__PURE__ */ new Map();
        const formatIcon = (icon, distDir, publicPath) => {
          const { src, size } = icon;
          const cached = iconFormatMap.get(src);
          if (cached) {
            return { ...cached, ...icon };
          }
          const sizes = `${size}x${size}`;
          if (isURL(src)) {
            const paths2 = {
              sizes,
              isURL: true,
              requestPath: src,
              absolutePath: src,
              relativePath: src,
              mimeType: lookup(src)
            };
            iconFormatMap.set(src, paths2);
            return { ...paths2, ...icon };
          }
          const absolutePath = path15.isAbsolute(src) ? src : path15.join(api.context.rootPath, src);
          const relativePath = path15.posix.join(
            distDir,
            path15.basename(absolutePath)
          );
          const requestPath = ensureAssetPrefix(relativePath, publicPath);
          const paths = {
            sizes,
            requestPath,
            absolutePath,
            relativePath,
            mimeType: lookup(absolutePath)
          };
          iconFormatMap.set(src, paths);
          return { ...paths, ...icon };
        };
        api.processAssets(
          { stage: "additional" },
          async ({ compilation, environment, sources }) => {
            const { config } = environment;
            const { appIcon } = config.html;
            if (!appIcon) {
              return;
            }
            const distDir = config.output.distPath.image;
            const manifestFile = appIcon.filename ?? "manifest.webmanifest";
            const publicPath = getPublicPathFromCompiler(compilation);
            const icons = appIcon.icons.map(
              (icon) => formatIcon(icon, distDir, publicPath)
            );
            const tags = [];
            for (const icon of icons) {
              if (icon.target === "web-app-manifest" && !appIcon.name) {
                throw new Error(
                  "[rsbuild:app-icon] `appIcon.name` is required when `target` is 'web-app-manifest'."
                );
              }
              if (!icon.isURL) {
                if (!compilation.inputFileSystem) {
                  throw new Error(
                    `[rsbuild:app-icon] 'compilation.inputFileSystem' is not available.`
                  );
                }
                if (!await fileExistsByCompilation(compilation, icon.absolutePath)) {
                  throw new Error(
                    `[rsbuild:app-icon] Can not find the app icon, please check if the '${icon.relativePath}' file exists'.`
                  );
                }
                const source = await promisify4(
                  compilation.inputFileSystem.readFile
                )(icon.absolutePath);
                if (!source) {
                  throw new Error(
                    `[rsbuild:app-icon] Failed to read the app icon file, please check if the '${icon.relativePath}' file exists'.`
                  );
                }
                compilation.emitAsset(
                  icon.relativePath,
                  new sources.RawSource(source)
                );
              }
              if (icon.target === "apple-touch-icon" || !icon.target && icon.size < 200) {
                tags.push({
                  tag: "link",
                  attrs: {
                    rel: "apple-touch-icon",
                    sizes: icon.sizes,
                    href: icon.requestPath
                  }
                });
              }
            }
            if (appIcon.name) {
              const manifestIcons = icons.filter(
                (icon) => icon.target === "web-app-manifest" || !icon.target
              ).map((icon) => {
                const result = {
                  src: icon.requestPath,
                  sizes: icon.sizes
                };
                if (icon.mimeType) {
                  return { ...result, type: icon.mimeType };
                }
                return result;
              });
              const manifest = {
                name: appIcon.name,
                icons: manifestIcons
              };
              compilation.emitAsset(
                manifestFile,
                new sources.RawSource(JSON.stringify(manifest))
              );
              tags.push({
                tag: "link",
                attrs: {
                  rel: "manifest",
                  href: ensureAssetPrefix(manifestFile, publicPath)
                }
              });
            }
            if (tags.length) {
              htmlTagsMap.set(environment.name, tags);
            }
          }
        );
        api.modifyHTMLTags(({ headTags, bodyTags }, { environment }) => {
          const tags = htmlTagsMap.get(environment.name);
          if (tags) {
            headTags.unshift(...tags);
          }
          return { headTags, bodyTags };
        });
        api.onCloseDevServer(() => {
          htmlTagsMap.clear();
          iconFormatMap.clear();
        });
      }
    });
  }
});

// src/plugins/wasm.ts
var wasm_exports = {};
__export(wasm_exports, {
  pluginWasm: () => pluginWasm
});
import { posix as posix5 } from "path";
var pluginWasm;
var init_wasm = __esm({
  "src/plugins/wasm.ts"() {
    "use strict";
    init_esm();
    pluginWasm = () => ({
      name: "rsbuild:wasm",
      setup(api) {
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const { config } = environment;
          const distPath = config.output.distPath.wasm;
          chain.experiments({
            ...chain.get("experiments"),
            asyncWebAssembly: true
          });
          const wasmFilename = posix5.join(distPath, "[hash].module.wasm");
          chain.output.merge({
            webassemblyModuleFilename: wasmFilename
          });
          chain.module.rule(CHAIN_ID2.RULE.WASM).test(/\.wasm$/).merge({
            dependency: "url"
          }).type("asset/resource").set("generator", {
            filename: wasmFilename
          });
        });
      }
    });
  }
});

// src/plugins/moment.ts
var moment_exports = {};
__export(moment_exports, {
  pluginMoment: () => pluginMoment
});
var pluginMoment;
var init_moment = __esm({
  "src/plugins/moment.ts"() {
    "use strict";
    init_esm();
    pluginMoment = () => ({
      name: "rsbuild:moment",
      setup(api) {
        api.modifyBundlerChain(async (chain, { environment, bundler }) => {
          const { config } = environment;
          if (config.performance.removeMomentLocale) {
            chain.plugin("remove-moment-locale").use(bundler.IgnorePlugin, [
              {
                resourceRegExp: /^\.\/locale$/,
                contextRegExp: /moment$/
              }
            ]);
          }
        });
      }
    });
  }
});

// src/plugins/nodeAddons.ts
var nodeAddons_exports = {};
__export(nodeAddons_exports, {
  pluginNodeAddons: () => pluginNodeAddons
});
import path16 from "path";
var getFilename3, pluginNodeAddons;
var init_nodeAddons = __esm({
  "src/plugins/nodeAddons.ts"() {
    "use strict";
    init_esm();
    getFilename3 = (resourcePath) => {
      let basename = "";
      if (resourcePath) {
        const parsed = path16.parse(resourcePath);
        if (parsed.dir) {
          basename = parsed.name;
        }
      }
      if (basename) {
        return `${basename}.node`;
      }
      return null;
    };
    pluginNodeAddons = () => ({
      name: "rsbuild:node-addons",
      setup(api) {
        api.transform(
          { test: /\.node$/, targets: ["node"], raw: true },
          ({ code, emitFile, resourcePath }) => {
            const name = getFilename3(resourcePath);
            if (name === null) {
              throw new Error(`Failed to load Node.js addon: "${resourcePath}"`);
            }
            emitFile(name, code);
            return `
try {
const path = require("path");
process.dlopen(module, path.join(__dirname, "${name}"));
} catch (error) {
throw new Error('Failed to load Node.js addon: "${name}"\\n' + error);
}
`;
          }
        );
      }
    });
  }
});

// src/plugins/define.ts
var define_exports = {};
__export(define_exports, {
  pluginDefine: () => pluginDefine
});
var pluginDefine;
var init_define = __esm({
  "src/plugins/define.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    pluginDefine = () => ({
      name: "rsbuild:define",
      setup(api) {
        api.modifyBundlerChain((chain, { CHAIN_ID: CHAIN_ID2, bundler, environment }) => {
          const { config } = environment;
          const baseUrl = JSON.stringify(config.server.base);
          const assetPrefix = JSON.stringify(getPublicPathFromChain(chain, false));
          const builtinVars = {
            "import.meta.env.MODE": JSON.stringify(config.mode),
            "import.meta.env.DEV": config.mode === "development",
            "import.meta.env.PROD": config.mode === "production",
            "import.meta.env.BASE_URL": baseUrl,
            "import.meta.env.ASSET_PREFIX": assetPrefix,
            "process.env.BASE_URL": baseUrl,
            "process.env.ASSET_PREFIX": assetPrefix
          };
          chain.plugin(CHAIN_ID2.PLUGIN.DEFINE).use(bundler.DefinePlugin, [
            { ...builtinVars, ...config.source.define }
          ]);
        });
      }
    });
  }
});

// src/plugins/minimize.ts
var minimize_exports = {};
__export(minimize_exports, {
  getSwcMinimizerOptions: () => getSwcMinimizerOptions,
  parseMinifyOptions: () => parseMinifyOptions,
  pluginMinimize: () => pluginMinimize
});
import { rspack as rspack6 } from "@rspack/core";
var import_deepmerge3, getSwcMinimizerOptions, parseMinifyOptions, pluginMinimize;
var init_minimize = __esm({
  "src/plugins/minimize.ts"() {
    "use strict";
    init_esm();
    import_deepmerge3 = __toESM(require_cjs());
    getSwcMinimizerOptions = (config, jsOptions) => {
      const options = {};
      options.minimizerOptions ||= {};
      options.minimizerOptions.format ||= {};
      const { removeConsole } = config.performance;
      if (removeConsole === true) {
        options.minimizerOptions.compress = {
          drop_console: true
        };
      } else if (Array.isArray(removeConsole)) {
        const pureFuncs = removeConsole.map((method) => `console.${method}`);
        options.minimizerOptions.compress = {
          pure_funcs: pureFuncs
        };
      }
      switch (config.output.legalComments) {
        case "inline":
          options.minimizerOptions.format.comments = "some";
          options.extractComments = false;
          break;
        case "linked":
          options.extractComments = true;
          break;
        case "none":
          options.minimizerOptions.format.comments = false;
          options.extractComments = false;
          break;
        default:
          break;
      }
      options.minimizerOptions.format.asciiOnly = config.output.charset === "ascii";
      if (jsOptions) {
        return (0, import_deepmerge3.default)(options, jsOptions);
      }
      return options;
    };
    parseMinifyOptions = (config, isProd) => {
      const { minify } = config.output;
      if (minify === false || !isProd) {
        return {
          minifyJs: false,
          minifyCss: false
        };
      }
      if (minify === true) {
        return {
          minifyJs: true,
          minifyCss: true
        };
      }
      return {
        minifyJs: minify.js !== false,
        minifyCss: minify.css !== false,
        jsOptions: minify.jsOptions,
        cssOptions: minify.cssOptions
      };
    };
    pluginMinimize = () => ({
      name: "rsbuild:minimize",
      setup(api) {
        const isRspack = api.context.bundlerType === "rspack";
        api.modifyBundlerChain(async (chain, { isProd, environment, CHAIN_ID: CHAIN_ID2 }) => {
          const { config } = environment;
          const { minifyJs, minifyCss, jsOptions, cssOptions } = parseMinifyOptions(
            config,
            isProd
          );
          chain.optimization.minimize(minifyJs || minifyCss);
          if (minifyJs && isRspack) {
            chain.optimization.minimizer(CHAIN_ID2.MINIMIZER.JS).use(rspack6.SwcJsMinimizerRspackPlugin, [
              getSwcMinimizerOptions(config, jsOptions)
            ]).end();
          }
          if (minifyCss && isRspack) {
            const defaultOptions2 = {
              minimizerOptions: {
                targets: environment.browserslist
              }
            };
            const mergedOptions = cssOptions ? (0, import_deepmerge3.default)(
              defaultOptions2,
              cssOptions
            ) : defaultOptions2;
            chain.optimization.minimizer(CHAIN_ID2.MINIMIZER.CSS).use(rspack6.LightningCssMinimizerRspackPlugin, [mergedOptions]).end();
          }
        });
      }
    });
  }
});

// src/plugins/progress.ts
var progress_exports = {};
__export(progress_exports, {
  pluginProgress: () => pluginProgress
});
import { rspack as rspack7 } from "@rspack/core";
var pluginProgress;
var init_progress = __esm({
  "src/plugins/progress.ts"() {
    "use strict";
    init_esm();
    pluginProgress = () => ({
      name: "rsbuild:progress",
      setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const { config } = environment;
          const options = config.dev.progressBar ?? // enable progress bar in production mode by default
          config.mode === "production";
          if (!options) {
            return;
          }
          const prefix = options !== true && options.id !== void 0 ? options.id : environment.name;
          chain.plugin(CHAIN_ID2.PLUGIN.PROGRESS).use(rspack7.ProgressPlugin, [
            {
              prefix,
              ...options === true ? {} : options
            }
          ]);
        });
      }
    });
  }
});

// src/plugins/swc.ts
var swc_exports = {};
__export(swc_exports, {
  applySwcDecoratorConfig: () => applySwcDecoratorConfig,
  pluginSwc: () => pluginSwc
});
import fs9 from "fs";
import path17 from "path";
function applyScriptCondition({
  rule,
  isDev,
  config,
  context,
  rsbuildTarget
}) {
  rule.include.add({
    and: [context.rootPath, { not: NODE_MODULES_REGEX }]
  });
  rule.include.add(/\.(?:ts|tsx|jsx|mts|cts)$/);
  if (rsbuildTarget === "web" && isDev) {
    rule.include.add(/[\\/]@rsbuild[\\/]core[\\/]dist[\\/]/);
  }
  for (const condition of config.source.include || []) {
    rule.include.add(condition);
  }
  for (const condition of config.source.exclude || []) {
    rule.exclude.add(condition);
  }
}
function getDefaultSwcConfig(browserslist, cacheRoot) {
  return {
    jsc: {
      externalHelpers: true,
      parser: {
        tsx: false,
        syntax: "typescript",
        decorators: true
      },
      experimental: {
        cacheRoot
      }
    },
    isModule: "unknown",
    env: {
      targets: browserslist
    }
  };
}
async function applyCoreJs(swcConfig, polyfillMode) {
  const coreJsPath = __require.resolve("core-js/package.json");
  const version2 = getCoreJsVersion(coreJsPath);
  const coreJsDir = path17.dirname(coreJsPath);
  swcConfig.env.coreJs = version2;
  if (polyfillMode === "usage") {
    swcConfig.env.shippedProposals = true;
  }
  return coreJsDir;
}
function applyTransformImport(swcConfig, pluginImport) {
  const finalPluginImport = reduceTransformImportConfig(pluginImport);
  if (finalPluginImport?.length) {
    swcConfig.rspackExperiments ??= {};
    swcConfig.rspackExperiments.import ??= [];
    swcConfig.rspackExperiments.import.push(...finalPluginImport);
  }
}
function applySwcDecoratorConfig(swcConfig, config) {
  swcConfig.jsc ||= {};
  swcConfig.jsc.transform ||= {};
  const { version: version2 } = config.source.decorators;
  switch (version2) {
    case "legacy":
      swcConfig.jsc.transform.legacyDecorator = true;
      swcConfig.jsc.transform.decoratorMetadata = true;
      swcConfig.jsc.transform.useDefineForClassFields = false;
      break;
    case "2022-03":
      swcConfig.jsc.transform.legacyDecorator = false;
      swcConfig.jsc.transform.decoratorVersion = "2022-03";
      break;
    default:
      throw new Error(`Unknown decorators version: ${version2}`);
  }
}
var import_deepmerge4, builtinSwcLoaderName, pluginSwc, getCoreJsVersion, reduceTransformImportConfig;
var init_swc = __esm({
  "src/plugins/swc.ts"() {
    "use strict";
    init_esm();
    import_deepmerge4 = __toESM(require_cjs());
    init_dist2();
    init_constants();
    init_helpers();
    builtinSwcLoaderName = "builtin:swc-loader";
    pluginSwc = () => ({
      name: PLUGIN_SWC_NAME,
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, { CHAIN_ID: CHAIN_ID2, isDev, target, environment }) => {
            const { config, browserslist } = environment;
            const cacheRoot = path17.join(api.context.cachePath, ".swc");
            const rule = chain.module.rule(CHAIN_ID2.RULE.JS).test(SCRIPT_REGEX).type("javascript/auto");
            const dataUriRule = chain.module.rule(CHAIN_ID2.RULE.JS_DATA_URI).mimetype({
              or: ["text/javascript", "application/javascript"]
            });
            applyScriptCondition({
              rule,
              isDev,
              config,
              context: api.context,
              rsbuildTarget: target
            });
            if (api.context.bundlerType === "webpack") {
              return;
            }
            const swcConfig = getDefaultSwcConfig(browserslist, cacheRoot);
            applyTransformImport(swcConfig, config.source.transformImport);
            applySwcDecoratorConfig(swcConfig, config);
            if (swcConfig.jsc?.externalHelpers) {
              chain.resolve.alias.set(
                "@swc/helpers",
                path17.dirname(__require.resolve("@swc/helpers/package.json"))
              );
            }
            if (isWebTarget(target)) {
              const polyfillMode = config.output.polyfill;
              if (polyfillMode === "off") {
                swcConfig.env.mode = void 0;
              } else {
                swcConfig.env.mode = polyfillMode;
                const coreJsDir = await applyCoreJs(swcConfig, polyfillMode);
                for (const item of [rule, dataUriRule]) {
                  item.resolve.alias.set("core-js", coreJsDir);
                }
              }
            }
            const mergedSwcConfig = reduceConfigs({
              initial: swcConfig,
              config: config.tools.swc,
              mergeFn: import_deepmerge4.default
            });
            rule.use(CHAIN_ID2.USE.SWC).loader(builtinSwcLoaderName).options(mergedSwcConfig);
            dataUriRule.resolve.set("fullySpecified", false).end().use(CHAIN_ID2.USE.SWC).loader(builtinSwcLoaderName).options(cloneDeep(mergedSwcConfig));
          }
        });
      }
    });
    getCoreJsVersion = (corejsPkgPath) => {
      try {
        const rawJson = fs9.readFileSync(corejsPkgPath, "utf-8");
        const { version: version2 } = JSON.parse(rawJson);
        const [major, minor] = version2.split(".");
        return `${major}.${minor}`;
      } catch (err) {
        return "3";
      }
    };
    reduceTransformImportConfig = (options) => {
      if (!options) {
        return [];
      }
      let imports = [];
      for (const item of castArray(options)) {
        if (isFunction(item)) {
          imports = item(imports) ?? imports;
        } else {
          imports.push(item);
        }
      }
      return imports;
    };
  }
});

// src/plugins/externals.ts
var externals_exports = {};
__export(externals_exports, {
  pluginExternals: () => pluginExternals
});
function pluginExternals() {
  return {
    name: "rsbuild:externals",
    setup(api) {
      api.modifyBundlerChain((chain, { environment }) => {
        const { externals } = environment.config.output;
        if (externals) {
          chain.externals(externals);
        }
      });
      api.onBeforeCreateCompiler(({ bundlerConfigs }) => {
        for (const config of bundlerConfigs) {
          const isWebWorker = Array.isArray(config.target) ? config.target.includes("webworker") : config.target === "webworker";
          if (isWebWorker && config.externals) {
            delete config.externals;
          }
        }
      });
    }
  };
}
var init_externals = __esm({
  "src/plugins/externals.ts"() {
    "use strict";
    init_esm();
  }
});

// src/plugins/splitChunks.ts
var splitChunks_exports = {};
__export(splitChunks_exports, {
  MODULE_PATH_REGEX: () => MODULE_PATH_REGEX,
  getPackageNameFromModulePath: () => getPackageNameFromModulePath,
  pluginSplitChunks: () => pluginSplitChunks
});
import assert from "assert";
function getForceSplittingGroups(forceSplitting) {
  const cacheGroups = {};
  const pairs = Array.isArray(forceSplitting) ? forceSplitting.map(
    (regexp, index) => [`force-split-${index}`, regexp]
  ) : Object.entries(forceSplitting);
  for (const [key, regexp] of pairs) {
    cacheGroups[key] = {
      test: regexp,
      name: key,
      chunks: "all",
      priority: 0,
      // Ignore minimum size, minimum chunks and maximum requests and always create chunks.
      enforce: true
    };
  }
  return cacheGroups;
}
function splitByExperience(ctx) {
  const { override, polyfill, defaultConfig, forceSplittingGroups } = ctx;
  const experienceCacheGroup = {};
  const packageRegExps = {
    axios: /node_modules[\\/]axios(-.+)?[\\/]/
  };
  if (polyfill === "entry" || polyfill === "usage") {
    packageRegExps.polyfill = /node_modules[\\/](?:tslib|core-js|@swc[\\/]helpers)[\\/]/;
  }
  for (const [name, test] of Object.entries(packageRegExps)) {
    const key = `lib-${name}`;
    experienceCacheGroup[key] = {
      test,
      priority: 0,
      name: key
    };
  }
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...experienceCacheGroup,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
function getPackageNameFromModulePath(modulePath) {
  const handleModuleContext = modulePath?.match(MODULE_PATH_REGEX);
  if (!handleModuleContext) {
    return void 0;
  }
  const [, scope, name] = handleModuleContext;
  const packageName = ["npm", (scope ?? "").replace("@", ""), name].filter(Boolean).join(".");
  return packageName;
}
function splitByModule(ctx) {
  const { override, forceSplittingGroups, defaultConfig } = ctx;
  return {
    ...defaultConfig,
    minSize: 0,
    maxInitialRequests: Number.POSITIVE_INFINITY,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...forceSplittingGroups,
      // Core group
      vendors: {
        priority: -9,
        test: NODE_MODULES_REGEX,
        name(module) {
          return module ? getPackageNameFromModulePath(module.context) : void 0;
        }
      },
      ...override.cacheGroups
    }
  };
}
function splitBySize(ctx) {
  const { override, forceSplittingGroups, defaultConfig, userConfig } = ctx;
  assert(userConfig.strategy === "split-by-size");
  return {
    ...defaultConfig,
    minSize: userConfig.minSize ?? 0,
    maxSize: userConfig.maxSize ?? Number.POSITIVE_INFINITY,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
function splitCustom(ctx) {
  const { override, forceSplittingGroups, defaultConfig } = ctx;
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
function allInOne(_ctx) {
  return false;
}
function singleVendor(ctx) {
  const { override, defaultConfig, forceSplittingGroups } = ctx;
  const singleVendorCacheGroup = {
    singleVendor: {
      test: NODE_MODULES_REGEX,
      priority: 0,
      chunks: "all",
      name: "vendor",
      enforce: true
    }
  };
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...singleVendorCacheGroup,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
var MODULE_PATH_REGEX, SPLIT_STRATEGY_DISPATCHER, pluginSplitChunks;
var init_splitChunks = __esm({
  "src/plugins/splitChunks.ts"() {
    "use strict";
    init_esm();
    init_constants();
    MODULE_PATH_REGEX = /.*[\\/]node_modules[\\/](?!\.pnpm[\\/])(?:(@[^\\/]+)[\\/])?([^\\/]+)/;
    SPLIT_STRATEGY_DISPATCHER = {
      "split-by-experience": splitByExperience,
      "split-by-module": splitByModule,
      "split-by-size": splitBySize,
      custom: splitCustom,
      "all-in-one": allInOne,
      "single-vendor": singleVendor
    };
    pluginSplitChunks = () => ({
      name: "rsbuild:split-chunks",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { environment, isServer, isWebWorker }) => {
            if (isServer || isWebWorker) {
              chain.optimization.splitChunks(false);
              if (isWebWorker) {
                chain.module.parser.merge({
                  javascript: {
                    dynamicImportMode: "eager"
                  }
                });
              }
              return;
            }
            const { config } = environment;
            const defaultConfig = {
              chunks: config.moduleFederation?.options?.exposes ? (
                // split only `async` chunks for module federation provider app
                // this ensures that remote entries are not affected by chunk splitting
                "async"
              ) : (
                // split both `initial` and `async` chunks for normal app
                "all"
              ),
              cacheGroups: {}
            };
            if (api.context.bundlerType === "webpack") {
              defaultConfig.enforceSizeThreshold = 5e4;
            }
            const { chunkSplit } = config.performance;
            let forceSplittingGroups = {};
            if (chunkSplit.forceSplitting) {
              forceSplittingGroups = getForceSplittingGroups(
                chunkSplit.forceSplitting
              );
            }
            const override = chunkSplit.strategy === "custom" ? chunkSplit.splitChunks ?? chunkSplit.override : chunkSplit.override;
            const splitChunksOptions = await SPLIT_STRATEGY_DISPATCHER[chunkSplit.strategy || "split-by-experience"]({
              defaultConfig,
              override: override || {},
              forceSplittingGroups,
              userConfig: chunkSplit,
              rootPath: api.context.rootPath,
              polyfill: config.output.polyfill
            });
            chain.optimization.splitChunks(splitChunksOptions);
          }
        );
      }
    });
  }
});

// src/plugins/inlineChunk.ts
var inlineChunk_exports = {};
__export(inlineChunk_exports, {
  pluginInlineChunk: () => pluginInlineChunk
});
import path18 from "path";
import { isRegExp } from "util/types";
function updateSourceMappingURL({
  source,
  compilation,
  publicPath,
  type,
  config
}) {
  const { devtool } = compilation.options;
  if (devtool && // If the source map is inlined, we do not need to update the sourceMappingURL
  !devtool.includes("inline") && source.includes("# sourceMappingURL")) {
    const prefix = addTrailingSlash(
      path18.join(publicPath, config.output.distPath[type] || "")
    );
    return source.replace(
      /# sourceMappingURL=/,
      `# sourceMappingURL=${prefix}`
    );
  }
  return source;
}
function matchTests(name, source, tests) {
  return tests.some((test) => {
    if (isFunction(test)) {
      const size = source.length;
      return test({ name, size });
    }
    return test.exec(name);
  });
}
var pluginInlineChunk;
var init_inlineChunk = __esm({
  "src/plugins/inlineChunk.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    pluginInlineChunk = () => ({
      name: "rsbuild:inline-chunk",
      setup(api) {
        const inlinedAssets = /* @__PURE__ */ new Set();
        const getInlinedScriptTag = (publicPath, tag, compilation, scriptTests, config) => {
          const { assets } = compilation;
          if (!(tag.attrs?.src && typeof tag.attrs.src === "string")) {
            return tag;
          }
          const { src, ...otherAttrs } = tag.attrs;
          const scriptName = publicPath ? src.replace(publicPath, "") : src;
          const asset = assets[scriptName];
          if (asset == null) {
            return tag;
          }
          const source = asset.source().toString();
          const shouldInline = matchTests(scriptName, source, scriptTests);
          if (!shouldInline) {
            return tag;
          }
          const ret = {
            tag: "script",
            children: updateSourceMappingURL({
              source,
              compilation,
              publicPath,
              type: "js",
              config
            }),
            attrs: {
              ...otherAttrs
            }
          };
          inlinedAssets.add(scriptName);
          return ret;
        };
        const getInlinedCSSTag = (publicPath, tag, compilation, styleTests, config) => {
          const { assets } = compilation;
          if (!(tag.attrs?.href && typeof tag.attrs.href === "string")) {
            return tag;
          }
          const linkName = publicPath ? tag.attrs.href.replace(publicPath, "") : tag.attrs.href;
          const asset = assets[linkName];
          if (asset == null) {
            return tag;
          }
          const source = asset.source().toString();
          const shouldInline = matchTests(linkName, source, styleTests);
          if (!shouldInline) {
            return tag;
          }
          const ret = {
            tag: "style",
            children: updateSourceMappingURL({
              source,
              compilation,
              publicPath,
              type: "css",
              config
            })
          };
          inlinedAssets.add(linkName);
          return ret;
        };
        const getInlinedTag = (publicPath, tag, compilation, scriptTests, styleTests, config) => {
          if (tag.tag === "script") {
            return getInlinedScriptTag(
              publicPath,
              tag,
              compilation,
              scriptTests,
              config
            );
          }
          if (tag.tag === "link" && tag.attrs && tag.attrs.rel === "stylesheet") {
            return getInlinedCSSTag(
              publicPath,
              tag,
              compilation,
              styleTests,
              config
            );
          }
          return tag;
        };
        api.processAssets(
          {
            /**
             * Remove marked inline assets in summarize stage,
             * which should be later than the emitting of html-rspack-plugin
             */
            stage: "summarize"
          },
          ({ compiler, compilation }) => {
            if (inlinedAssets.size === 0) {
              return;
            }
            const { devtool } = compiler.options;
            for (const name of inlinedAssets) {
              if (devtool === "hidden-source-map") {
                compilation.deleteAsset(name);
              } else {
                delete compilation.assets[name];
              }
            }
            inlinedAssets.clear();
          }
        );
        api.modifyHTMLTags(
          ({ headTags, bodyTags }, { compiler, compilation, environment }) => {
            const { htmlPaths, config } = environment;
            if (Object.keys(htmlPaths).length === 0) {
              return { headTags, bodyTags };
            }
            const { inlineStyles, inlineScripts } = config.output;
            const scriptTests = [];
            const styleTests = [];
            const isProdMode = environment.config.mode === "production";
            if (inlineScripts) {
              if (inlineScripts === true) {
                isProdMode && scriptTests.push(JS_REGEX);
              } else if (isRegExp(inlineScripts) || isFunction(inlineScripts)) {
                isProdMode && scriptTests.push(inlineScripts);
              } else {
                const enable = inlineScripts.enable === "auto" ? isProdMode : inlineScripts.enable;
                if (enable) {
                  scriptTests.push(inlineScripts.test);
                }
              }
            }
            if (inlineStyles) {
              if (inlineStyles === true) {
                isProdMode && styleTests.push(CSS_REGEX);
              } else if (isRegExp(inlineStyles) || isFunction(inlineStyles)) {
                isProdMode && styleTests.push(inlineStyles);
              } else {
                const enable = inlineStyles.enable === "auto" ? isProdMode : inlineStyles.enable;
                if (enable) {
                  styleTests.push(inlineStyles.test);
                }
              }
            }
            if (!scriptTests.length && !styleTests.length) {
              return { headTags, bodyTags };
            }
            const publicPath = getPublicPathFromCompiler(compiler);
            const updateTag = (tag) => getInlinedTag(
              publicPath,
              tag,
              compilation,
              scriptTests,
              styleTests,
              environment.config
            );
            return {
              headTags: headTags.map(updateTag),
              bodyTags: bodyTags.map(updateTag)
            };
          }
        );
      }
    });
  }
});

// src/plugins/rsdoctor.ts
var rsdoctor_exports = {};
__export(rsdoctor_exports, {
  pluginRsdoctor: () => pluginRsdoctor
});
import color17 from "../compiled/picocolors/index.js";
var pluginRsdoctor;
var init_rsdoctor = __esm({
  "src/plugins/rsdoctor.ts"() {
    "use strict";
    init_esm();
    init_logger();
    pluginRsdoctor = () => ({
      name: "rsbuild:rsdoctor",
      setup(api) {
        api.onBeforeCreateCompiler(async ({ bundlerConfigs }) => {
          if (process.env.RSDOCTOR !== "true") {
            return;
          }
          const isRspack = api.context.bundlerType === "rspack";
          const pluginName = isRspack ? "RsdoctorRspackPlugin" : "RsdoctorWebpackPlugin";
          const isRsdoctorPlugin = (plugin) => plugin?.isRsdoctorPlugin === true || plugin?.constructor?.name === pluginName;
          for (const config of bundlerConfigs) {
            const registered = config.plugins?.some(
              (plugin) => isRsdoctorPlugin(plugin)
            );
            if (registered) {
              return;
            }
          }
          const packageName = isRspack ? "@rsdoctor/rspack-plugin" : "@rsdoctor/webpack-plugin";
          let packagePath;
          try {
            packagePath = __require.resolve(packageName, {
              paths: [api.context.rootPath]
            });
          } catch (err) {
            logger.warn(
              `\`process.env.RSDOCTOR\` enabled, please install ${color17.bold(color17.yellow(packageName))} package.`
            );
            return;
          }
          let module;
          try {
            module = await import(packagePath);
          } catch (err) {
            logger.error(
              `\`process.env.RSDOCTOR\` enabled, but failed to load ${color17.bold(color17.yellow(packageName))} module.`
            );
            return;
          }
          if (!module || !module[pluginName]) {
            return;
          }
          for (const config of bundlerConfigs) {
            config.plugins ||= [];
            config.plugins.push(new module[pluginName]());
          }
          logger.info(`${color17.bold(color17.yellow(packageName))} enabled.`);
        });
      }
    });
  }
});

// src/rspack/preload/helpers/extractChunks.ts
function isAsync(chunk) {
  if ("canBeInitial" in chunk) {
    return !chunk.canBeInitial();
  }
  if ("isInitial" in chunk) {
    return !chunk.isInitial();
  }
  return false;
}
function extractChunks({ compilation, includeType }) {
  const chunks = [...compilation.chunks];
  if (includeType === void 0 || includeType === "async-chunks") {
    return chunks.filter(isAsync);
  }
  if (includeType === "initial") {
    return chunks.filter((chunk) => !isAsync(chunk));
  }
  if (includeType === "all-chunks") {
    return chunks;
  }
  if (includeType === "all-assets") {
    const licenseAssets = [...compilation.assetsInfo?.values() || []].map((info) => {
      if (info.related?.license) {
        return info.related.license;
      }
      return false;
    }).filter(Boolean);
    return [
      {
        files: Object.keys(compilation.assets).filter(
          (t) => !licenseAssets.includes(t)
        )
      }
    ];
  }
  return chunks;
}
var init_extractChunks = __esm({
  "src/rspack/preload/helpers/extractChunks.ts"() {
    "use strict";
    init_esm();
  }
});

// src/rspack/preload/helpers/determineAsValue.ts
import path19 from "path";
import { URL as URL2 } from "url";
function determineAsValue({
  href,
  file
}) {
  const url2 = new URL2(file || href, "https://example.com");
  const extension = path19.extname(url2.pathname).slice(1);
  if (["css"].includes(extension)) {
    return "style";
  }
  if (IMAGE_EXTENSIONS.includes(extension)) {
    return "image";
  }
  if (VIDEO_EXTENSIONS.includes(extension)) {
    return "video";
  }
  if (AUDIO_EXTENSIONS.includes(extension)) {
    return "audio";
  }
  if (FONT_EXTENSIONS.includes(extension)) {
    return "font";
  }
  if (["vtt"].includes(extension)) {
    return "track";
  }
  return "script";
}
var init_determineAsValue = __esm({
  "src/rspack/preload/helpers/determineAsValue.ts"() {
    "use strict";
    init_esm();
    init_constants();
  }
});

// src/rspack/preload/helpers/doesChunkBelongToHtml.ts
function recursiveChunkGroup(chunkGroup) {
  const parents = chunkGroup.getParents();
  if (!parents.length) {
    return [chunkGroup.name];
  }
  return parents.flatMap((chunkParent) => recursiveChunkGroup(chunkParent));
}
function recursiveChunkEntryNames(chunk) {
  const isChunkName = (name) => Boolean(name);
  const [...chunkGroups] = chunk.groupsIterable;
  const names = chunkGroups.flatMap((chunkGroup) => recursiveChunkGroup(chunkGroup)).filter(isChunkName);
  return [...new Set(names)];
}
function isChunksFiltered(chunkName, includeChunks, excludeChunks) {
  if (Array.isArray(includeChunks) && includeChunks.indexOf(chunkName) === -1) {
    return false;
  }
  if (Array.isArray(excludeChunks) && excludeChunks.indexOf(chunkName) !== -1) {
    return false;
  }
  return true;
}
function doesChunkBelongToHtml({
  chunk,
  htmlPluginData
}) {
  const { options } = htmlPluginData.plugin;
  const chunkNames = recursiveChunkEntryNames(chunk);
  return chunkNames.some(
    (chunkName) => isChunksFiltered(chunkName, options?.chunks, options?.excludeChunks)
  );
}
var init_doesChunkBelongToHtml = __esm({
  "src/rspack/preload/helpers/doesChunkBelongToHtml.ts"() {
    "use strict";
    init_esm();
  }
});

// src/rspack/preload/helpers/type.ts
var init_type2 = __esm({
  "src/rspack/preload/helpers/type.ts"() {
    "use strict";
    init_esm();
  }
});

// src/rspack/preload/helpers/index.ts
var init_helpers2 = __esm({
  "src/rspack/preload/helpers/index.ts"() {
    "use strict";
    init_esm();
    init_extractChunks();
    init_determineAsValue();
    init_doesChunkBelongToHtml();
    init_type2();
  }
});

// src/rspack/preload/HtmlPreloadOrPrefetchPlugin.ts
var HtmlPreloadOrPrefetchPlugin_exports = {};
__export(HtmlPreloadOrPrefetchPlugin_exports, {
  HtmlPreloadOrPrefetchPlugin: () => HtmlPreloadOrPrefetchPlugin
});
function filterResourceHints(resourceHints, scripts) {
  return resourceHints.filter(
    (resourceHint) => !scripts.find(
      (script) => script.attributes.src === resourceHint.attributes.href
    )
  );
}
function generateLinks(options, type, compilation, htmlPluginData, HTMLCount) {
  const extractedChunks = extractChunks({
    compilation,
    includeType: options.type
  });
  const htmlChunks = (
    // Handle all chunks.
    options.type === "all-assets" || HTMLCount === 1 ? extractedChunks : (
      // Only handle chunks imported by this HtmlRspackPlugin.
      extractedChunks.filter(
        (chunk) => doesChunkBelongToHtml({
          chunk,
          compilation,
          htmlPluginData,
          pluginOptions: options
        })
      )
    )
  );
  const allFiles = htmlChunks.reduce(
    (accumulated, chunk) => accumulated.concat([
      ...chunk.files,
      // sourcemap files are inside auxiliaryFiles in webpack5
      ...chunk.auxiliaryFiles || []
    ]),
    []
  );
  const uniqueFiles = new Set(allFiles);
  const filteredFiles = [...uniqueFiles].filter((file) => [/.map$/].every((regex) => !regex.test(file))).filter(
    (file) => !options.include || (typeof options.include === "function" ? options.include(file) : options.include.some((regex) => new RegExp(regex).test(file)))
  ).filter(
    (file) => !options.exclude || (typeof options.exclude === "function" ? !options.exclude(file) : options.exclude.every((regex) => !new RegExp(regex).test(file)))
  );
  const sortedFilteredFiles = filteredFiles.sort();
  const links = [];
  const { publicPath, crossOriginLoading } = compilation.outputOptions;
  for (const file of sortedFilteredFiles) {
    const href = ensureAssetPrefix(file, publicPath);
    const attributes = {
      href,
      rel: type
    };
    if (type === "preload") {
      attributes.as = determineAsValue({
        href,
        file
      });
      if (attributes.as === "font") {
        attributes.crossorigin = "";
      }
      if (attributes.as === "script" || attributes.as === "style") {
        if (crossOriginLoading && !(crossOriginLoading !== "use-credentials" && publicPath === "/")) {
          attributes.crossorigin = crossOriginLoading === "anonymous" ? "" : crossOriginLoading;
        }
      }
    }
    links.push({
      tagName: "link",
      attributes,
      voidTag: true,
      meta: {}
    });
  }
  return links;
}
var defaultOptions, HtmlPreloadOrPrefetchPlugin;
var init_HtmlPreloadOrPrefetchPlugin = __esm({
  "src/rspack/preload/HtmlPreloadOrPrefetchPlugin.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    init_pluginHelper();
    init_helpers2();
    defaultOptions = {
      type: "async-chunks"
    };
    HtmlPreloadOrPrefetchPlugin = class {
      constructor(options, type, HTMLCount) {
        __publicField(this, "options");
        __publicField(this, "resourceHints", []);
        __publicField(this, "type");
        __publicField(this, "HTMLCount");
        this.options = {
          ...defaultOptions,
          ...typeof options === "boolean" ? {} : options
        };
        this.type = type;
        this.HTMLCount = HTMLCount;
      }
      apply(compiler) {
        compiler.hooks.compilation.tap(this.constructor.name, (compilation) => {
          getHTMLPlugin().getHooks(compilation).beforeAssetTagGeneration.tap(
            `HTML${upperFirst(this.type)}Plugin`,
            (htmlPluginData) => {
              this.resourceHints = generateLinks(
                this.options,
                this.type,
                compilation,
                htmlPluginData,
                this.HTMLCount
              );
              return htmlPluginData;
            }
          );
          getHTMLPlugin().getHooks(compilation).alterAssetTags.tap(
            `HTML${upperFirst(this.type)}Plugin`,
            (htmlPluginData) => {
              if (this.resourceHints) {
                htmlPluginData.assetTags.styles = [
                  ...filterResourceHints(
                    this.resourceHints,
                    htmlPluginData.assetTags.scripts
                  ),
                  ...htmlPluginData.assetTags.styles
                ];
              }
              return htmlPluginData;
            }
          );
        });
      }
    };
  }
});

// src/plugins/resourceHints.ts
var resourceHints_exports = {};
__export(resourceHints_exports, {
  pluginResourceHints: () => pluginResourceHints
});
var generateLinks2, pluginResourceHints;
var init_resourceHints = __esm({
  "src/plugins/resourceHints.ts"() {
    "use strict";
    init_esm();
    generateLinks2 = (options, rel) => options.map((option) => ({
      tag: "link",
      attrs: {
        rel,
        ...option
      }
    }));
    pluginResourceHints = () => ({
      name: "rsbuild:resource-hints",
      setup(api) {
        api.modifyHTMLTags(({ headTags, bodyTags }, { environment }) => {
          const { config } = environment;
          const { dnsPrefetch, preconnect } = config.performance;
          if (dnsPrefetch) {
            const attrs = dnsPrefetch.map((option) => ({ href: option }));
            if (attrs.length) {
              headTags.unshift(...generateLinks2(attrs, "dns-prefetch"));
            }
          }
          if (preconnect) {
            const attrs = preconnect.map(
              (option) => typeof option === "string" ? { href: option } : option
            );
            if (attrs.length) {
              headTags.unshift(...generateLinks2(attrs, "preconnect"));
            }
          }
          return { headTags, bodyTags };
        });
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const { config, htmlPaths } = environment;
          if (Object.keys(htmlPaths).length === 0) {
            return;
          }
          const {
            performance: { preload, prefetch }
          } = config;
          const HTMLCount = chain.entryPoints.values().length;
          const { HtmlPreloadOrPrefetchPlugin: HtmlPreloadOrPrefetchPlugin2 } = await Promise.resolve().then(() => (init_HtmlPreloadOrPrefetchPlugin(), HtmlPreloadOrPrefetchPlugin_exports));
          if (prefetch) {
            chain.plugin(CHAIN_ID2.PLUGIN.HTML_PREFETCH).use(HtmlPreloadOrPrefetchPlugin2, [prefetch, "prefetch", HTMLCount]);
          }
          if (preload) {
            chain.plugin(CHAIN_ID2.PLUGIN.HTML_PRELOAD).use(HtmlPreloadOrPrefetchPlugin2, [preload, "preload", HTMLCount]);
          }
        });
      }
    });
  }
});

// src/plugins/performance.ts
var performance_exports = {};
__export(performance_exports, {
  pluginPerformance: () => pluginPerformance
});
var pluginPerformance;
var init_performance = __esm({
  "src/plugins/performance.ts"() {
    "use strict";
    init_esm();
    pluginPerformance = () => ({
      name: "rsbuild:performance",
      setup(api) {
        api.modifyRsbuildConfig({
          order: "post",
          handler: (rsbuildConfig) => {
            const applyBundleAnalyzeConfig = (config) => {
              if (!config.performance?.bundleAnalyze) {
                config.performance ??= {};
                config.performance.bundleAnalyze = {
                  analyzerMode: "disabled",
                  generateStatsFile: true
                };
              } else {
                config.performance.bundleAnalyze = {
                  generateStatsFile: true,
                  ...config.performance.bundleAnalyze || {}
                };
              }
            };
            if (rsbuildConfig.performance?.profile) {
              applyBundleAnalyzeConfig(rsbuildConfig);
            } else if (rsbuildConfig.environments) {
              for (const config of Object.values(rsbuildConfig.environments)) {
                if (config.performance?.profile) {
                  applyBundleAnalyzeConfig(config);
                }
              }
            }
          }
        });
        api.modifyBundlerChain((chain, { environment }) => {
          const { config } = environment;
          const { profile } = config.performance;
          if (!profile) {
            return;
          }
          chain.profile(profile);
        });
      }
    });
  }
});

// src/plugins/bundleAnalyzer.ts
var bundleAnalyzer_exports = {};
__export(bundleAnalyzer_exports, {
  pluginBundleAnalyzer: () => pluginBundleAnalyzer
});
function pluginBundleAnalyzer() {
  return {
    name: "rsbuild:bundle-analyzer",
    setup(api) {
      api.modifyRsbuildConfig({
        order: "post",
        handler: (config) => {
          const useAnalyzer = isUseAnalyzer(config) || Object.values(config.environments || []).some(
            (config2) => isUseAnalyzer(config2)
          );
          if (!useAnalyzer) {
            return;
          }
          config.dev ||= {};
          config.dev.writeToDisk = true;
          return config;
        }
      });
      api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
        const { config } = environment;
        if (!isUseAnalyzer(config)) {
          return;
        }
        const { default: BundleAnalyzer } = await import("../compiled/webpack-bundle-analyzer/index.js");
        chain.plugin(CHAIN_ID2.PLUGIN.BUNDLE_ANALYZER).use(BundleAnalyzer.BundleAnalyzerPlugin, [
          {
            analyzerMode: "static",
            openAnalyzer: false,
            reportFilename: `report-${environment.name}.html`,
            ...config.performance.bundleAnalyze || {}
          }
        ]);
      });
    }
  };
}
var isUseAnalyzer;
var init_bundleAnalyzer = __esm({
  "src/plugins/bundleAnalyzer.ts"() {
    "use strict";
    init_esm();
    isUseAnalyzer = (config) => process.env.BUNDLE_ANALYZE || config.performance?.bundleAnalyze;
  }
});

// src/plugins/server.ts
var server_exports = {};
__export(server_exports, {
  pluginServer: () => pluginServer
});
import fs10 from "fs";
import { isAbsolute as isAbsolute7, join as join12 } from "path";
var pluginServer;
var init_server = __esm({
  "src/plugins/server.ts"() {
    "use strict";
    init_esm();
    init_config();
    init_open();
    pluginServer = () => ({
      name: "rsbuild:server",
      setup(api) {
        const onStartServer = async ({ port, routes }) => {
          const config = api.getNormalizedConfig();
          if (config.server.open) {
            open({
              https: api.context.devServer?.https,
              port,
              routes,
              config
            });
          }
        };
        api.onAfterStartDevServer(onStartServer);
        api.onAfterStartProdServer(onStartServer);
        api.onBeforeBuild(async ({ isFirstCompile }) => {
          if (!isFirstCompile) {
            return;
          }
          const config = api.getNormalizedConfig();
          const publicDirs = normalizePublicDirs(config.server.publicDir);
          for (const publicDir of publicDirs) {
            const { name, copyOnBuild } = publicDir;
            if (!copyOnBuild || !name) {
              continue;
            }
            const normalizedPath = isAbsolute7(name) ? name : join12(api.context.rootPath, name);
            if (!fs10.existsSync(normalizedPath)) {
              continue;
            }
            try {
              await fs10.promises.cp(normalizedPath, api.context.distPath, {
                recursive: true,
                // dereference symlinks
                dereference: true
              });
            } catch (err) {
              if (err instanceof Error) {
                err.message = `Copy public dir (${normalizedPath}) to dist failed:
${err.message}`;
              }
              throw err;
            }
          }
        });
      }
    });
  }
});

// src/plugins/manifest.ts
var manifest_exports = {};
__export(manifest_exports, {
  pluginManifest: () => pluginManifest
});
var generateManifest, pluginManifest;
var init_manifest = __esm({
  "src/plugins/manifest.ts"() {
    "use strict";
    init_esm();
    init_helpers2();
    generateManifest = (htmlPaths) => (_seed, files) => {
      const chunkEntries = /* @__PURE__ */ new Map();
      const licenseMap = /* @__PURE__ */ new Map();
      const allFiles = files.map((file) => {
        if (file.chunk) {
          const names = recursiveChunkEntryNames(file.chunk);
          for (const name of names) {
            chunkEntries.set(name, [file, ...chunkEntries.get(name) || []]);
          }
        }
        if (file.path.endsWith(".LICENSE.txt")) {
          const sourceFilePath = file.path.split(".LICENSE.txt")[0];
          licenseMap.set(sourceFilePath, file.path);
        }
        return file.path;
      });
      const entries = {};
      for (const [name, chunkFiles] of chunkEntries) {
        const assets = /* @__PURE__ */ new Set();
        const initialJS = [];
        const asyncJS = [];
        const initialCSS = [];
        const asyncCSS = [];
        for (const file of chunkFiles) {
          if (file.isInitial) {
            if (file.path.endsWith(".css")) {
              initialCSS.push(file.path);
            } else {
              initialJS.push(file.path);
            }
          } else {
            if (file.path.endsWith(".css")) {
              asyncCSS.push(file.path);
            } else {
              asyncJS.push(file.path);
            }
          }
          const relatedLICENSE = licenseMap.get(file.path);
          if (relatedLICENSE) {
            assets.add(relatedLICENSE);
          }
          for (const auxiliaryFile of file.chunk.auxiliaryFiles) {
            assets.add(auxiliaryFile);
          }
        }
        const entryManifest = {};
        if (assets.size) {
          entryManifest.assets = Array.from(assets);
        }
        const htmlPath = files.find((f) => f.name === htmlPaths[name])?.path;
        if (htmlPath) {
          entryManifest.html = [htmlPath];
        }
        if (initialJS.length) {
          entryManifest.initial = {
            js: initialJS
          };
        }
        if (initialCSS.length) {
          entryManifest.initial = {
            ...entryManifest.initial || {},
            css: initialCSS
          };
        }
        if (asyncJS.length) {
          entryManifest.async = {
            js: asyncJS
          };
        }
        if (asyncCSS.length) {
          entryManifest.async = {
            ...entryManifest.async || {},
            css: asyncCSS
          };
        }
        entries[name] = entryManifest;
      }
      return {
        allFiles,
        entries
      };
    };
    pluginManifest = () => ({
      name: "rsbuild:manifest",
      setup(api) {
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const {
            output: { manifest }
          } = environment.config;
          if (manifest === false) {
            return;
          }
          const fileName = typeof manifest === "string" ? manifest : "manifest.json";
          const { RspackManifestPlugin } = await import("../compiled/rspack-manifest-plugin/index.js");
          const { htmlPaths } = environment;
          chain.plugin(CHAIN_ID2.PLUGIN.MANIFEST).use(RspackManifestPlugin, [
            {
              fileName,
              generate: generateManifest(htmlPaths)
            }
          ]);
        });
      }
    });
  }
});

// src/plugins/moduleFederation.ts
var moduleFederation_exports = {};
__export(moduleFederation_exports, {
  pluginModuleFederation: () => pluginModuleFederation
});
import { isRegExp as isRegExp2 } from "util/types";
import { rspack as rspack8 } from "@rspack/core";
function pluginModuleFederation() {
  return {
    name: "rsbuild:module-federation",
    setup(api) {
      if (api.context.bundlerType === "webpack") {
        return;
      }
      api.modifyRsbuildConfig((config) => {
        const { moduleFederation } = config;
        if (!moduleFederation?.options) {
          return;
        }
        if (moduleFederation.options.exposes && config.server?.port && !config.dev?.client?.port) {
          config.dev ||= {};
          config.dev.client ||= {};
          config.dev.client.port = config.server.port;
        }
      });
      api.modifyEnvironmentConfig((config) => {
        if (!config.moduleFederation?.options) {
          return;
        }
        if (config.performance?.chunkSplit?.strategy === "split-by-experience") {
          config.performance.chunkSplit = {
            ...config.performance.chunkSplit,
            strategy: "custom"
          };
        }
        config.source.include = [
          ...config.source.include || [],
          /@module-federation[\\/]sdk/,
          /@module-federation[\\/]runtime/
        ];
      });
      api.modifyBundlerChain(
        async (chain, { CHAIN_ID: CHAIN_ID2, target, environment }) => {
          const { config } = environment;
          if (!config.moduleFederation?.options || target !== "web") {
            return;
          }
          const { options } = config.moduleFederation;
          chain.plugin(CHAIN_ID2.PLUGIN.MODULE_FEDERATION).use(rspack8.container.ModuleFederationPlugin, [options]);
          if (options.name) {
            if (options.exposes) {
              chain.plugin("mf-patch-split-chunks").use(PatchSplitChunksPlugin, [options.name]);
            }
            if (!chain.output.get("uniqueName")) {
              chain.output.set("uniqueName", options.name);
            }
          }
          const publicPath = chain.output.get("publicPath");
          if (publicPath === DEFAULT_ASSET_PREFIX) {
            chain.output.set("publicPath", "auto");
          }
        }
      );
    }
  };
}
var PatchSplitChunksPlugin;
var init_moduleFederation = __esm({
  "src/plugins/moduleFederation.ts"() {
    "use strict";
    init_esm();
    init_constants();
    PatchSplitChunksPlugin = class {
      constructor(name) {
        __publicField(this, "name");
        this.name = name;
      }
      apply(compiler) {
        const { splitChunks } = compiler.options.optimization;
        if (!splitChunks) {
          return;
        }
        const applyPatch = (cacheGroup) => {
          if (typeof cacheGroup !== "object" || isRegExp2(cacheGroup)) {
            return;
          }
          const { chunks } = cacheGroup;
          if (!chunks || chunks === "async") {
            return;
          }
          if (typeof chunks === "function") {
            const prevChunks = chunks;
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return prevChunks(chunk);
            };
            return;
          }
          if (chunks === "all") {
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return true;
            };
            return;
          }
          if (chunks === "initial") {
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return chunk.isOnlyInitial();
            };
            return;
          }
        };
        applyPatch(splitChunks);
        const { cacheGroups } = splitChunks;
        if (!cacheGroups) {
          return;
        }
        for (const cacheGroupKey of Object.keys(cacheGroups)) {
          applyPatch(cacheGroups[cacheGroupKey]);
        }
      }
    };
  }
});

// src/plugins/rspackProfile.ts
var rspackProfile_exports = {};
__export(rspackProfile_exports, {
  pluginRspackProfile: () => pluginRspackProfile
});
import fs11 from "fs";
import inspector from "inspector";
import path20 from "path";
import rspack9 from "@rspack/core";
var stopProfiler, pluginRspackProfile;
var init_rspackProfile = __esm({
  "src/plugins/rspackProfile.ts"() {
    "use strict";
    init_esm();
    init_logger();
    stopProfiler = (output, profileSession) => {
      if (!profileSession) {
        return;
      }
      profileSession.post("Profiler.stop", (error, param) => {
        if (error) {
          logger.error("Failed to generate JS CPU profile:", error);
          return;
        }
        fs11.writeFileSync(output, JSON.stringify(param.profile));
      });
    };
    pluginRspackProfile = () => ({
      name: "rsbuild:rspack-profile",
      async setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        const RSPACK_PROFILE = process.env.RSPACK_PROFILE?.toUpperCase();
        if (!RSPACK_PROFILE) {
          return;
        }
        const timestamp = Date.now();
        const profileDirName = `rspack-profile-${timestamp}`;
        let profileSession;
        const enableProfileTrace = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("TRACE");
        const enableCPUProfile = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("CPU");
        const enableLogging = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("LOGGING");
        const onStart = () => {
          const profileDir = path20.join(api.context.distPath, profileDirName);
          const traceFilePath = path20.join(profileDir, "trace.json");
          if (!fs11.existsSync(profileDir)) {
            fs11.mkdirSync(profileDir, { recursive: true });
          }
          if (enableProfileTrace) {
            rspack9.experiments.globalTrace.register(
              "trace",
              "chrome",
              traceFilePath
            );
          }
          if (enableCPUProfile) {
            profileSession = new inspector.Session();
            profileSession.connect();
            profileSession.post("Profiler.enable");
            profileSession.post("Profiler.start");
          }
        };
        api.onBeforeBuild(({ isFirstCompile }) => {
          if (isFirstCompile) {
            onStart();
          }
        });
        api.onBeforeStartDevServer(onStart);
        api.onAfterBuild(async ({ stats }) => {
          const loggingFilePath = path20.join(
            api.context.distPath,
            profileDirName,
            "logging.json"
          );
          if (enableLogging && stats) {
            const logging = stats.toJson({
              all: false,
              logging: "verbose",
              loggingTrace: true
            });
            fs11.writeFileSync(loggingFilePath, JSON.stringify(logging));
          }
        });
        api.onExit(() => {
          if (enableProfileTrace) {
            rspack9.experiments.globalTrace.cleanup();
          }
          const profileDir = path20.join(api.context.distPath, profileDirName);
          const cpuProfilePath = path20.join(profileDir, "jscpuprofile.json");
          stopProfiler(cpuProfilePath, profileSession);
          logger.info(`Saved Rspack profile file to ${profileDir}`);
        });
      }
    });
  }
});

// src/plugins/lazyCompilation.ts
var lazyCompilation_exports = {};
__export(lazyCompilation_exports, {
  pluginLazyCompilation: () => pluginLazyCompilation
});
var pluginLazyCompilation;
var init_lazyCompilation = __esm({
  "src/plugins/lazyCompilation.ts"() {
    "use strict";
    init_esm();
    pluginLazyCompilation = () => ({
      name: "rsbuild:lazy-compilation",
      setup(api) {
        api.modifyBundlerChain((chain, { environment, isProd, target }) => {
          if (isProd || target !== "web") {
            return;
          }
          const { config } = environment;
          const options = config.dev?.lazyCompilation;
          if (!options) {
            return;
          }
          chain.experiments({
            ...chain.get("experiments"),
            lazyCompilation: options
          });
        });
      }
    });
  }
});

// src/plugins/sri.ts
var sri_exports = {};
__export(sri_exports, {
  pluginSri: () => pluginSri
});
import crypto2 from "crypto";
var getAssetName, pluginSri;
var init_sri = __esm({
  "src/plugins/sri.ts"() {
    "use strict";
    init_esm();
    init_constants();
    init_helpers();
    init_logger();
    getAssetName = (url2, assetPrefix) => {
      if (url2.startsWith(assetPrefix)) {
        return removeLeadingSlash(url2.replace(assetPrefix, ""));
      }
      return removeLeadingSlash(url2);
    };
    pluginSri = () => ({
      name: "rsbuild:sri",
      setup(api) {
        const placeholder = "RSBUILD_INTEGRITY_PLACEHOLDER:";
        const getAlgorithm = (environment) => {
          const { config } = environment;
          const { sri } = config.security;
          const enable = sri.enable === "auto" ? config.mode === "production" : sri.enable;
          if (!enable) {
            return null;
          }
          const { algorithm = "sha384" } = sri;
          return algorithm;
        };
        api.modifyHTMLTags({
          // ensure `sri` can be applied to all tags
          order: "post",
          handler(tags, { assetPrefix, environment }) {
            const algorithm = getAlgorithm(environment);
            if (!algorithm) {
              return tags;
            }
            const allTags = [...tags.headTags, ...tags.bodyTags];
            for (const tag of allTags) {
              let url2 = "";
              if (!tag.attrs) {
                continue;
              }
              if (tag.tag === "script" && typeof tag.attrs.src === "string") {
                url2 = tag.attrs.src;
              } else if (tag.tag === "link" && tag.attrs.rel === "stylesheet" && typeof tag.attrs.href === "string") {
                url2 = tag.attrs.href;
              }
              if (!url2) {
                continue;
              }
              const assetName = getAssetName(url2, assetPrefix);
              if (!assetName) {
                continue;
              }
              tag.attrs.integrity ??= `${placeholder}${assetName}`;
            }
            return tags;
          }
        });
        const replaceIntegrity = (htmlContent, assets, algorithm, integrityCache) => {
          const regex = /integrity="RSBUILD_INTEGRITY_PLACEHOLDER:([^"]+)"/g;
          const matches = htmlContent.matchAll(regex);
          let replacedHtml = htmlContent;
          const calcIntegrity = (algorithm2, assetName, data) => {
            if (integrityCache.has(assetName)) {
              return integrityCache.get(assetName);
            }
            const hash = crypto2.createHash(algorithm2).update(data).digest().toString("base64");
            const integrity = `${algorithm2}-${hash}`;
            integrityCache.set(assetName, integrity);
            return integrity;
          };
          for (const match of matches) {
            const assetName = match[1];
            if (!assetName) {
              continue;
            }
            if (assets[assetName]) {
              const integrity = calcIntegrity(
                algorithm,
                assetName,
                assets[assetName].buffer()
              );
              replacedHtml = replacedHtml.replaceAll(
                `integrity="${placeholder}${assetName}"`,
                `integrity="${integrity}"`
              );
            } else {
              logger.debug(
                `[rsbuild:sri] failed to generate integrity for ${assetName}.`
              );
              replacedHtml = replacedHtml.replace(
                `integrity="${placeholder}${assetName}"`,
                ""
              );
            }
          }
          return replacedHtml;
        };
        api.processAssets(
          {
            // use to final stage to get the final asset content
            stage: "report"
          },
          ({ assets, sources, environment }) => {
            const { htmlPaths } = environment;
            if (Object.keys(htmlPaths).length === 0) {
              return;
            }
            const algorithm = getAlgorithm(environment);
            if (!algorithm) {
              return;
            }
            const integrityCache = /* @__PURE__ */ new Map();
            for (const asset of Object.keys(assets)) {
              if (!HTML_REGEX.test(asset)) {
                continue;
              }
              const htmlContent = assets[asset].source();
              if (!htmlContent.includes(placeholder)) {
                continue;
              }
              assets[asset] = new sources.RawSource(
                replaceIntegrity(htmlContent, assets, algorithm, integrityCache)
              );
            }
          }
        );
      }
    });
  }
});

// src/plugins/nonce.ts
var nonce_exports = {};
__export(nonce_exports, {
  pluginNonce: () => pluginNonce
});
var pluginNonce;
var init_nonce = __esm({
  "src/plugins/nonce.ts"() {
    "use strict";
    init_esm();
    init_helpers();
    pluginNonce = () => ({
      name: "rsbuild:nonce",
      setup(api) {
        api.onAfterCreateCompiler(({ compiler, environments }) => {
          const nonces = Object.values(environments).map((environment) => {
            const { nonce } = environment.config.security;
            return nonce;
          });
          if (!nonces.some((nonce) => !!nonce)) {
            return;
          }
          const environmentList = Object.values(environments);
          applyToCompiler(compiler, (compiler2, index) => {
            const nonce = nonces[index];
            const environment = environmentList.find(
              (item) => item.index === index
            );
            const hasHTML = Object.keys(environment?.htmlPaths ?? {}).length;
            if (!hasHTML || !nonce) {
              return;
            }
            const injectCode = createVirtualModule(
              `__webpack_nonce__ = "${nonce}";`
            );
            new compiler2.webpack.EntryPlugin(compiler2.context, injectCode, {
              name: void 0
            }).apply(compiler2);
          });
        });
        api.modifyHTMLTags({
          // ensure `nonce` can be applied to all tags
          order: "post",
          handler: ({ headTags, bodyTags }, { environment }) => {
            const { config } = environment;
            const { nonce } = config.security;
            const allTags = [...headTags, ...bodyTags];
            if (nonce) {
              for (const tag of allTags) {
                if (tag.tag === "script" || tag.tag === "style") {
                  tag.attrs ??= {};
                  tag.attrs.nonce = nonce;
                }
              }
            }
            return { headTags, bodyTags };
          }
        });
      }
    });
  }
});

// src/server/prodServer.ts
var prodServer_exports = {};
__export(prodServer_exports, {
  RsbuildProdServer: () => RsbuildProdServer,
  startProdServer: () => startProdServer
});
async function startProdServer(context, config, { getPortSilently } = {}) {
  const { port, host, https, portTip } = await getServerConfig({
    config
  });
  const { default: connect } = await import("../compiled/connect/index.js");
  const middlewares = connect();
  const serverConfig = config.server;
  const server = new RsbuildProdServer(
    {
      pwd: context.rootPath,
      output: {
        path: context.distPath,
        assetPrefixes: Object.values(context.environments).map(
          (e) => pathnameParse(e.config.output.assetPrefix)
        )
      },
      serverConfig
    },
    middlewares
  );
  await context.hooks.onBeforeStartProdServer.call();
  const httpServer = await createHttpServer({
    serverConfig,
    middlewares: server.middlewares
  });
  const serverTerminator = getServerTerminator(httpServer);
  await server.onInit(httpServer);
  return new Promise((resolve2) => {
    httpServer.listen(
      {
        host,
        port
      },
      async () => {
        const routes = getRoutes(context);
        await context.hooks.onAfterStartProdServer.call({
          port,
          routes,
          environments: context.environments
        });
        const protocol = https ? "https" : "http";
        const urls = getAddressUrls({ protocol, port, host });
        const cliShortcutsEnabled = isCliShortcutsEnabled(config.dev);
        const closeServer = async () => {
          await Promise.all([server.close(), serverTerminator()]);
        };
        const printUrls = () => printServerURLs({
          urls,
          port,
          routes,
          protocol,
          printUrls: serverConfig.printUrls,
          trailingLineBreak: !cliShortcutsEnabled
        });
        const openPage = async () => {
          return open({
            https,
            port,
            routes,
            config,
            clearCache: true
          });
        };
        printUrls();
        if (cliShortcutsEnabled) {
          setupCliShortcuts({
            openPage,
            closeServer,
            printUrls,
            customShortcuts: typeof config.dev.cliShortcuts === "boolean" ? void 0 : config.dev.cliShortcuts.custom
          });
        }
        if (!getPortSilently && portTip) {
          logger.info(portTip);
        }
        resolve2({
          port,
          urls: urls.map((item) => item.url),
          server: {
            close: closeServer
          }
        });
      }
    );
  });
}
var RsbuildProdServer;
var init_prodServer = __esm({
  "src/server/prodServer.ts"() {
    "use strict";
    init_esm();
    init_path();
    init_logger();
    init_cliShortcuts();
    init_helper();
    init_httpServer();
    init_middlewares();
    init_open();
    RsbuildProdServer = class {
      constructor(options, middlewares) {
        __publicField(this, "app");
        __publicField(this, "options");
        __publicField(this, "middlewares");
        this.options = options;
        this.middlewares = middlewares;
      }
      // Complete the preparation of services
      async onInit(app) {
        this.app = app;
        await this.applyDefaultMiddlewares();
      }
      async applyDefaultMiddlewares() {
        const { headers, proxy, historyApiFallback, compress, base } = this.options.serverConfig;
        if (logger.level === "verbose") {
          this.middlewares.use(await getRequestLoggerMiddleware());
        }
        if (compress) {
          const { gzipMiddleware: gzipMiddleware2 } = await Promise.resolve().then(() => (init_gzipMiddleware(), gzipMiddleware_exports));
          this.middlewares.use(
            gzipMiddleware2({
              // simulates the common gzip compression rates
              level: 6
            })
          );
        }
        if (headers) {
          this.middlewares.use((_req, res, next) => {
            for (const [key, value] of Object.entries(headers)) {
              res.setHeader(key, value);
            }
            next();
          });
        }
        if (proxy) {
          const { createProxyMiddleware: createProxyMiddleware2 } = await Promise.resolve().then(() => (init_proxy(), proxy_exports));
          const { middlewares, upgrade } = await createProxyMiddleware2(proxy);
          for (const middleware of middlewares) {
            this.middlewares.use(middleware);
          }
          this.app.on("upgrade", upgrade);
        }
        if (base && base !== "/") {
          this.middlewares.use(getBaseMiddleware({ base }));
        }
        await this.applyStaticAssetMiddleware();
        if (historyApiFallback) {
          const { default: connectHistoryApiFallback } = await import("../compiled/connect-history-api-fallback/index.js");
          const historyApiFallbackMiddleware = connectHistoryApiFallback(
            historyApiFallback === true ? {} : historyApiFallback
          );
          this.middlewares.use(historyApiFallbackMiddleware);
          await this.applyStaticAssetMiddleware();
        }
        this.middlewares.use(faviconFallbackMiddleware);
      }
      async applyStaticAssetMiddleware() {
        const {
          output: { path: path22, assetPrefixes },
          serverConfig: { htmlFallback }
        } = this.options;
        const { default: sirv } = await import("../compiled/sirv/index.js");
        const assetMiddleware = sirv(path22, {
          etag: true,
          dev: true,
          ignores: ["favicon.ico"],
          single: htmlFallback === "index"
        });
        this.middlewares.use((req, res, next) => {
          const url2 = req.url;
          const assetPrefix = url2 && assetPrefixes.find((prefix) => url2.startsWith(prefix));
          if (assetPrefix && url2?.startsWith(assetPrefix)) {
            req.url = url2.slice(assetPrefix.length);
            assetMiddleware(req, res, (...args) => {
              req.url = url2;
              next(...args);
            });
          } else {
            assetMiddleware(req, res, next);
          }
        });
      }
      async close() {
      }
    };
  }
});

// src/createRsbuild.ts
var createRsbuild_exports = {};
__export(createRsbuild_exports, {
  createRsbuild: () => createRsbuild
});
import { existsSync } from "fs";
import { isPromise } from "util/types";
import color18 from "../compiled/picocolors/index.js";
async function applyDefaultPlugins(pluginManager, context) {
  const plugins = await Promise.all([
    Promise.resolve().then(() => (init_basic2(), basic_exports)).then(({ pluginBasic: pluginBasic2 }) => pluginBasic2()),
    Promise.resolve().then(() => (init_entry(), entry_exports)).then(({ pluginEntry: pluginEntry2 }) => pluginEntry2()),
    Promise.resolve().then(() => (init_cache(), cache_exports)).then(({ pluginCache: pluginCache2 }) => pluginCache2()),
    Promise.resolve().then(() => (init_target(), target_exports)).then(({ pluginTarget: pluginTarget2 }) => pluginTarget2()),
    Promise.resolve().then(() => (init_output(), output_exports)).then(({ pluginOutput: pluginOutput2 }) => pluginOutput2()),
    Promise.resolve().then(() => (init_resolve(), resolve_exports)).then(({ pluginResolve: pluginResolve2 }) => pluginResolve2()),
    Promise.resolve().then(() => (init_fileSize(), fileSize_exports)).then(({ pluginFileSize: pluginFileSize2 }) => pluginFileSize2()),
    // cleanOutput plugin should before the html plugin
    Promise.resolve().then(() => (init_cleanOutput(), cleanOutput_exports)).then(
      ({ pluginCleanOutput: pluginCleanOutput2 }) => pluginCleanOutput2()
    ),
    Promise.resolve().then(() => (init_asset(), asset_exports)).then(({ pluginAsset: pluginAsset2 }) => pluginAsset2()),
    Promise.resolve().then(() => (init_html(), html_exports)).then(
      ({ pluginHtml: pluginHtml2 }) => pluginHtml2((environment) => async (...args) => {
        const result = await context.hooks.modifyHTMLTags.callInEnvironment({
          environment,
          args
        });
        return result[0];
      })
    ),
    Promise.resolve().then(() => (init_appIcon(), appIcon_exports)).then(({ pluginAppIcon: pluginAppIcon2 }) => pluginAppIcon2()),
    Promise.resolve().then(() => (init_wasm(), wasm_exports)).then(({ pluginWasm: pluginWasm2 }) => pluginWasm2()),
    Promise.resolve().then(() => (init_moment(), moment_exports)).then(({ pluginMoment: pluginMoment2 }) => pluginMoment2()),
    Promise.resolve().then(() => (init_nodeAddons(), nodeAddons_exports)).then(
      ({ pluginNodeAddons: pluginNodeAddons2 }) => pluginNodeAddons2()
    ),
    Promise.resolve().then(() => (init_define(), define_exports)).then(({ pluginDefine: pluginDefine2 }) => pluginDefine2()),
    Promise.resolve().then(() => (init_css(), css_exports)).then(({ pluginCss: pluginCss2 }) => pluginCss2()),
    Promise.resolve().then(() => (init_minimize(), minimize_exports)).then(({ pluginMinimize: pluginMinimize2 }) => pluginMinimize2()),
    Promise.resolve().then(() => (init_progress(), progress_exports)).then(({ pluginProgress: pluginProgress2 }) => pluginProgress2()),
    Promise.resolve().then(() => (init_swc(), swc_exports)).then(({ pluginSwc: pluginSwc2 }) => pluginSwc2()),
    Promise.resolve().then(() => (init_externals(), externals_exports)).then(
      ({ pluginExternals: pluginExternals2 }) => pluginExternals2()
    ),
    Promise.resolve().then(() => (init_splitChunks(), splitChunks_exports)).then(
      ({ pluginSplitChunks: pluginSplitChunks2 }) => pluginSplitChunks2()
    ),
    Promise.resolve().then(() => (init_inlineChunk(), inlineChunk_exports)).then(
      ({ pluginInlineChunk: pluginInlineChunk2 }) => pluginInlineChunk2()
    ),
    Promise.resolve().then(() => (init_rsdoctor(), rsdoctor_exports)).then(({ pluginRsdoctor: pluginRsdoctor2 }) => pluginRsdoctor2()),
    Promise.resolve().then(() => (init_resourceHints(), resourceHints_exports)).then(
      ({ pluginResourceHints: pluginResourceHints2 }) => pluginResourceHints2()
    ),
    Promise.resolve().then(() => (init_performance(), performance_exports)).then(
      ({ pluginPerformance: pluginPerformance2 }) => pluginPerformance2()
    ),
    Promise.resolve().then(() => (init_bundleAnalyzer(), bundleAnalyzer_exports)).then(
      ({ pluginBundleAnalyzer: pluginBundleAnalyzer2 }) => pluginBundleAnalyzer2()
    ),
    Promise.resolve().then(() => (init_server(), server_exports)).then(({ pluginServer: pluginServer2 }) => pluginServer2()),
    Promise.resolve().then(() => (init_manifest(), manifest_exports)).then(({ pluginManifest: pluginManifest2 }) => pluginManifest2()),
    Promise.resolve().then(() => (init_moduleFederation(), moduleFederation_exports)).then(
      ({ pluginModuleFederation: pluginModuleFederation2 }) => pluginModuleFederation2()
    ),
    Promise.resolve().then(() => (init_rspackProfile(), rspackProfile_exports)).then(
      ({ pluginRspackProfile: pluginRspackProfile2 }) => pluginRspackProfile2()
    ),
    Promise.resolve().then(() => (init_lazyCompilation(), lazyCompilation_exports)).then(
      ({ pluginLazyCompilation: pluginLazyCompilation2 }) => pluginLazyCompilation2()
    ),
    Promise.resolve().then(() => (init_sri(), sri_exports)).then(({ pluginSri: pluginSri2 }) => pluginSri2()),
    Promise.resolve().then(() => (init_nonce(), nonce_exports)).then(({ pluginNonce: pluginNonce2 }) => pluginNonce2())
  ]);
  pluginManager.addPlugins(plugins);
}
async function createRsbuild(options = {}) {
  const { rsbuildConfig = {} } = options;
  const rsbuildOptions = {
    cwd: process.cwd(),
    rsbuildConfig,
    ...options
  };
  const pluginManager = createPluginManager();
  const context = await createContext(
    rsbuildOptions,
    rsbuildOptions.rsbuildConfig,
    rsbuildConfig.provider ? "webpack" : "rspack"
  );
  const getPluginAPI = initPluginAPI({ context, pluginManager });
  context.getPluginAPI = getPluginAPI;
  const globalPluginAPI = getPluginAPI();
  logger.debug("add default plugins");
  await applyDefaultPlugins(pluginManager, context);
  logger.debug("add default plugins done");
  const provider = rsbuildConfig.provider || await getRspackProvider();
  const providerInstance = await provider({
    context,
    pluginManager,
    rsbuildOptions,
    setCssExtractPlugin
  });
  const preview = async (options2 = {}) => {
    if (!getNodeEnv()) {
      setNodeEnv("production");
    }
    const config = await initRsbuildConfig({ context, pluginManager });
    const { distPath } = context;
    const { checkDistDir = true } = options2;
    if (checkDistDir) {
      if (!existsSync(distPath)) {
        throw new Error(
          `The output directory ${color18.yellow(
            distPath
          )} does not exist, please build the project before previewing.`
        );
      }
      if (isEmptyDir(distPath)) {
        throw new Error(
          `The output directory ${color18.yellow(
            distPath
          )} is empty, please build the project before previewing.`
        );
      }
    }
    const { startProdServer: startProdServer2 } = await Promise.resolve().then(() => (init_prodServer(), prodServer_exports));
    return startProdServer2(context, config, options2);
  };
  const build2 = (...args) => {
    if (!getNodeEnv()) {
      setNodeEnv("production");
    }
    return providerInstance.build(...args);
  };
  const startDevServer = (...args) => {
    if (!getNodeEnv()) {
      setNodeEnv("development");
    }
    return providerInstance.startDevServer(...args);
  };
  const createDevServer2 = (...args) => {
    if (!getNodeEnv()) {
      setNodeEnv("development");
    }
    return providerInstance.createDevServer(...args);
  };
  const rsbuild = {
    build: build2,
    preview,
    startDevServer,
    createDevServer: createDevServer2,
    ...pick(pluginManager, [
      "addPlugins",
      "getPlugins",
      "removePlugins",
      "isPluginExists"
    ]),
    ...pick(globalPluginAPI, [
      "context",
      "onBeforeBuild",
      "onBeforeCreateCompiler",
      "onBeforeStartDevServer",
      "onBeforeStartProdServer",
      "onAfterBuild",
      "onAfterCreateCompiler",
      "onAfterStartDevServer",
      "onAfterStartProdServer",
      "onCloseDevServer",
      "onDevCompileDone",
      "onExit",
      "getRsbuildConfig",
      "getNormalizedConfig"
    ]),
    ...pick(providerInstance, [
      "initConfigs",
      "inspectConfig",
      "createCompiler"
    ])
  };
  const getFlattenedPlugins = async (pluginOptions) => {
    let plugins = pluginOptions;
    do {
      plugins = (await Promise.all(plugins)).flat(
        Number.POSITIVE_INFINITY
      );
    } while (plugins.some((v) => isPromise(v)));
    return plugins;
  };
  if (rsbuildConfig.plugins) {
    const plugins = await getFlattenedPlugins(rsbuildConfig.plugins);
    rsbuild.addPlugins(plugins);
  }
  if (rsbuildConfig.environments) {
    await Promise.all(
      Object.entries(rsbuildConfig.environments).map(async ([name, config]) => {
        const isEnvironmentEnabled = !rsbuildOptions.environment || rsbuildOptions.environment.includes(name);
        if (config.plugins && isEnvironmentEnabled) {
          const plugins = await getFlattenedPlugins(config.plugins);
          rsbuild.addPlugins(plugins, {
            environment: name
          });
        }
      })
    );
  }
  return rsbuild;
}
var getRspackProvider;
var init_createRsbuild = __esm({
  "src/createRsbuild.ts"() {
    "use strict";
    init_esm();
    init_createContext();
    init_helpers();
    init_initPlugins();
    init_internal();
    init_logger();
    init_pluginHelper();
    init_pluginManager();
    getRspackProvider = async () => {
      const { rspackProvider: rspackProvider2 } = await Promise.resolve().then(() => (init_provider(), provider_exports));
      return rspackProvider2;
    };
  }
});

// src/cli/init.ts
import path21 from "path";
async function init({
  cliOptions,
  isRestart
}) {
  if (cliOptions) {
    commonOpts = cliOptions;
  }
  try {
    const cwd = process.cwd();
    const root = commonOpts.root ? getAbsolutePath(cwd, commonOpts.root) : cwd;
    const envs = loadEnv({
      cwd: getEnvDir(root, commonOpts.envDir),
      mode: commonOpts.envMode
    });
    onBeforeRestartServer(envs.cleanup);
    const { content: config, filePath: configFilePath } = await loadConfig({
      cwd: root,
      path: commonOpts.config,
      envMode: commonOpts.envMode
    });
    const command = process.argv[2];
    if (command === "dev") {
      const files = [...envs.filePaths];
      if (configFilePath) {
        files.push(configFilePath);
      }
      if (config.dev?.watchFiles) {
        for (const watchFilesConfig of castArray(config.dev.watchFiles)) {
          if (watchFilesConfig.type === "reload-page") {
            continue;
          }
          const paths = castArray(watchFilesConfig.paths);
          if (watchFilesConfig.options) {
            watchFilesForRestart(paths, watchFilesConfig.options);
          } else {
            files.push(...paths);
          }
        }
      }
      watchFilesForRestart(files);
    }
    const { createRsbuild: createRsbuild2 } = await Promise.resolve().then(() => (init_createRsbuild(), createRsbuild_exports));
    config.source ||= {};
    config.source.define = {
      ...envs.publicVars,
      ...config.source.define
    };
    if (commonOpts.root) {
      config.root = root;
    }
    if (commonOpts.mode) {
      config.mode = commonOpts.mode;
    }
    if (commonOpts.open && !config.server?.open) {
      config.server ||= {};
      config.server.open = commonOpts.open;
    }
    if (commonOpts.host) {
      config.server ||= {};
      config.server.host = commonOpts.host;
    }
    if (commonOpts.port) {
      config.server ||= {};
      config.server.port = commonOpts.port;
    }
    if (config.dev?.cliShortcuts === void 0) {
      config.dev ||= {};
      config.dev.cliShortcuts = true;
    }
    return createRsbuild2({
      cwd: root,
      rsbuildConfig: config,
      environment: commonOpts.environment
    });
  } catch (err) {
    if (isRestart) {
      logger.error(err);
    } else {
      throw err;
    }
  }
}
var commonOpts, getEnvDir;
var init_init = __esm({
  "src/cli/init.ts"() {
    "use strict";
    init_esm();
    init_config();
    init_helpers();
    init_loadEnv();
    init_logger();
    init_restart();
    commonOpts = {};
    getEnvDir = (cwd, envDir) => {
      if (envDir) {
        return path21.isAbsolute(envDir) ? envDir : path21.resolve(cwd, envDir);
      }
      return cwd;
    };
  }
});

// src/cli/commands.ts
function runCli() {
  program.name("rsbuild").usage("<command> [options]").version("1.0.13");
  const devCommand = program.command("dev");
  const buildCommand = program.command("build");
  const previewCommand = program.command("preview");
  const inspectCommand = program.command("inspect");
  [devCommand, buildCommand, previewCommand, inspectCommand].forEach(
    applyCommonOptions
  );
  [devCommand, previewCommand].forEach(applyServerOptions);
  devCommand.description("starting the dev server").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.startDevServer();
    } catch (err) {
      logger.error("Failed to start dev server.");
      logger.error(err);
      process.exit(1);
    }
  });
  buildCommand.option("-w --watch", "turn on watch mode, watch for changes and rebuild").description("build the app for production").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.build({
        watch: options.watch
      });
    } catch (err) {
      logger.error("Failed to build.");
      logger.error(err);
      process.exit(1);
    }
  });
  previewCommand.description("preview the production build locally").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.preview();
    } catch (err) {
      logger.error("Failed to start preview server.");
      logger.error(err);
      process.exit(1);
    }
  });
  inspectCommand.description("inspect the Rspack and Rsbuild configs").option("--output <output>", "specify inspect content output path").option("--verbose", "show full function definitions in output").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.inspectConfig({
        verbose: options.verbose,
        outputPath: options.output,
        writeToDisk: true
      });
    } catch (err) {
      logger.error("Failed to inspect config.");
      logger.error(err);
      process.exit(1);
    }
  });
  program.parse();
}
var applyCommonOptions, applyServerOptions;
var init_commands = __esm({
  "src/cli/commands.ts"() {
    "use strict";
    init_esm();
    init_esm2();
    init_logger();
    init_init();
    applyCommonOptions = (command) => {
      command.option(
        "-c --config <config>",
        "specify the configuration file, can be a relative or absolute path"
      ).option(
        "-r --root <root>",
        "specify the project root directory, can be an absolute path or a path relative to cwd"
      ).option(
        "-m --mode <mode>",
        "specify the build mode, can be `development`, `production` or `none`"
      ).option(
        "--env-mode <mode>",
        "specify the env mode to load the `.env.[mode]` file"
      ).option(
        "--environment <name>",
        "specify the name of environment to build",
        (str, prev) => prev ? prev.concat(str.split(",")) : str.split(",")
      ).option("--env-dir <dir>", "specify the directory to load `.env` files");
    };
    applyServerOptions = (command) => {
      command.option("-o --open [url]", "open the page in browser on startup").option("--port <port>", "specify a port number for server to listen").option("--host <host>", "specify the host that the server listens to");
    };
  }
});

// src/cli/prepare.ts
import nodeModule from "module";
function initNodeEnv() {
  if (!process.env.NODE_ENV) {
    const command = process.argv[2];
    process.env.NODE_ENV = ["build", "preview"].includes(command) ? "production" : "development";
  }
}
function prepareCli() {
  initNodeEnv();
  const { enableCompileCache } = nodeModule;
  if (enableCompileCache && !process.env.NODE_DISABLE_COMPILE_CACHE) {
    try {
      enableCompileCache();
    } catch {
    }
  }
  const { npm_execpath } = process.env;
  if (!npm_execpath || npm_execpath.includes("npx-cli.js") || npm_execpath.includes(".bun")) {
    console.log();
  }
  logger.greet(`  ${`Rsbuild v${"1.0.13"}`}
`);
}
var init_prepare = __esm({
  "src/cli/prepare.ts"() {
    "use strict";
    init_esm();
    init_logger();
  }
});

// src/internal.ts
var internal_exports = {};
__export(internal_exports, {
  applySwcDecoratorConfig: () => applySwcDecoratorConfig,
  chainToConfig: () => chainToConfig,
  createDevServer: () => createDevServer,
  createPluginManager: () => createPluginManager,
  formatStats: () => formatStats,
  getChainUtils: () => getChainUtils,
  getConfigUtils: () => getConfigUtils,
  getHTMLPlugin: () => getHTMLPlugin,
  getRsbuildInspectConfig: () => getRsbuildInspectConfig,
  getStatsOptions: () => getStatsOptions,
  getSwcMinimizerOptions: () => getSwcMinimizerOptions,
  initHooks: () => initHooks,
  initPlugins: () => initPlugins,
  initRsbuildConfig: () => initRsbuildConfig,
  modifyBundlerChain: () => modifyBundlerChain,
  onCompileDone: () => onCompileDone,
  outputInspectConfigFiles: () => outputInspectConfigFiles,
  prepareCli: () => prepareCli,
  prettyTime: () => prettyTime,
  registerBuildHook: () => registerBuildHook,
  registerDevHook: () => registerDevHook,
  runCli: () => runCli,
  setHTMLPlugin: () => setHTMLPlugin,
  stringifyConfig: () => stringifyConfig
});
var init_internal = __esm({
  "src/internal.ts"() {
    "use strict";
    init_esm();
    init_commands();
    init_prepare();
    init_pluginManager();
    init_hooks();
    init_initConfigs();
    init_config();
    init_pluginHelper();
    init_helpers();
    init_hooks();
    init_rspackConfig();
    init_configChain();
    init_swc();
    init_minimize();
    init_devServer();
  }
});

// src/index.ts
init_esm();
init_internal();
init_loadEnv();
init_createRsbuild();
init_config();
init_logger();
init_mergeConfig();
init_helpers();
init_constants();
import { rspack as rspack10 } from "@rspack/core";
var version = "1.0.13";
export {
  PLUGIN_CSS_NAME,
  PLUGIN_SWC_NAME,
  internal_exports as __internalHelper,
  createRsbuild,
  defineConfig,
  ensureAssetPrefix,
  loadConfig,
  loadEnv,
  logger,
  mergeRsbuildConfig,
  rspack10 as rspack,
  version
};
