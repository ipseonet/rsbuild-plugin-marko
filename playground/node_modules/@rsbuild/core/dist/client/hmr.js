// src/client/format.ts
function resolveFileName(stats) {
  if (stats.moduleIdentifier) {
    const regex = /(?:\!|^)([^!]+)$/;
    const matched = stats.moduleIdentifier.match(regex);
    if (matched) {
      const fileName = matched.pop();
      if (fileName) {
        return `File: ${fileName}:1:1
`;
      }
    }
  }
  const file = stats.file || stats.moduleName;
  return file ? `File: ${file}
` : "";
}
function hintUnknownFiles(message) {
  const hint = "You may need an appropriate loader to handle this file type.";
  if (message.indexOf(hint) === -1) {
    return message;
  }
  if (/File: .+\.s(c|a)ss/.test(message)) {
    return message.replace(hint, `To enable support for Sass, use "@rsbuild/plugin-sass".`);
  }
  if (/File: .+\.less/.test(message)) {
    return message.replace(hint, `To enable support for Less, use "@rsbuild/plugin-less".`);
  }
  if (/File: .+\.styl(us)?/.test(message)) {
    return message.replace(hint, `To enable support for Stylus, use "@rsbuild/plugin-stylus".`);
  }
  return message;
}
function formatMessage(stats, verbose) {
  let lines = [];
  let message;
  if (typeof stats === "object") {
    const fileName = resolveFileName(stats);
    const mainMessage = stats.message;
    const details = verbose && stats.details ? `
Details: ${stats.details}
` : "";
    const stack = verbose && stats.stack ? `
${stats.stack}` : "";
    message = `${fileName}${mainMessage}${details}${stack}`;
  } else {
    message = stats;
  }
  message = hintUnknownFiles(message);
  lines = message.split("\n");
  lines = lines.filter((line, index, arr) => index === 0 || line.trim() !== "" || line.trim() !== arr[index - 1].trim());
  message = lines.join("\n");
  const innerError = "-- inner error --";
  if (!verbose && message.includes(innerError)) {
    message = message.split(innerError)[0];
  }
  return message.trim();
}
function formatStatsMessages(stats, verbose) {
  var _stats_errors, _stats_warnings;
  const formattedErrors = ((_stats_errors = stats.errors) === null || _stats_errors === void 0 ? void 0 : _stats_errors.map((error) => formatMessage(error, verbose))) || [];
  const formattedWarnings = ((_stats_warnings = stats.warnings) === null || _stats_warnings === void 0 ? void 0 : _stats_warnings.map((warning) => formatMessage(warning, verbose))) || [];
  return {
    errors: formattedErrors,
    warnings: formattedWarnings
  };
}

// src/client/hmr.ts
var compilationId = RSBUILD_COMPILATION_NAME;
var config = RSBUILD_CLIENT_CONFIG;
function formatURL({ port, protocol, hostname, pathname }) {
  if (typeof URL !== "undefined") {
    const url = new URL("http://localhost");
    url.port = String(port);
    url.hostname = hostname;
    url.protocol = protocol;
    url.pathname = pathname;
    url.searchParams.append("compilationId", compilationId);
    return url.toString();
  }
  const colon = protocol.indexOf(":") === -1 ? ":" : "";
  return `${protocol}${colon}//${hostname}:${port}${pathname}`;
}
var isFirstCompilation = true;
var lastCompilationHash = null;
var hasCompileErrors = false;
function clearOutdatedErrors() {
  if (console.clear && hasCompileErrors) {
    console.clear();
  }
}
var createOverlay;
var clearOverlay;
var registerOverlay = (createFn, clearFn) => {
  createOverlay = createFn;
  clearOverlay = clearFn;
};
function handleSuccess() {
  clearOutdatedErrors();
  const isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;
  if (isHotUpdate) {
    tryApplyUpdates();
  }
}
function handleWarnings(warnings) {
  clearOutdatedErrors();
  const isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;
  const formatted = formatStatsMessages({
    warnings,
    errors: []
  });
  for (let i = 0; i < formatted.warnings.length; i++) {
    if (i === 5) {
      console.warn("There were more warnings in other files, you can find a complete log in the terminal.");
      break;
    }
    console.warn(formatted.warnings[i]);
  }
  if (isHotUpdate) {
    tryApplyUpdates();
  }
}
function handleErrors(errors) {
  clearOutdatedErrors();
  isFirstCompilation = false;
  hasCompileErrors = true;
  const formatted = formatStatsMessages({
    errors,
    warnings: []
  });
  for (const error of formatted.errors) {
    console.error(error);
  }
  if (createOverlay) {
    createOverlay(formatted.errors);
  }
}
var isUpdateAvailable = () => lastCompilationHash !== __webpack_hash__;
function tryApplyUpdates() {
  if (!isUpdateAvailable()) {
    return;
  }
  if (!import.meta.webpackHot) {
    reloadPage();
    return;
  }
  if (import.meta.webpackHot.status() !== "idle") {
    return;
  }
  const handleApplyUpdates = (err, updatedModules) => {
    const forcedReload = err || !updatedModules;
    if (forcedReload) {
      if (err) {
        console.error("[HMR] Forced reload caused by: ", err);
      }
      reloadPage();
      return;
    }
    if (isUpdateAvailable()) {
      tryApplyUpdates();
    }
  };
  import.meta.webpackHot.check(true).then((updatedModules) => handleApplyUpdates(null, updatedModules), (err) => handleApplyUpdates(err, null));
}
var connection = null;
var reconnectCount = 0;
function onOpen() {
  console.info("[HMR] connected.");
}
function onMessage(e) {
  const message = JSON.parse(e.data);
  if (message.compilationId && message.compilationId !== compilationId) {
    return;
  }
  switch (message.type) {
    case "hash":
      lastCompilationHash = message.data;
      if (clearOverlay && isUpdateAvailable()) {
        clearOverlay();
      }
      break;
    case "still-ok":
    case "ok":
      handleSuccess();
      break;
    case "static-changed":
    case "content-changed":
      reloadPage();
      break;
    case "warnings":
      handleWarnings(message.data);
      break;
    case "errors":
      handleErrors(message.data);
      break;
  }
}
function onClose() {
  if (reconnectCount >= config.reconnect) {
    if (config.reconnect > 0) {
      console.info("[HMR] Connection failure after maximum reconnect limit exceeded.");
    }
    return;
  }
  console.info("[HMR] disconnected. Attempting to reconnect.");
  removeListeners();
  connection = null;
  reconnectCount++;
  setTimeout(connect, 1e3 * 1.5 ** reconnectCount);
}
function connect() {
  const { location } = self;
  const { host, port, path, protocol } = config;
  const socketUrl = formatURL({
    protocol: protocol || (location.protocol === "https:" ? "wss" : "ws"),
    hostname: host || location.hostname,
    port: port || location.port,
    pathname: path || "/rsbuild-hmr"
  });
  connection = new WebSocket(socketUrl);
  connection.addEventListener("open", onOpen);
  connection.addEventListener("close", onClose);
  connection.addEventListener("message", onMessage);
}
function removeListeners() {
  if (connection) {
    connection.removeEventListener("open", onOpen);
    connection.removeEventListener("close", onClose);
    connection.removeEventListener("message", onMessage);
  }
}
function reloadPage() {
  if (RSBUILD_DEV_LIVE_RELOAD) {
    window.location.reload();
  }
}
connect();
export {
  registerOverlay
};
