(() => {
  "use strict";
  var __webpack_modules__ = {
    261: (module) => {
      /*!
       * ee-first
       * Copyright(c) 2014 Jonathan Ong
       * MIT Licensed
       */
      module.exports = first;
      function first(stuff, done) {
        if (!Array.isArray(stuff))
          throw new TypeError("arg must be an array of [ee, events...] arrays");
        var cleanups = [];
        for (var i = 0; i < stuff.length; i++) {
          var arr = stuff[i];
          if (!Array.isArray(arr) || arr.length < 2)
            throw new TypeError("each array member must be [ee, events...]");
          var ee = arr[0];
          for (var j = 1; j < arr.length; j++) {
            var event = arr[j];
            var fn = listener(event, callback);
            ee.on(event, fn);
            cleanups.push({ ee, event, fn });
          }
        }
        function callback() {
          cleanup();
          done.apply(null, arguments);
        }
        function cleanup() {
          var x;
          for (var i = 0; i < cleanups.length; i++) {
            x = cleanups[i];
            x.ee.removeListener(x.event, x.fn);
          }
        }
        function thunk(fn) {
          done = fn;
        }
        thunk.cancel = cleanup;
        return thunk;
      }
      function listener(event, done) {
        return function onevent(arg1) {
          var args = new Array(arguments.length);
          var ee = this;
          var err = event === "error" ? arg1 : null;
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          done(err, ee, event, args);
        };
      }
    },
    878: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Dirent = void 0;
      const constants_1 = __nccwpck_require__(55);
      const encoding_1 = __nccwpck_require__(900);
      const {
        S_IFMT,
        S_IFDIR,
        S_IFREG,
        S_IFBLK,
        S_IFCHR,
        S_IFLNK,
        S_IFIFO,
        S_IFSOCK,
      } = constants_1.constants;
      class Dirent {
        constructor() {
          this.name = "";
          this.path = "";
          this.mode = 0;
        }
        static build(link, encoding) {
          const dirent = new Dirent();
          const { mode } = link.getNode();
          dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
          dirent.mode = mode;
          dirent.path = link.getParentPath();
          return dirent;
        }
        _checkModeProperty(property) {
          return (this.mode & S_IFMT) === property;
        }
        isDirectory() {
          return this._checkModeProperty(S_IFDIR);
        }
        isFile() {
          return this._checkModeProperty(S_IFREG);
        }
        isBlockDevice() {
          return this._checkModeProperty(S_IFBLK);
        }
        isCharacterDevice() {
          return this._checkModeProperty(S_IFCHR);
        }
        isSymbolicLink() {
          return this._checkModeProperty(S_IFLNK);
        }
        isFIFO() {
          return this._checkModeProperty(S_IFIFO);
        }
        isSocket() {
          return this._checkModeProperty(S_IFSOCK);
        }
      }
      exports.Dirent = Dirent;
      exports["default"] = Dirent;
    },
    441: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Stats = void 0;
      const constants_1 = __nccwpck_require__(55);
      const {
        S_IFMT,
        S_IFDIR,
        S_IFREG,
        S_IFBLK,
        S_IFCHR,
        S_IFLNK,
        S_IFIFO,
        S_IFSOCK,
      } = constants_1.constants;
      class Stats {
        static build(node, bigint = false) {
          const stats = new Stats();
          const { uid, gid, atime, mtime, ctime } = node;
          const getStatNumber = !bigint
            ? (number) => number
            : (number) => BigInt(number);
          stats.uid = getStatNumber(uid);
          stats.gid = getStatNumber(gid);
          stats.rdev = getStatNumber(0);
          stats.blksize = getStatNumber(4096);
          stats.ino = getStatNumber(node.ino);
          stats.size = getStatNumber(node.getSize());
          stats.blocks = getStatNumber(1);
          stats.atime = atime;
          stats.mtime = mtime;
          stats.ctime = ctime;
          stats.birthtime = ctime;
          stats.atimeMs = getStatNumber(atime.getTime());
          stats.mtimeMs = getStatNumber(mtime.getTime());
          const ctimeMs = getStatNumber(ctime.getTime());
          stats.ctimeMs = ctimeMs;
          stats.birthtimeMs = ctimeMs;
          if (bigint) {
            stats.atimeNs = BigInt(atime.getTime()) * BigInt(1e6);
            stats.mtimeNs = BigInt(mtime.getTime()) * BigInt(1e6);
            const ctimeNs = BigInt(ctime.getTime()) * BigInt(1e6);
            stats.ctimeNs = ctimeNs;
            stats.birthtimeNs = ctimeNs;
          }
          stats.dev = getStatNumber(0);
          stats.mode = getStatNumber(node.mode);
          stats.nlink = getStatNumber(node.nlink);
          return stats;
        }
        _checkModeProperty(property) {
          return (Number(this.mode) & S_IFMT) === property;
        }
        isDirectory() {
          return this._checkModeProperty(S_IFDIR);
        }
        isFile() {
          return this._checkModeProperty(S_IFREG);
        }
        isBlockDevice() {
          return this._checkModeProperty(S_IFBLK);
        }
        isCharacterDevice() {
          return this._checkModeProperty(S_IFCHR);
        }
        isSymbolicLink() {
          return this._checkModeProperty(S_IFLNK);
        }
        isFIFO() {
          return this._checkModeProperty(S_IFIFO);
        }
        isSocket() {
          return this._checkModeProperty(S_IFSOCK);
        }
      }
      exports.Stats = Stats;
      exports["default"] = Stats;
    },
    55: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.constants = void 0;
      exports.constants = {
        O_RDONLY: 0,
        O_WRONLY: 1,
        O_RDWR: 2,
        S_IFMT: 61440,
        S_IFREG: 32768,
        S_IFDIR: 16384,
        S_IFCHR: 8192,
        S_IFBLK: 24576,
        S_IFIFO: 4096,
        S_IFLNK: 40960,
        S_IFSOCK: 49152,
        O_CREAT: 64,
        O_EXCL: 128,
        O_NOCTTY: 256,
        O_TRUNC: 512,
        O_APPEND: 1024,
        O_DIRECTORY: 65536,
        O_NOATIME: 262144,
        O_NOFOLLOW: 131072,
        O_SYNC: 1052672,
        O_SYMLINK: 2097152,
        O_DIRECT: 16384,
        O_NONBLOCK: 2048,
        S_IRWXU: 448,
        S_IRUSR: 256,
        S_IWUSR: 128,
        S_IXUSR: 64,
        S_IRWXG: 56,
        S_IRGRP: 32,
        S_IWGRP: 16,
        S_IXGRP: 8,
        S_IRWXO: 7,
        S_IROTH: 4,
        S_IWOTH: 2,
        S_IXOTH: 1,
        F_OK: 0,
        R_OK: 4,
        W_OK: 2,
        X_OK: 1,
        UV_FS_SYMLINK_DIR: 1,
        UV_FS_SYMLINK_JUNCTION: 2,
        UV_FS_COPYFILE_EXCL: 1,
        UV_FS_COPYFILE_FICLONE: 2,
        UV_FS_COPYFILE_FICLONE_FORCE: 4,
        COPYFILE_EXCL: 1,
        COPYFILE_FICLONE: 2,
        COPYFILE_FICLONE_FORCE: 4,
      };
    },
    900: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.strToEncoding =
        exports.assertEncoding =
        exports.ENCODING_UTF8 =
          void 0;
      const buffer_1 = __nccwpck_require__(730);
      const errors = __nccwpck_require__(40);
      exports.ENCODING_UTF8 = "utf8";
      function assertEncoding(encoding) {
        if (encoding && !buffer_1.Buffer.isEncoding(encoding))
          throw new errors.TypeError(
            "ERR_INVALID_OPT_VALUE_ENCODING",
            encoding,
          );
      }
      exports.assertEncoding = assertEncoding;
      function strToEncoding(str, encoding) {
        if (!encoding || encoding === exports.ENCODING_UTF8) return str;
        if (encoding === "buffer") return new buffer_1.Buffer(str);
        return new buffer_1.Buffer(str).toString(encoding);
      }
      exports.strToEncoding = strToEncoding;
    },
    664: (module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.memfs =
        exports.fs =
        exports.createFsFromVolume =
        exports.vol =
        exports.Volume =
          void 0;
      const Stats_1 = __nccwpck_require__(441);
      const Dirent_1 = __nccwpck_require__(878);
      const volume_1 = __nccwpck_require__(380);
      const constants_1 = __nccwpck_require__(55);
      const fsSynchronousApiList_1 = __nccwpck_require__(601);
      const fsCallbackApiList_1 = __nccwpck_require__(314);
      const { F_OK, R_OK, W_OK, X_OK } = constants_1.constants;
      exports.Volume = volume_1.Volume;
      exports.vol = new volume_1.Volume();
      function createFsFromVolume(vol) {
        const fs = {
          F_OK,
          R_OK,
          W_OK,
          X_OK,
          constants: constants_1.constants,
          Stats: Stats_1.default,
          Dirent: Dirent_1.default,
        };
        for (const method of fsSynchronousApiList_1.fsSynchronousApiList)
          if (typeof vol[method] === "function")
            fs[method] = vol[method].bind(vol);
        for (const method of fsCallbackApiList_1.fsCallbackApiList)
          if (typeof vol[method] === "function")
            fs[method] = vol[method].bind(vol);
        fs.StatWatcher = vol.StatWatcher;
        fs.FSWatcher = vol.FSWatcher;
        fs.WriteStream = vol.WriteStream;
        fs.ReadStream = vol.ReadStream;
        fs.promises = vol.promises;
        fs._toUnixTimestamp = volume_1.toUnixTimestamp;
        fs.__vol = vol;
        return fs;
      }
      exports.createFsFromVolume = createFsFromVolume;
      exports.fs = createFsFromVolume(exports.vol);
      const memfs = (json = {}, cwd = "/") => {
        const vol = exports.Volume.fromNestedJSON(json, cwd);
        const fs = createFsFromVolume(vol);
        return { fs, vol };
      };
      exports.memfs = memfs;
      module.exports = Object.assign(
        Object.assign({}, module.exports),
        exports.fs,
      );
      module.exports.semantic = true;
    },
    730: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferFrom = exports.bufferAllocUnsafe = exports.Buffer = void 0;
      const buffer_1 = __nccwpck_require__(300);
      Object.defineProperty(exports, "Buffer", {
        enumerable: true,
        get: function () {
          return buffer_1.Buffer;
        },
      });
      function bufferV0P12Ponyfill(arg0, ...args) {
        return new buffer_1.Buffer(arg0, ...args);
      }
      const bufferAllocUnsafe =
        buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
      exports.bufferAllocUnsafe = bufferAllocUnsafe;
      const bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
      exports.bufferFrom = bufferFrom;
    },
    40: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.E =
        exports.AssertionError =
        exports.message =
        exports.RangeError =
        exports.TypeError =
        exports.Error =
          void 0;
      const assert = __nccwpck_require__(491);
      const util = __nccwpck_require__(837);
      const kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
      const messages = {};
      function makeNodeError(Base) {
        return class NodeError extends Base {
          constructor(key, ...args) {
            super(message(key, args));
            this.code = key;
            this[kCode] = key;
            this.name = `${super.name} [${this[kCode]}]`;
          }
        };
      }
      const g = typeof globalThis !== "undefined" ? globalThis : global;
      class AssertionError extends g.Error {
        constructor(options) {
          if (typeof options !== "object" || options === null) {
            throw new exports.TypeError(
              "ERR_INVALID_ARG_TYPE",
              "options",
              "object",
            );
          }
          if (options.message) {
            super(options.message);
          } else {
            super(
              `${util.inspect(options.actual).slice(0, 128)} ` +
                `${options.operator} ${util.inspect(options.expected).slice(0, 128)}`,
            );
          }
          this.generatedMessage = !options.message;
          this.name = "AssertionError [ERR_ASSERTION]";
          this.code = "ERR_ASSERTION";
          this.actual = options.actual;
          this.expected = options.expected;
          this.operator = options.operator;
          exports.Error.captureStackTrace(this, options.stackStartFunction);
        }
      }
      exports.AssertionError = AssertionError;
      function message(key, args) {
        assert.strictEqual(typeof key, "string");
        const msg = messages[key];
        assert(msg, `An invalid error message key was used: ${key}.`);
        let fmt;
        if (typeof msg === "function") {
          fmt = msg;
        } else {
          fmt = util.format;
          if (args === undefined || args.length === 0) return msg;
          args.unshift(msg);
        }
        return String(fmt.apply(null, args));
      }
      exports.message = message;
      function E(sym, val) {
        messages[sym] = typeof val === "function" ? val : String(val);
      }
      exports.E = E;
      exports.Error = makeNodeError(g.Error);
      exports.TypeError = makeNodeError(g.TypeError);
      exports.RangeError = makeNodeError(g.RangeError);
      E("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
      E("ERR_ASSERTION", "%s");
      E("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
      E("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
      E(
        "ERR_CONSOLE_WRITABLE_STREAM",
        "Console expects a writable stream instance for %s",
      );
      E("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
      E(
        "ERR_DNS_SET_SERVERS_FAILED",
        (err, servers) => `c-ares failed to set servers: "${err}" [${servers}]`,
      );
      E("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
      E(
        "ERR_ENCODING_NOT_SUPPORTED",
        (enc) => `The "${enc}" encoding is not supported`,
      );
      E(
        "ERR_ENCODING_INVALID_ENCODED_DATA",
        (enc) => `The encoded data was not valid for encoding ${enc}`,
      );
      E(
        "ERR_HTTP_HEADERS_SENT",
        "Cannot render headers after they are sent to the client",
      );
      E("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
      E(
        "ERR_HTTP_TRAILER_INVALID",
        "Trailers are invalid with this transfer encoding",
      );
      E("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
      E("ERR_INVALID_ARG_TYPE", invalidArgType);
      E("ERR_INVALID_ARRAY_LENGTH", (name, len, actual) => {
        assert.strictEqual(typeof actual, "number");
        return `The array "${name}" (length ${actual}) must be of length ${len}.`;
      });
      E("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
      E("ERR_INVALID_CALLBACK", "Callback must be a function");
      E("ERR_INVALID_CHAR", "Invalid character in %s");
      E(
        "ERR_INVALID_CURSOR_POS",
        "Cannot set cursor row without setting its column",
      );
      E("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
      E(
        "ERR_INVALID_FILE_URL_HOST",
        'File URL host must be "localhost" or empty on %s',
      );
      E("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
      E("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
      E("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
      E(
        "ERR_INVALID_OPT_VALUE",
        (name, value) =>
          `The value "${String(value)}" is invalid for option "${name}"`,
      );
      E(
        "ERR_INVALID_OPT_VALUE_ENCODING",
        (value) =>
          `The value "${String(value)}" is invalid for option "encoding"`,
      );
      E(
        "ERR_INVALID_REPL_EVAL_CONFIG",
        'Cannot specify both "breakEvalOnSigint" and "eval" for REPL',
      );
      E(
        "ERR_INVALID_SYNC_FORK_INPUT",
        "Asynchronous forks do not support Buffer, Uint8Array or string input: %s",
      );
      E("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
      E("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
      E("ERR_INVALID_URL", "Invalid URL: %s");
      E(
        "ERR_INVALID_URL_SCHEME",
        (expected) => `The URL must be ${oneOf(expected, "scheme")}`,
      );
      E("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
      E("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
      E("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
      E("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
      E("ERR_MISSING_ARGS", missingArgs);
      E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      E("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
      E(
        "ERR_NAPI_CONS_PROTOTYPE_OBJECT",
        "Constructor.prototype must be an object",
      );
      E("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
      E("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
      E("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
      E("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
      E("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
      E(
        "ERR_SOCKET_BAD_TYPE",
        "Bad socket type specified. Valid types are: udp4, udp6",
      );
      E("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
      E("ERR_SOCKET_CLOSED", "Socket is closed");
      E("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
      E("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
      E("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
      E("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
      E(
        "ERR_TLS_CERT_ALTNAME_INVALID",
        "Hostname/IP does not match certificate's altnames: %s",
      );
      E(
        "ERR_TLS_DH_PARAM_SIZE",
        (size) => `DH parameter size ${size} is less than 2048`,
      );
      E("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
      E("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
      E(
        "ERR_TLS_REQUIRED_SERVER_NAME",
        '"servername" is required parameter for Server.addContext',
      );
      E("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
      E(
        "ERR_TRANSFORM_ALREADY_TRANSFORMING",
        "Calling transform done when still transforming",
      );
      E(
        "ERR_TRANSFORM_WITH_LENGTH_0",
        "Calling transform done when writableState.length != 0",
      );
      E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
      E("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
      E("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
      E("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
      E(
        "ERR_V8BREAKITERATOR",
        "Full ICU data not installed. " +
          "See https://github.com/nodejs/node/wiki/Intl",
      );
      function invalidArgType(name, expected, actual) {
        assert(name, "name is required");
        let determiner;
        if (expected.includes("not ")) {
          determiner = "must not be";
          expected = expected.split("not ")[1];
        } else {
          determiner = "must be";
        }
        let msg;
        if (Array.isArray(name)) {
          const names = name.map((val) => `"${val}"`).join(", ");
          msg = `The ${names} arguments ${determiner} ${oneOf(expected, "type")}`;
        } else if (name.includes(" argument")) {
          msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
        } else {
          const type = name.includes(".") ? "property" : "argument";
          msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
        }
        if (arguments.length >= 3) {
          msg += `. Received type ${actual !== null ? typeof actual : "null"}`;
        }
        return msg;
      }
      function missingArgs(...args) {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg = "The ";
        const len = args.length;
        args = args.map((a) => `"${a}"`);
        switch (len) {
          case 1:
            msg += `${args[0]} argument`;
            break;
          case 2:
            msg += `${args[0]} and ${args[1]} arguments`;
            break;
          default:
            msg += args.slice(0, len - 1).join(", ");
            msg += `, and ${args[len - 1]} arguments`;
            break;
        }
        return `${msg} must be specified`;
      }
      function oneOf(expected, thing) {
        assert(expected, "expected is required");
        assert(typeof thing === "string", "thing is required");
        if (Array.isArray(expected)) {
          const len = expected.length;
          assert(len > 0, "At least one expected value needs to be specified");
          expected = expected.map((i) => String(i));
          if (len > 2) {
            return (
              `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` +
              expected[len - 1]
            );
          } else if (len === 2) {
            return `one of ${thing} ${expected[0]} or ${expected[1]}`;
          } else {
            return `of ${thing} ${expected[0]}`;
          }
        } else {
          return `of ${thing} ${String(expected)}`;
        }
      }
      function bufferOutOfBounds(name, isWriting) {
        if (isWriting) {
          return "Attempt to write outside buffer bounds";
        } else {
          return `"${name}" is outside of buffer bounds`;
        }
      }
    },
    615: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.printTree = void 0;
      const printTree = (tab = "", children) => {
        children = children.filter(Boolean);
        let str = "";
        for (let i = 0; i < children.length; i++) {
          const isLast = i >= children.length - 1;
          const fn = children[i];
          if (!fn) continue;
          const child = fn(tab + `${isLast ? " " : "│"}  `);
          const branch = child ? (isLast ? "└─" : "├─") : "│ ";
          str += `\n${tab}${branch} ${child}`;
        }
        return str;
      };
      exports.printTree = printTree;
    },
    332: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.newNotAllowedError =
        exports.newTypeMismatchError =
        exports.newNotFoundError =
        exports.assertCanWrite =
        exports.assertName =
        exports.basename =
        exports.ctx =
          void 0;
      const ctx = (partial = {}) =>
        Object.assign(
          { separator: "/", syncHandleAllowed: false, mode: "read" },
          partial,
        );
      exports.ctx = ctx;
      const basename = (path, separator) => {
        if (path[path.length - 1] === separator) path = path.slice(0, -1);
        const lastSlashIndex = path.lastIndexOf(separator);
        return lastSlashIndex === -1 ? path : path.slice(lastSlashIndex + 1);
      };
      exports.basename = basename;
      const nameRegex = /^(\.{1,2})$|^(.*([\/\\]).*)$/;
      const assertName = (name, method, klass) => {
        const isInvalid = !name || nameRegex.test(name);
        if (isInvalid)
          throw new TypeError(
            `Failed to execute '${method}' on '${klass}': Name is not allowed.`,
          );
      };
      exports.assertName = assertName;
      const assertCanWrite = (mode) => {
        if (mode !== "readwrite")
          throw new DOMException(
            "The request is not allowed by the user agent or the platform in the current context.",
            "NotAllowedError",
          );
      };
      exports.assertCanWrite = assertCanWrite;
      const newNotFoundError = () =>
        new DOMException(
          "A requested file or directory could not be found at the time an operation was processed.",
          "NotFoundError",
        );
      exports.newNotFoundError = newNotFoundError;
      const newTypeMismatchError = () =>
        new DOMException(
          "The path supplied exists, but was not an entry of requested type.",
          "TypeMismatchError",
        );
      exports.newTypeMismatchError = newTypeMismatchError;
      const newNotAllowedError = () =>
        new DOMException("Permission not granted.", "NotAllowedError");
      exports.newNotAllowedError = newNotAllowedError;
    },
    616: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.File = exports.Link = exports.Node = exports.SEP = void 0;
      const process_1 = __nccwpck_require__(486);
      const buffer_1 = __nccwpck_require__(730);
      const constants_1 = __nccwpck_require__(55);
      const events_1 = __nccwpck_require__(361);
      const Stats_1 = __nccwpck_require__(441);
      const { S_IFMT, S_IFDIR, S_IFREG, S_IFLNK, O_APPEND } =
        constants_1.constants;
      const getuid = () => {
        var _a, _b;
        return (_b =
          (_a = process_1.default.getuid) === null || _a === void 0
            ? void 0
            : _a.call(process_1.default)) !== null && _b !== void 0
          ? _b
          : 0;
      };
      const getgid = () => {
        var _a, _b;
        return (_b =
          (_a = process_1.default.getgid) === null || _a === void 0
            ? void 0
            : _a.call(process_1.default)) !== null && _b !== void 0
          ? _b
          : 0;
      };
      exports.SEP = "/";
      class Node extends events_1.EventEmitter {
        constructor(ino, perm = 438) {
          super();
          this._uid = getuid();
          this._gid = getgid();
          this._atime = new Date();
          this._mtime = new Date();
          this._ctime = new Date();
          this._perm = 438;
          this.mode = S_IFREG;
          this._nlink = 1;
          this._perm = perm;
          this.mode |= perm;
          this.ino = ino;
        }
        set ctime(ctime) {
          this._ctime = ctime;
        }
        get ctime() {
          return this._ctime;
        }
        set uid(uid) {
          this._uid = uid;
          this.ctime = new Date();
        }
        get uid() {
          return this._uid;
        }
        set gid(gid) {
          this._gid = gid;
          this.ctime = new Date();
        }
        get gid() {
          return this._gid;
        }
        set atime(atime) {
          this._atime = atime;
          this.ctime = new Date();
        }
        get atime() {
          return this._atime;
        }
        set mtime(mtime) {
          this._mtime = mtime;
          this.ctime = new Date();
        }
        get mtime() {
          return this._mtime;
        }
        set perm(perm) {
          this._perm = perm;
          this.ctime = new Date();
        }
        get perm() {
          return this._perm;
        }
        set nlink(nlink) {
          this._nlink = nlink;
          this.ctime = new Date();
        }
        get nlink() {
          return this._nlink;
        }
        getString(encoding = "utf8") {
          this.atime = new Date();
          return this.getBuffer().toString(encoding);
        }
        setString(str) {
          this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
          this.touch();
        }
        getBuffer() {
          this.atime = new Date();
          if (!this.buf) this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
          return (0, buffer_1.bufferFrom)(this.buf);
        }
        setBuffer(buf) {
          this.buf = (0, buffer_1.bufferFrom)(buf);
          this.touch();
        }
        getSize() {
          return this.buf ? this.buf.length : 0;
        }
        setModeProperty(property) {
          this.mode = (this.mode & ~S_IFMT) | property;
        }
        setIsFile() {
          this.setModeProperty(S_IFREG);
        }
        setIsDirectory() {
          this.setModeProperty(S_IFDIR);
        }
        setIsSymlink() {
          this.setModeProperty(S_IFLNK);
        }
        isFile() {
          return (this.mode & S_IFMT) === S_IFREG;
        }
        isDirectory() {
          return (this.mode & S_IFMT) === S_IFDIR;
        }
        isSymlink() {
          return (this.mode & S_IFMT) === S_IFLNK;
        }
        makeSymlink(steps) {
          this.symlink = steps;
          this.setIsSymlink();
        }
        write(buf, off = 0, len = buf.length, pos = 0) {
          if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (pos + len > this.buf.length) {
            const newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
            this.buf.copy(newBuf, 0, 0, this.buf.length);
            this.buf = newBuf;
          }
          buf.copy(this.buf, pos, off, off + len);
          this.touch();
          return len;
        }
        read(buf, off = 0, len = buf.byteLength, pos = 0) {
          this.atime = new Date();
          if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          let actualLen = len;
          if (actualLen > buf.byteLength) {
            actualLen = buf.byteLength;
          }
          if (actualLen + pos > this.buf.length) {
            actualLen = this.buf.length - pos;
          }
          const buf2 =
            buf instanceof buffer_1.Buffer
              ? buf
              : buffer_1.Buffer.from(buf.buffer);
          this.buf.copy(buf2, off, pos, pos + actualLen);
          return actualLen;
        }
        truncate(len = 0) {
          if (!len) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          else {
            if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
            if (len <= this.buf.length) {
              this.buf = this.buf.slice(0, len);
            } else {
              const buf = (0, buffer_1.bufferAllocUnsafe)(len);
              this.buf.copy(buf);
              buf.fill(0, this.buf.length);
              this.buf = buf;
            }
          }
          this.touch();
        }
        chmod(perm) {
          this.perm = perm;
          this.mode = (this.mode & ~511) | perm;
          this.touch();
        }
        chown(uid, gid) {
          this.uid = uid;
          this.gid = gid;
          this.touch();
        }
        touch() {
          this.mtime = new Date();
          this.emit("change", this);
        }
        canRead(uid = getuid(), gid = getgid()) {
          if (this.perm & 4) {
            return true;
          }
          if (gid === this.gid) {
            if (this.perm & 32) {
              return true;
            }
          }
          if (uid === this.uid) {
            if (this.perm & 256) {
              return true;
            }
          }
          return false;
        }
        canWrite(uid = getuid(), gid = getgid()) {
          if (this.perm & 2) {
            return true;
          }
          if (gid === this.gid) {
            if (this.perm & 16) {
              return true;
            }
          }
          if (uid === this.uid) {
            if (this.perm & 128) {
              return true;
            }
          }
          return false;
        }
        del() {
          this.emit("delete", this);
        }
        toJSON() {
          return {
            ino: this.ino,
            uid: this.uid,
            gid: this.gid,
            atime: this.atime.getTime(),
            mtime: this.mtime.getTime(),
            ctime: this.ctime.getTime(),
            perm: this.perm,
            mode: this.mode,
            nlink: this.nlink,
            symlink: this.symlink,
            data: this.getString(),
          };
        }
      }
      exports.Node = Node;
      class Link extends events_1.EventEmitter {
        get steps() {
          return this._steps;
        }
        set steps(val) {
          this._steps = val;
          for (const [child, link] of this.children.entries()) {
            if (child === "." || child === "..") {
              continue;
            }
            link === null || link === void 0 ? void 0 : link.syncSteps();
          }
        }
        constructor(vol, parent, name) {
          super();
          this.children = new Map();
          this._steps = [];
          this.ino = 0;
          this.length = 0;
          this.vol = vol;
          this.parent = parent;
          this.name = name;
          this.syncSteps();
        }
        setNode(node) {
          this.node = node;
          this.ino = node.ino;
        }
        getNode() {
          return this.node;
        }
        createChild(name, node = this.vol.createNode()) {
          const link = new Link(this.vol, this, name);
          link.setNode(node);
          if (node.isDirectory()) {
            link.children.set(".", link);
            link.getNode().nlink++;
          }
          this.setChild(name, link);
          return link;
        }
        setChild(name, link = new Link(this.vol, this, name)) {
          this.children.set(name, link);
          link.parent = this;
          this.length++;
          const node = link.getNode();
          if (node.isDirectory()) {
            link.children.set("..", this);
            this.getNode().nlink++;
          }
          this.getNode().mtime = new Date();
          this.emit("child:add", link, this);
          return link;
        }
        deleteChild(link) {
          const node = link.getNode();
          if (node.isDirectory()) {
            link.children.delete("..");
            this.getNode().nlink--;
          }
          this.children.delete(link.getName());
          this.length--;
          this.getNode().mtime = new Date();
          this.emit("child:delete", link, this);
        }
        getChild(name) {
          this.getNode().mtime = new Date();
          return this.children.get(name);
        }
        getPath() {
          return this.steps.join(exports.SEP);
        }
        getParentPath() {
          return this.steps.slice(0, -1).join(exports.SEP);
        }
        getName() {
          return this.steps[this.steps.length - 1];
        }
        walk(steps, stop = steps.length, i = 0) {
          if (i >= steps.length) return this;
          if (i >= stop) return this;
          const step = steps[i];
          const link = this.getChild(step);
          if (!link) return null;
          return link.walk(steps, stop, i + 1);
        }
        toJSON() {
          return {
            steps: this.steps,
            ino: this.ino,
            children: Array.from(this.children.keys()),
          };
        }
        syncSteps() {
          this.steps = this.parent
            ? this.parent.steps.concat([this.name])
            : [this.name];
        }
      }
      exports.Link = Link;
      class File {
        constructor(link, node, flags, fd) {
          this.link = link;
          this.node = node;
          this.flags = flags;
          this.fd = fd;
          this.position = 0;
          if (this.flags & O_APPEND) this.position = this.getSize();
        }
        getString(encoding = "utf8") {
          return this.node.getString();
        }
        setString(str) {
          this.node.setString(str);
        }
        getBuffer() {
          return this.node.getBuffer();
        }
        setBuffer(buf) {
          this.node.setBuffer(buf);
        }
        getSize() {
          return this.node.getSize();
        }
        truncate(len) {
          this.node.truncate(len);
        }
        seekTo(position) {
          this.position = position;
        }
        stats() {
          return Stats_1.default.build(this.node);
        }
        write(buf, offset = 0, length = buf.length, position) {
          if (typeof position !== "number") position = this.position;
          const bytes = this.node.write(buf, offset, length, position);
          this.position = position + bytes;
          return bytes;
        }
        read(buf, offset = 0, length = buf.byteLength, position) {
          if (typeof position !== "number") position = this.position;
          const bytes = this.node.read(buf, offset, length, position);
          this.position = position + bytes;
          return bytes;
        }
        chmod(perm) {
          this.node.chmod(perm);
        }
        chown(uid, gid) {
          this.node.chown(uid, gid);
        }
      }
      exports.File = File;
    },
    353: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FileHandle = void 0;
      const util_1 = __nccwpck_require__(103);
      class FileHandle {
        constructor(fs, fd) {
          this.fs = fs;
          this.fd = fd;
        }
        appendFile(data, options) {
          return (0, util_1.promisify)(this.fs, "appendFile")(
            this.fd,
            data,
            options,
          );
        }
        chmod(mode) {
          return (0, util_1.promisify)(this.fs, "fchmod")(this.fd, mode);
        }
        chown(uid, gid) {
          return (0, util_1.promisify)(this.fs, "fchown")(this.fd, uid, gid);
        }
        close() {
          return (0, util_1.promisify)(this.fs, "close")(this.fd);
        }
        datasync() {
          return (0, util_1.promisify)(this.fs, "fdatasync")(this.fd);
        }
        read(buffer, offset, length, position) {
          return (0, util_1.promisify)(this.fs, "read", (bytesRead) => ({
            bytesRead,
            buffer,
          }))(this.fd, buffer, offset, length, position);
        }
        readv(buffers, position) {
          return (0, util_1.promisify)(this.fs, "readv", (bytesRead) => ({
            bytesRead,
            buffers,
          }))(this.fd, buffers, position);
        }
        readFile(options) {
          return (0, util_1.promisify)(this.fs, "readFile")(this.fd, options);
        }
        stat(options) {
          return (0, util_1.promisify)(this.fs, "fstat")(this.fd, options);
        }
        sync() {
          return (0, util_1.promisify)(this.fs, "fsync")(this.fd);
        }
        truncate(len) {
          return (0, util_1.promisify)(this.fs, "ftruncate")(this.fd, len);
        }
        utimes(atime, mtime) {
          return (0, util_1.promisify)(this.fs, "futimes")(
            this.fd,
            atime,
            mtime,
          );
        }
        write(buffer, offset, length, position) {
          return (0, util_1.promisify)(this.fs, "write", (bytesWritten) => ({
            bytesWritten,
            buffer,
          }))(this.fd, buffer, offset, length, position);
        }
        writev(buffers, position) {
          return (0, util_1.promisify)(this.fs, "writev", (bytesWritten) => ({
            bytesWritten,
            buffers,
          }))(this.fd, buffers, position);
        }
        writeFile(data, options) {
          return (0, util_1.promisify)(this.fs, "writeFile")(
            this.fd,
            data,
            options,
          );
        }
      }
      exports.FileHandle = FileHandle;
    },
    167: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FsPromises = void 0;
      const util_1 = __nccwpck_require__(103);
      const constants_1 = __nccwpck_require__(55);
      class FsPromises {
        constructor(fs, FileHandle) {
          this.fs = fs;
          this.FileHandle = FileHandle;
          this.constants = constants_1.constants;
          this.cp = (0, util_1.promisify)(this.fs, "cp");
          this.opendir = (0, util_1.promisify)(this.fs, "opendir");
          this.statfs = (0, util_1.promisify)(this.fs, "statfs");
          this.lutimes = (0, util_1.promisify)(this.fs, "lutimes");
          this.access = (0, util_1.promisify)(this.fs, "access");
          this.chmod = (0, util_1.promisify)(this.fs, "chmod");
          this.chown = (0, util_1.promisify)(this.fs, "chown");
          this.copyFile = (0, util_1.promisify)(this.fs, "copyFile");
          this.lchmod = (0, util_1.promisify)(this.fs, "lchmod");
          this.lchown = (0, util_1.promisify)(this.fs, "lchown");
          this.link = (0, util_1.promisify)(this.fs, "link");
          this.lstat = (0, util_1.promisify)(this.fs, "lstat");
          this.mkdir = (0, util_1.promisify)(this.fs, "mkdir");
          this.mkdtemp = (0, util_1.promisify)(this.fs, "mkdtemp");
          this.readdir = (0, util_1.promisify)(this.fs, "readdir");
          this.readlink = (0, util_1.promisify)(this.fs, "readlink");
          this.realpath = (0, util_1.promisify)(this.fs, "realpath");
          this.rename = (0, util_1.promisify)(this.fs, "rename");
          this.rmdir = (0, util_1.promisify)(this.fs, "rmdir");
          this.rm = (0, util_1.promisify)(this.fs, "rm");
          this.stat = (0, util_1.promisify)(this.fs, "stat");
          this.symlink = (0, util_1.promisify)(this.fs, "symlink");
          this.truncate = (0, util_1.promisify)(this.fs, "truncate");
          this.unlink = (0, util_1.promisify)(this.fs, "unlink");
          this.utimes = (0, util_1.promisify)(this.fs, "utimes");
          this.readFile = (id, options) =>
            (0, util_1.promisify)(this.fs, "readFile")(
              id instanceof this.FileHandle ? id.fd : id,
              options,
            );
          this.appendFile = (path, data, options) =>
            (0, util_1.promisify)(this.fs, "appendFile")(
              path instanceof this.FileHandle ? path.fd : path,
              data,
              options,
            );
          this.open = (path, flags = "r", mode) =>
            (0, util_1.promisify)(
              this.fs,
              "open",
              (fd) => new this.FileHandle(this.fs, fd),
            )(path, flags, mode);
          this.writeFile = (id, data, options) =>
            (0, util_1.promisify)(this.fs, "writeFile")(
              id instanceof this.FileHandle ? id.fd : id,
              data,
              options,
            );
          this.watch = () => {
            throw new Error("Not implemented");
          };
        }
      }
      exports.FsPromises = FsPromises;
    },
    661: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FLAGS = exports.ERRSTR = void 0;
      const constants_1 = __nccwpck_require__(55);
      exports.ERRSTR = {
        PATH_STR: "path must be a string or Buffer",
        FD: "fd must be a file descriptor",
        MODE_INT: "mode must be an int",
        CB: "callback must be a function",
        UID: "uid must be an unsigned int",
        GID: "gid must be an unsigned int",
        LEN: "len must be an integer",
        ATIME: "atime must be an integer",
        MTIME: "mtime must be an integer",
        PREFIX: "filename prefix is required",
        BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
        OFFSET: "offset must be an integer",
        LENGTH: "length must be an integer",
        POSITION: "position must be an integer",
      };
      const {
        O_RDONLY,
        O_WRONLY,
        O_RDWR,
        O_CREAT,
        O_EXCL,
        O_TRUNC,
        O_APPEND,
        O_SYNC,
      } = constants_1.constants;
      var FLAGS;
      (function (FLAGS) {
        FLAGS[(FLAGS["r"] = O_RDONLY)] = "r";
        FLAGS[(FLAGS["r+"] = O_RDWR)] = "r+";
        FLAGS[(FLAGS["rs"] = O_RDONLY | O_SYNC)] = "rs";
        FLAGS[(FLAGS["sr"] = FLAGS.rs)] = "sr";
        FLAGS[(FLAGS["rs+"] = O_RDWR | O_SYNC)] = "rs+";
        FLAGS[(FLAGS["sr+"] = FLAGS["rs+"])] = "sr+";
        FLAGS[(FLAGS["w"] = O_WRONLY | O_CREAT | O_TRUNC)] = "w";
        FLAGS[(FLAGS["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL)] = "wx";
        FLAGS[(FLAGS["xw"] = FLAGS.wx)] = "xw";
        FLAGS[(FLAGS["w+"] = O_RDWR | O_CREAT | O_TRUNC)] = "w+";
        FLAGS[(FLAGS["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL)] = "wx+";
        FLAGS[(FLAGS["xw+"] = FLAGS["wx+"])] = "xw+";
        FLAGS[(FLAGS["a"] = O_WRONLY | O_APPEND | O_CREAT)] = "a";
        FLAGS[(FLAGS["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL)] = "ax";
        FLAGS[(FLAGS["xa"] = FLAGS.ax)] = "xa";
        FLAGS[(FLAGS["a+"] = O_RDWR | O_APPEND | O_CREAT)] = "a+";
        FLAGS[(FLAGS["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL)] = "ax+";
        FLAGS[(FLAGS["xa+"] = FLAGS["ax+"])] = "xa+";
      })(FLAGS || (exports.FLAGS = FLAGS = {}));
    },
    314: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fsCallbackApiList = void 0;
      exports.fsCallbackApiList = [
        "access",
        "appendFile",
        "chmod",
        "chown",
        "close",
        "copyFile",
        "createReadStream",
        "createWriteStream",
        "exists",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchmod",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "mkdtemp",
        "open",
        "read",
        "readv",
        "readdir",
        "readFile",
        "readlink",
        "realpath",
        "rename",
        "rm",
        "rmdir",
        "stat",
        "symlink",
        "truncate",
        "unlink",
        "unwatchFile",
        "utimes",
        "watch",
        "watchFile",
        "write",
        "writev",
        "writeFile",
      ];
    },
    601: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fsSynchronousApiList = void 0;
      exports.fsSynchronousApiList = [
        "accessSync",
        "appendFileSync",
        "chmodSync",
        "chownSync",
        "closeSync",
        "copyFileSync",
        "existsSync",
        "fchmodSync",
        "fchownSync",
        "fdatasyncSync",
        "fstatSync",
        "fsyncSync",
        "ftruncateSync",
        "futimesSync",
        "lchmodSync",
        "lchownSync",
        "linkSync",
        "lstatSync",
        "mkdirSync",
        "mkdtempSync",
        "openSync",
        "readdirSync",
        "readFileSync",
        "readlinkSync",
        "readSync",
        "readvSync",
        "realpathSync",
        "renameSync",
        "rmdirSync",
        "rmSync",
        "statSync",
        "symlinkSync",
        "truncateSync",
        "unlinkSync",
        "utimesSync",
        "writeFileSync",
        "writeSync",
        "writevSync",
      ];
    },
    456: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getWriteFileOptions =
        exports.writeFileDefaults =
        exports.getRealpathOptsAndCb =
        exports.getRealpathOptions =
        exports.getStatOptsAndCb =
        exports.getStatOptions =
        exports.getAppendFileOptsAndCb =
        exports.getAppendFileOpts =
        exports.getReaddirOptsAndCb =
        exports.getReaddirOptions =
        exports.getReadFileOptions =
        exports.getRmOptsAndCb =
        exports.getRmdirOptions =
        exports.getDefaultOptsAndCb =
        exports.getDefaultOpts =
        exports.optsDefaults =
        exports.optsAndCbGenerator =
        exports.optsGenerator =
        exports.getOptions =
        exports.getMkdirOptions =
          void 0;
      const constants_1 = __nccwpck_require__(661);
      const encoding_1 = __nccwpck_require__(900);
      const util_1 = __nccwpck_require__(103);
      const mkdirDefaults = { mode: 511, recursive: false };
      const getMkdirOptions = (options) => {
        if (typeof options === "number")
          return Object.assign({}, mkdirDefaults, { mode: options });
        return Object.assign({}, mkdirDefaults, options);
      };
      exports.getMkdirOptions = getMkdirOptions;
      const ERRSTR_OPTS = (tipeof) =>
        `Expected options to be either an object or a string, but got ${tipeof} instead`;
      function getOptions(defaults, options) {
        let opts;
        if (!options) return defaults;
        else {
          const tipeof = typeof options;
          switch (tipeof) {
            case "string":
              opts = Object.assign({}, defaults, { encoding: options });
              break;
            case "object":
              opts = Object.assign({}, defaults, options);
              break;
            default:
              throw TypeError(ERRSTR_OPTS(tipeof));
          }
        }
        if (opts.encoding !== "buffer")
          (0, encoding_1.assertEncoding)(opts.encoding);
        return opts;
      }
      exports.getOptions = getOptions;
      function optsGenerator(defaults) {
        return (options) => getOptions(defaults, options);
      }
      exports.optsGenerator = optsGenerator;
      function optsAndCbGenerator(getOpts) {
        return (options, callback) =>
          typeof options === "function"
            ? [getOpts(), options]
            : [getOpts(options), (0, util_1.validateCallback)(callback)];
      }
      exports.optsAndCbGenerator = optsAndCbGenerator;
      exports.optsDefaults = { encoding: "utf8" };
      exports.getDefaultOpts = optsGenerator(exports.optsDefaults);
      exports.getDefaultOptsAndCb = optsAndCbGenerator(exports.getDefaultOpts);
      const rmdirDefaults = { recursive: false };
      const getRmdirOptions = (options) =>
        Object.assign({}, rmdirDefaults, options);
      exports.getRmdirOptions = getRmdirOptions;
      const getRmOpts = optsGenerator(exports.optsDefaults);
      exports.getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
      const readFileOptsDefaults = { flag: "r" };
      exports.getReadFileOptions = optsGenerator(readFileOptsDefaults);
      const readdirDefaults = {
        encoding: "utf8",
        recursive: false,
        withFileTypes: false,
      };
      exports.getReaddirOptions = optsGenerator(readdirDefaults);
      exports.getReaddirOptsAndCb = optsAndCbGenerator(
        exports.getReaddirOptions,
      );
      const appendFileDefaults = {
        encoding: "utf8",
        mode: 438,
        flag: constants_1.FLAGS[constants_1.FLAGS.a],
      };
      exports.getAppendFileOpts = optsGenerator(appendFileDefaults);
      exports.getAppendFileOptsAndCb = optsAndCbGenerator(
        exports.getAppendFileOpts,
      );
      const statDefaults = { bigint: false };
      const getStatOptions = (options = {}) =>
        Object.assign({}, statDefaults, options);
      exports.getStatOptions = getStatOptions;
      const getStatOptsAndCb = (options, callback) =>
        typeof options === "function"
          ? [(0, exports.getStatOptions)(), options]
          : [
              (0, exports.getStatOptions)(options),
              (0, util_1.validateCallback)(callback),
            ];
      exports.getStatOptsAndCb = getStatOptsAndCb;
      const realpathDefaults = exports.optsDefaults;
      exports.getRealpathOptions = optsGenerator(realpathDefaults);
      exports.getRealpathOptsAndCb = optsAndCbGenerator(
        exports.getRealpathOptions,
      );
      exports.writeFileDefaults = {
        encoding: "utf8",
        mode: 438,
        flag: constants_1.FLAGS[constants_1.FLAGS.w],
      };
      exports.getWriteFileOptions = optsGenerator(exports.writeFileDefaults);
    },
    103: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unixify =
        exports.bufferToEncoding =
        exports.getWriteSyncArgs =
        exports.getWriteArgs =
        exports.bufToUint8 =
        exports.dataToBuffer =
        exports.validateFd =
        exports.isFd =
        exports.flagsToNumber =
        exports.genRndStr6 =
        exports.createError =
        exports.pathToFilename =
        exports.nullCheck =
        exports.modeToNumber =
        exports.validateCallback =
        exports.promisify =
        exports.isWin =
          void 0;
      const constants_1 = __nccwpck_require__(661);
      const errors = __nccwpck_require__(40);
      const buffer_1 = __nccwpck_require__(730);
      const encoding_1 = __nccwpck_require__(900);
      const buffer_2 = __nccwpck_require__(730);
      const queueMicrotask_1 = __nccwpck_require__(563);
      exports.isWin = process.platform === "win32";
      function promisify(fs, fn, getResult = (input) => input) {
        return (...args) =>
          new Promise((resolve, reject) => {
            fs[fn].bind(fs)(...args, (error, result) => {
              if (error) return reject(error);
              return resolve(getResult(result));
            });
          });
      }
      exports.promisify = promisify;
      function validateCallback(callback) {
        if (typeof callback !== "function")
          throw TypeError(constants_1.ERRSTR.CB);
        return callback;
      }
      exports.validateCallback = validateCallback;
      function _modeToNumber(mode, def) {
        if (typeof mode === "number") return mode;
        if (typeof mode === "string") return parseInt(mode, 8);
        if (def) return modeToNumber(def);
        return undefined;
      }
      function modeToNumber(mode, def) {
        const result = _modeToNumber(mode, def);
        if (typeof result !== "number" || isNaN(result))
          throw new TypeError(constants_1.ERRSTR.MODE_INT);
        return result;
      }
      exports.modeToNumber = modeToNumber;
      function nullCheck(path, callback) {
        if (("" + path).indexOf("\0") !== -1) {
          const er = new Error("Path must be a string without null bytes");
          er.code = "ENOENT";
          if (typeof callback !== "function") throw er;
          (0, queueMicrotask_1.default)(() => {
            callback(er);
          });
          return false;
        }
        return true;
      }
      exports.nullCheck = nullCheck;
      function getPathFromURLPosix(url) {
        if (url.hostname !== "") {
          throw new errors.TypeError(
            "ERR_INVALID_FILE_URL_HOST",
            process.platform,
          );
        }
        const pathname = url.pathname;
        for (let n = 0; n < pathname.length; n++) {
          if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 32;
            if (pathname[n + 1] === "2" && third === 102) {
              throw new errors.TypeError(
                "ERR_INVALID_FILE_URL_PATH",
                "must not include encoded / characters",
              );
            }
          }
        }
        return decodeURIComponent(pathname);
      }
      function pathToFilename(path) {
        if (typeof path !== "string" && !buffer_1.Buffer.isBuffer(path)) {
          try {
            if (!(path instanceof __nccwpck_require__(310).URL))
              throw new TypeError(constants_1.ERRSTR.PATH_STR);
          } catch (err) {
            throw new TypeError(constants_1.ERRSTR.PATH_STR);
          }
          path = getPathFromURLPosix(path);
        }
        const pathString = String(path);
        nullCheck(pathString);
        return pathString;
      }
      exports.pathToFilename = pathToFilename;
      const ENOENT = "ENOENT";
      const EBADF = "EBADF";
      const EINVAL = "EINVAL";
      const EPERM = "EPERM";
      const EPROTO = "EPROTO";
      const EEXIST = "EEXIST";
      const ENOTDIR = "ENOTDIR";
      const EMFILE = "EMFILE";
      const EACCES = "EACCES";
      const EISDIR = "EISDIR";
      const ENOTEMPTY = "ENOTEMPTY";
      const ENOSYS = "ENOSYS";
      const ERR_FS_EISDIR = "ERR_FS_EISDIR";
      const ERR_OUT_OF_RANGE = "ERR_OUT_OF_RANGE";
      function formatError(errorCode, func = "", path = "", path2 = "") {
        let pathFormatted = "";
        if (path) pathFormatted = ` '${path}'`;
        if (path2) pathFormatted += ` -> '${path2}'`;
        switch (errorCode) {
          case ENOENT:
            return `ENOENT: no such file or directory, ${func}${pathFormatted}`;
          case EBADF:
            return `EBADF: bad file descriptor, ${func}${pathFormatted}`;
          case EINVAL:
            return `EINVAL: invalid argument, ${func}${pathFormatted}`;
          case EPERM:
            return `EPERM: operation not permitted, ${func}${pathFormatted}`;
          case EPROTO:
            return `EPROTO: protocol error, ${func}${pathFormatted}`;
          case EEXIST:
            return `EEXIST: file already exists, ${func}${pathFormatted}`;
          case ENOTDIR:
            return `ENOTDIR: not a directory, ${func}${pathFormatted}`;
          case EISDIR:
            return `EISDIR: illegal operation on a directory, ${func}${pathFormatted}`;
          case EACCES:
            return `EACCES: permission denied, ${func}${pathFormatted}`;
          case ENOTEMPTY:
            return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
          case EMFILE:
            return `EMFILE: too many open files, ${func}${pathFormatted}`;
          case ENOSYS:
            return `ENOSYS: function not implemented, ${func}${pathFormatted}`;
          case ERR_FS_EISDIR:
            return `[ERR_FS_EISDIR]: Path is a directory: ${func} returned EISDIR (is a directory) ${path}`;
          case ERR_OUT_OF_RANGE:
            return `[ERR_OUT_OF_RANGE]: value out of range, ${func}${pathFormatted}`;
          default:
            return `${errorCode}: error occurred, ${func}${pathFormatted}`;
        }
      }
      function createError(
        errorCode,
        func = "",
        path = "",
        path2 = "",
        Constructor = Error,
      ) {
        const error = new Constructor(
          formatError(errorCode, func, path, path2),
        );
        error.code = errorCode;
        if (path) {
          error.path = path;
        }
        return error;
      }
      exports.createError = createError;
      function genRndStr6() {
        const str = (Math.random() + 1).toString(36).substring(2, 8);
        if (str.length === 6) return str;
        else return genRndStr6();
      }
      exports.genRndStr6 = genRndStr6;
      function flagsToNumber(flags) {
        if (typeof flags === "number") return flags;
        if (typeof flags === "string") {
          const flagsNum = constants_1.FLAGS[flags];
          if (typeof flagsNum !== "undefined") return flagsNum;
        }
        throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
      }
      exports.flagsToNumber = flagsToNumber;
      function isFd(path) {
        return path >>> 0 === path;
      }
      exports.isFd = isFd;
      function validateFd(fd) {
        if (!isFd(fd)) throw TypeError(constants_1.ERRSTR.FD);
      }
      exports.validateFd = validateFd;
      function dataToBuffer(data, encoding = encoding_1.ENCODING_UTF8) {
        if (buffer_1.Buffer.isBuffer(data)) return data;
        else if (data instanceof Uint8Array)
          return (0, buffer_2.bufferFrom)(data);
        else return (0, buffer_2.bufferFrom)(String(data), encoding);
      }
      exports.dataToBuffer = dataToBuffer;
      const bufToUint8 = (buf) =>
        new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      exports.bufToUint8 = bufToUint8;
      const getWriteArgs = (fd, a, b, c, d, e) => {
        validateFd(fd);
        let offset = 0;
        let length;
        let position = null;
        let encoding;
        let callback;
        const tipa = typeof a;
        const tipb = typeof b;
        const tipc = typeof c;
        const tipd = typeof d;
        if (tipa !== "string") {
          if (tipb === "function") {
            callback = b;
          } else if (tipc === "function") {
            offset = b | 0;
            callback = c;
          } else if (tipd === "function") {
            offset = b | 0;
            length = c;
            callback = d;
          } else {
            offset = b | 0;
            length = c;
            position = d;
            callback = e;
          }
        } else {
          if (tipb === "function") {
            callback = b;
          } else if (tipc === "function") {
            position = b;
            callback = c;
          } else if (tipd === "function") {
            position = b;
            encoding = c;
            callback = d;
          }
        }
        const buf = dataToBuffer(a, encoding);
        if (tipa !== "string") {
          if (typeof length === "undefined") length = buf.length;
        } else {
          offset = 0;
          length = buf.length;
        }
        const cb = validateCallback(callback);
        return [fd, tipa === "string", buf, offset, length, position, cb];
      };
      exports.getWriteArgs = getWriteArgs;
      const getWriteSyncArgs = (fd, a, b, c, d) => {
        validateFd(fd);
        let encoding;
        let offset;
        let length;
        let position;
        const isBuffer = typeof a !== "string";
        if (isBuffer) {
          offset = (b || 0) | 0;
          length = c;
          position = d;
        } else {
          position = b;
          encoding = c;
        }
        const buf = dataToBuffer(a, encoding);
        if (isBuffer) {
          if (typeof length === "undefined") {
            length = buf.length;
          }
        } else {
          offset = 0;
          length = buf.length;
        }
        return [fd, buf, offset || 0, length, position];
      };
      exports.getWriteSyncArgs = getWriteSyncArgs;
      function bufferToEncoding(buffer, encoding) {
        if (!encoding || encoding === "buffer") return buffer;
        else return buffer.toString(encoding);
      }
      exports.bufferToEncoding = bufferToEncoding;
      const isSeparator = (str, i) => {
        let char = str[i];
        return i > 0 && (char === "/" || (exports.isWin && char === "\\"));
      };
      const removeTrailingSeparator = (str) => {
        let i = str.length - 1;
        if (i < 2) return str;
        while (isSeparator(str, i)) i--;
        return str.substr(0, i + 1);
      };
      const normalizePath = (str, stripTrailing) => {
        if (typeof str !== "string") throw new TypeError("expected a string");
        str = str.replace(/[\\\/]+/g, "/");
        if (stripTrailing !== false) str = removeTrailingSeparator(str);
        return str;
      };
      const unixify = (filepath, stripTrailing = true) => {
        if (exports.isWin) {
          filepath = normalizePath(filepath, stripTrailing);
          return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
        }
        return filepath;
      };
      exports.unixify = unixify;
    },
    568: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toTreeSync = void 0;
      const printTree_1 = __nccwpck_require__(615);
      const util_1 = __nccwpck_require__(332);
      const toTreeSync = (fs, opts = {}) => {
        var _a;
        const separator = opts.separator || "/";
        let dir = opts.dir || separator;
        if (dir[dir.length - 1] !== separator) dir += separator;
        const tab = opts.tab || "";
        const depth = (_a = opts.depth) !== null && _a !== void 0 ? _a : 10;
        let subtree = " (...)";
        if (depth > 0) {
          const list = fs.readdirSync(dir, { withFileTypes: true });
          subtree = (0, printTree_1.printTree)(
            tab,
            list.map((entry) => (tab) => {
              if (entry.isDirectory()) {
                return (0, exports.toTreeSync)(fs, {
                  dir: dir + entry.name,
                  depth: depth - 1,
                  tab,
                });
              } else if (entry.isSymbolicLink()) {
                return (
                  "" + entry.name + " → " + fs.readlinkSync(dir + entry.name)
                );
              } else {
                return "" + entry.name;
              }
            }),
          );
        }
        const base = (0, util_1.basename)(dir, separator) + separator;
        return base + subtree;
      };
      exports.toTreeSync = toTreeSync;
    },
    486: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createProcess = void 0;
      const maybeReturnProcess = () => {
        if (typeof process !== "undefined") {
          return process;
        }
        try {
          return __nccwpck_require__(282);
        } catch (_a) {
          return undefined;
        }
      };
      function createProcess() {
        const p = maybeReturnProcess() || {};
        if (!p.cwd) p.cwd = () => "/";
        if (!p.emitWarning)
          p.emitWarning = (message, type) => {
            console.warn(`${type}${type ? ": " : ""}${message}`);
          };
        if (!p.env) p.env = {};
        return p;
      }
      exports.createProcess = createProcess;
      exports["default"] = createProcess();
    },
    563: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports["default"] =
        typeof queueMicrotask === "function"
          ? queueMicrotask
          : (cb) =>
              Promise.resolve()
                .then(() => cb())
                .catch(() => {});
    },
    431: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      let _setImmediate;
      if (typeof setImmediate === "function")
        _setImmediate = setImmediate.bind(
          typeof globalThis !== "undefined" ? globalThis : global,
        );
      else
        _setImmediate = setTimeout.bind(
          typeof globalThis !== "undefined" ? globalThis : global,
        );
      exports["default"] = _setImmediate;
    },
    306: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      function setTimeoutUnref(callback, time, args) {
        const ref = setTimeout.apply(
          typeof globalThis !== "undefined" ? globalThis : global,
          arguments,
        );
        if (ref && typeof ref === "object" && typeof ref.unref === "function")
          ref.unref();
        return ref;
      }
      exports["default"] = setTimeoutUnref;
    },
    380: (__unused_webpack_module, exports, __nccwpck_require__) => {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FSWatcher =
        exports.StatWatcher =
        exports.Volume =
        exports.toUnixTimestamp =
        exports.dataToStr =
        exports.pathToSteps =
        exports.filenameToSteps =
          void 0;
      const pathModule = __nccwpck_require__(17);
      const node_1 = __nccwpck_require__(616);
      const Stats_1 = __nccwpck_require__(441);
      const Dirent_1 = __nccwpck_require__(878);
      const buffer_1 = __nccwpck_require__(730);
      const setImmediate_1 = __nccwpck_require__(431);
      const queueMicrotask_1 = __nccwpck_require__(563);
      const process_1 = __nccwpck_require__(486);
      const setTimeoutUnref_1 = __nccwpck_require__(306);
      const stream_1 = __nccwpck_require__(781);
      const constants_1 = __nccwpck_require__(55);
      const events_1 = __nccwpck_require__(361);
      const encoding_1 = __nccwpck_require__(900);
      const FileHandle_1 = __nccwpck_require__(353);
      const util = __nccwpck_require__(837);
      const FsPromises_1 = __nccwpck_require__(167);
      const print_1 = __nccwpck_require__(568);
      const constants_2 = __nccwpck_require__(661);
      const options_1 = __nccwpck_require__(456);
      const util_1 = __nccwpck_require__(103);
      const resolveCrossPlatform = pathModule.resolve;
      const {
        O_RDONLY,
        O_WRONLY,
        O_RDWR,
        O_CREAT,
        O_EXCL,
        O_TRUNC,
        O_APPEND,
        O_DIRECTORY,
        O_SYMLINK,
        F_OK,
        COPYFILE_EXCL,
        COPYFILE_FICLONE_FORCE,
      } = constants_1.constants;
      const { sep, relative, join, dirname } = pathModule.posix
        ? pathModule.posix
        : pathModule;
      const kMinPoolSpace = 128;
      const EPERM = "EPERM";
      const ENOENT = "ENOENT";
      const EBADF = "EBADF";
      const EINVAL = "EINVAL";
      const EEXIST = "EEXIST";
      const ENOTDIR = "ENOTDIR";
      const EMFILE = "EMFILE";
      const EACCES = "EACCES";
      const EISDIR = "EISDIR";
      const ENOTEMPTY = "ENOTEMPTY";
      const ENOSYS = "ENOSYS";
      const ERR_FS_EISDIR = "ERR_FS_EISDIR";
      const ERR_OUT_OF_RANGE = "ERR_OUT_OF_RANGE";
      let resolve = (filename, base = process_1.default.cwd()) =>
        resolveCrossPlatform(base, filename);
      if (util_1.isWin) {
        const _resolve = resolve;
        resolve = (filename, base) =>
          (0, util_1.unixify)(_resolve(filename, base));
      }
      function filenameToSteps(filename, base) {
        const fullPath = resolve(filename, base);
        const fullPathSansSlash = fullPath.substring(1);
        if (!fullPathSansSlash) return [];
        return fullPathSansSlash.split(sep);
      }
      exports.filenameToSteps = filenameToSteps;
      function pathToSteps(path) {
        return filenameToSteps((0, util_1.pathToFilename)(path));
      }
      exports.pathToSteps = pathToSteps;
      function dataToStr(data, encoding = encoding_1.ENCODING_UTF8) {
        if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);
        else if (data instanceof Uint8Array)
          return (0, buffer_1.bufferFrom)(data).toString(encoding);
        else return String(data);
      }
      exports.dataToStr = dataToStr;
      function toUnixTimestamp(time) {
        if (typeof time === "string" && +time == time) {
          return +time;
        }
        if (time instanceof Date) {
          return time.getTime() / 1e3;
        }
        if (isFinite(time)) {
          if (time < 0) {
            return Date.now() / 1e3;
          }
          return time;
        }
        throw new Error("Cannot parse time: " + time);
      }
      exports.toUnixTimestamp = toUnixTimestamp;
      function validateUid(uid) {
        if (typeof uid !== "number") throw TypeError(constants_2.ERRSTR.UID);
      }
      function validateGid(gid) {
        if (typeof gid !== "number") throw TypeError(constants_2.ERRSTR.GID);
      }
      function flattenJSON(nestedJSON) {
        const flatJSON = {};
        function flatten(pathPrefix, node) {
          for (const path in node) {
            const contentOrNode = node[path];
            const joinedPath = join(pathPrefix, path);
            if (
              typeof contentOrNode === "string" ||
              contentOrNode instanceof buffer_1.Buffer
            ) {
              flatJSON[joinedPath] = contentOrNode;
            } else if (
              typeof contentOrNode === "object" &&
              contentOrNode !== null &&
              Object.keys(contentOrNode).length > 0
            ) {
              flatten(joinedPath, contentOrNode);
            } else {
              flatJSON[joinedPath] = null;
            }
          }
        }
        flatten("", nestedJSON);
        return flatJSON;
      }
      const notImplemented = () => {
        throw new Error("Not implemented");
      };
      class Volume {
        static fromJSON(json, cwd) {
          const vol = new Volume();
          vol.fromJSON(json, cwd);
          return vol;
        }
        static fromNestedJSON(json, cwd) {
          const vol = new Volume();
          vol.fromNestedJSON(json, cwd);
          return vol;
        }
        get promises() {
          if (this.promisesApi === null)
            throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        }
        constructor(props = {}) {
          this.ino = 0;
          this.inodes = {};
          this.releasedInos = [];
          this.fds = {};
          this.releasedFds = [];
          this.maxFiles = 1e4;
          this.openFiles = 0;
          this.promisesApi = new FsPromises_1.FsPromises(
            this,
            FileHandle_1.FileHandle,
          );
          this.statWatchers = {};
          this.cpSync = notImplemented;
          this.lutimesSync = notImplemented;
          this.statfsSync = notImplemented;
          this.opendirSync = notImplemented;
          this.cp = notImplemented;
          this.lutimes = notImplemented;
          this.statfs = notImplemented;
          this.openAsBlob = notImplemented;
          this.opendir = notImplemented;
          this.props = Object.assign(
            { Node: node_1.Node, Link: node_1.Link, File: node_1.File },
            props,
          );
          const root = this.createLink();
          root.setNode(this.createNode(true));
          const self = this;
          this.StatWatcher = class extends StatWatcher {
            constructor() {
              super(self);
            }
          };
          const _ReadStream = FsReadStream;
          this.ReadStream = class extends _ReadStream {
            constructor(...args) {
              super(self, ...args);
            }
          };
          const _WriteStream = FsWriteStream;
          this.WriteStream = class extends _WriteStream {
            constructor(...args) {
              super(self, ...args);
            }
          };
          this.FSWatcher = class extends FSWatcher {
            constructor() {
              super(self);
            }
          };
          root.setChild(".", root);
          root.getNode().nlink++;
          root.setChild("..", root);
          root.getNode().nlink++;
          this.root = root;
        }
        createLink(parent, name, isDirectory = false, perm) {
          if (!parent) {
            return new this.props.Link(this, null, "");
          }
          if (!name) {
            throw new Error("createLink: name cannot be empty");
          }
          return parent.createChild(name, this.createNode(isDirectory, perm));
        }
        deleteLink(link) {
          const parent = link.parent;
          if (parent) {
            parent.deleteChild(link);
            return true;
          }
          return false;
        }
        newInoNumber() {
          const releasedFd = this.releasedInos.pop();
          if (releasedFd) return releasedFd;
          else {
            this.ino = (this.ino + 1) % 4294967295;
            return this.ino;
          }
        }
        newFdNumber() {
          const releasedFd = this.releasedFds.pop();
          return typeof releasedFd === "number" ? releasedFd : Volume.fd--;
        }
        createNode(isDirectory = false, perm) {
          const node = new this.props.Node(this.newInoNumber(), perm);
          if (isDirectory) node.setIsDirectory();
          this.inodes[node.ino] = node;
          return node;
        }
        deleteNode(node) {
          node.del();
          delete this.inodes[node.ino];
          this.releasedInos.push(node.ino);
        }
        getLink(steps) {
          return this.root.walk(steps);
        }
        getLinkOrThrow(filename, funcName) {
          const steps = filenameToSteps(filename);
          const link = this.getLink(steps);
          if (!link) throw (0, util_1.createError)(ENOENT, funcName, filename);
          return link;
        }
        getResolvedLink(filenameOrSteps) {
          let steps =
            typeof filenameOrSteps === "string"
              ? filenameToSteps(filenameOrSteps)
              : filenameOrSteps;
          let link = this.root;
          let i = 0;
          while (i < steps.length) {
            const step = steps[i];
            link = link.getChild(step);
            if (!link) return null;
            const node = link.getNode();
            if (node.isSymlink()) {
              steps = node.symlink.concat(steps.slice(i + 1));
              link = this.root;
              i = 0;
              continue;
            }
            i++;
          }
          return link;
        }
        getResolvedLinkOrThrow(filename, funcName) {
          const link = this.getResolvedLink(filename);
          if (!link) throw (0, util_1.createError)(ENOENT, funcName, filename);
          return link;
        }
        resolveSymlinks(link) {
          return this.getResolvedLink(link.steps.slice(1));
        }
        getLinkAsDirOrThrow(filename, funcName) {
          const link = this.getLinkOrThrow(filename, funcName);
          if (!link.getNode().isDirectory())
            throw (0, util_1.createError)(ENOTDIR, funcName, filename);
          return link;
        }
        getLinkParent(steps) {
          return this.root.walk(steps, steps.length - 1);
        }
        getLinkParentAsDirOrThrow(filenameOrSteps, funcName) {
          const steps =
            filenameOrSteps instanceof Array
              ? filenameOrSteps
              : filenameToSteps(filenameOrSteps);
          const link = this.getLinkParent(steps);
          if (!link)
            throw (0, util_1.createError)(
              ENOENT,
              funcName,
              sep + steps.join(sep),
            );
          if (!link.getNode().isDirectory())
            throw (0, util_1.createError)(
              ENOTDIR,
              funcName,
              sep + steps.join(sep),
            );
          return link;
        }
        getFileByFd(fd) {
          return this.fds[String(fd)];
        }
        getFileByFdOrThrow(fd, funcName) {
          if (!(0, util_1.isFd)(fd)) throw TypeError(constants_2.ERRSTR.FD);
          const file = this.getFileByFd(fd);
          if (!file) throw (0, util_1.createError)(EBADF, funcName);
          return file;
        }
        wrapAsync(method, args, callback) {
          (0, util_1.validateCallback)(callback);
          (0, setImmediate_1.default)(() => {
            let result;
            try {
              result = method.apply(this, args);
            } catch (err) {
              callback(err);
              return;
            }
            callback(null, result);
          });
        }
        _toJSON(link = this.root, json = {}, path, asBuffer) {
          let isEmpty = true;
          let children = link.children;
          if (link.getNode().isFile()) {
            children = new Map([
              [link.getName(), link.parent.getChild(link.getName())],
            ]);
            link = link.parent;
          }
          for (const name of children.keys()) {
            if (name === "." || name === "..") {
              continue;
            }
            isEmpty = false;
            const child = link.getChild(name);
            if (!child) {
              throw new Error("_toJSON: unexpected undefined");
            }
            const node = child.getNode();
            if (node.isFile()) {
              let filename = child.getPath();
              if (path) filename = relative(path, filename);
              json[filename] = asBuffer ? node.getBuffer() : node.getString();
            } else if (node.isDirectory()) {
              this._toJSON(child, json, path);
            }
          }
          let dirPath = link.getPath();
          if (path) dirPath = relative(path, dirPath);
          if (dirPath && isEmpty) {
            json[dirPath] = null;
          }
          return json;
        }
        toJSON(paths, json = {}, isRelative = false, asBuffer = false) {
          const links = [];
          if (paths) {
            if (!Array.isArray(paths)) paths = [paths];
            for (const path of paths) {
              const filename = (0, util_1.pathToFilename)(path);
              const link = this.getResolvedLink(filename);
              if (!link) continue;
              links.push(link);
            }
          } else {
            links.push(this.root);
          }
          if (!links.length) return json;
          for (const link of links)
            this._toJSON(
              link,
              json,
              isRelative ? link.getPath() : "",
              asBuffer,
            );
          return json;
        }
        fromJSON(json, cwd = process_1.default.cwd()) {
          for (let filename in json) {
            const data = json[filename];
            filename = resolve(filename, cwd);
            if (typeof data === "string" || data instanceof buffer_1.Buffer) {
              const dir = dirname(filename);
              this.mkdirpBase(dir, 511);
              this.writeFileSync(filename, data);
            } else {
              this.mkdirpBase(filename, 511);
            }
          }
        }
        fromNestedJSON(json, cwd) {
          this.fromJSON(flattenJSON(json), cwd);
        }
        toTree(opts = { separator: sep }) {
          return (0, print_1.toTreeSync)(this, opts);
        }
        reset() {
          this.ino = 0;
          this.inodes = {};
          this.releasedInos = [];
          this.fds = {};
          this.releasedFds = [];
          this.openFiles = 0;
          this.root = this.createLink();
          this.root.setNode(this.createNode(true));
        }
        mountSync(mountpoint, json) {
          this.fromJSON(json, mountpoint);
        }
        openLink(link, flagsNum, resolveSymlinks = true) {
          if (this.openFiles >= this.maxFiles) {
            throw (0, util_1.createError)(EMFILE, "open", link.getPath());
          }
          let realLink = link;
          if (resolveSymlinks) realLink = this.resolveSymlinks(link);
          if (!realLink)
            throw (0, util_1.createError)(ENOENT, "open", link.getPath());
          const node = realLink.getNode();
          if (node.isDirectory()) {
            if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
              throw (0, util_1.createError)(EISDIR, "open", link.getPath());
          } else {
            if (flagsNum & O_DIRECTORY)
              throw (0, util_1.createError)(ENOTDIR, "open", link.getPath());
          }
          if (!(flagsNum & O_WRONLY)) {
            if (!node.canRead()) {
              throw (0, util_1.createError)(EACCES, "open", link.getPath());
            }
          }
          if (flagsNum & O_RDWR) {
          }
          const file = new this.props.File(
            link,
            node,
            flagsNum,
            this.newFdNumber(),
          );
          this.fds[file.fd] = file;
          this.openFiles++;
          if (flagsNum & O_TRUNC) file.truncate();
          return file;
        }
        openFile(filename, flagsNum, modeNum, resolveSymlinks = true) {
          const steps = filenameToSteps(filename);
          let link = resolveSymlinks
            ? this.getResolvedLink(steps)
            : this.getLink(steps);
          if (link && flagsNum & O_EXCL)
            throw (0, util_1.createError)(EEXIST, "open", filename);
          if (!link && flagsNum & O_CREAT) {
            const dirLink = this.getResolvedLink(
              steps.slice(0, steps.length - 1),
            );
            if (!dirLink)
              throw (0, util_1.createError)(
                ENOENT,
                "open",
                sep + steps.join(sep),
              );
            if (flagsNum & O_CREAT && typeof modeNum === "number") {
              link = this.createLink(
                dirLink,
                steps[steps.length - 1],
                false,
                modeNum,
              );
            }
          }
          if (link) return this.openLink(link, flagsNum, resolveSymlinks);
          throw (0, util_1.createError)(ENOENT, "open", filename);
        }
        openBase(filename, flagsNum, modeNum, resolveSymlinks = true) {
          const file = this.openFile(
            filename,
            flagsNum,
            modeNum,
            resolveSymlinks,
          );
          if (!file) throw (0, util_1.createError)(ENOENT, "open", filename);
          return file.fd;
        }
        openSync(path, flags, mode = 438) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const fileName = (0, util_1.pathToFilename)(path);
          const flagsNum = (0, util_1.flagsToNumber)(flags);
          return this.openBase(
            fileName,
            flagsNum,
            modeNum,
            !(flagsNum & O_SYMLINK),
          );
        }
        open(path, flags, a, b) {
          let mode = a;
          let callback = b;
          if (typeof a === "function") {
            mode = 438;
            callback = a;
          }
          mode = mode || 438;
          const modeNum = (0, util_1.modeToNumber)(mode);
          const fileName = (0, util_1.pathToFilename)(path);
          const flagsNum = (0, util_1.flagsToNumber)(flags);
          this.wrapAsync(
            this.openBase,
            [fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK)],
            callback,
          );
        }
        closeFile(file) {
          if (!this.fds[file.fd]) return;
          this.openFiles--;
          delete this.fds[file.fd];
          this.releasedFds.push(file.fd);
        }
        closeSync(fd) {
          (0, util_1.validateFd)(fd);
          const file = this.getFileByFdOrThrow(fd, "close");
          this.closeFile(file);
        }
        close(fd, callback) {
          (0, util_1.validateFd)(fd);
          this.wrapAsync(this.closeSync, [fd], callback);
        }
        openFileOrGetById(id, flagsNum, modeNum) {
          if (typeof id === "number") {
            const file = this.fds[id];
            if (!file) throw (0, util_1.createError)(ENOENT);
            return file;
          } else {
            return this.openFile(
              (0, util_1.pathToFilename)(id),
              flagsNum,
              modeNum,
            );
          }
        }
        readBase(fd, buffer, offset, length, position) {
          if (buffer.byteLength < length) {
            throw (0, util_1.createError)(
              ERR_OUT_OF_RANGE,
              "read",
              undefined,
              undefined,
              RangeError,
            );
          }
          const file = this.getFileByFdOrThrow(fd);
          if (file.node.isSymlink()) {
            throw (0, util_1.createError)(EPERM, "read", file.link.getPath());
          }
          return file.read(
            buffer,
            Number(offset),
            Number(length),
            position === -1 || typeof position !== "number"
              ? undefined
              : position,
          );
        }
        readSync(fd, buffer, offset, length, position) {
          (0, util_1.validateFd)(fd);
          return this.readBase(fd, buffer, offset, length, position);
        }
        read(fd, buffer, offset, length, position, callback) {
          (0, util_1.validateCallback)(callback);
          if (length === 0) {
            return (0, queueMicrotask_1.default)(() => {
              if (callback) callback(null, 0, buffer);
            });
          }
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.readBase(fd, buffer, offset, length, position);
              callback(null, bytes, buffer);
            } catch (err) {
              callback(err);
            }
          });
        }
        readvBase(fd, buffers, position) {
          const file = this.getFileByFdOrThrow(fd);
          let p =
            position !== null && position !== void 0 ? position : undefined;
          if (p === -1) {
            p = undefined;
          }
          let bytesRead = 0;
          for (const buffer of buffers) {
            const bytes = file.read(buffer, 0, buffer.byteLength, p);
            p = undefined;
            bytesRead += bytes;
            if (bytes < buffer.byteLength) break;
          }
          return bytesRead;
        }
        readv(fd, buffers, a, b) {
          let position = a;
          let callback = b;
          if (typeof a === "function") {
            position = null;
            callback = a;
          }
          (0, util_1.validateCallback)(callback);
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.readvBase(fd, buffers, position);
              callback(null, bytes, buffers);
            } catch (err) {
              callback(err);
            }
          });
        }
        readvSync(fd, buffers, position) {
          (0, util_1.validateFd)(fd);
          return this.readvBase(fd, buffers, position);
        }
        readFileBase(id, flagsNum, encoding) {
          let result;
          const isUserFd = typeof id === "number";
          const userOwnsFd = isUserFd && (0, util_1.isFd)(id);
          let fd;
          if (userOwnsFd) fd = id;
          else {
            const filename = (0, util_1.pathToFilename)(id);
            const steps = filenameToSteps(filename);
            const link = this.getResolvedLink(steps);
            if (link) {
              const node = link.getNode();
              if (node.isDirectory())
                throw (0, util_1.createError)(EISDIR, "open", link.getPath());
            }
            fd = this.openSync(id, flagsNum);
          }
          try {
            result = (0, util_1.bufferToEncoding)(
              this.getFileByFdOrThrow(fd).getBuffer(),
              encoding,
            );
          } finally {
            if (!userOwnsFd) {
              this.closeSync(fd);
            }
          }
          return result;
        }
        readFileSync(file, options) {
          const opts = (0, options_1.getReadFileOptions)(options);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          return this.readFileBase(file, flagsNum, opts.encoding);
        }
        readFile(id, a, b) {
          const [opts, callback] = (0, options_1.optsAndCbGenerator)(
            options_1.getReadFileOptions,
          )(a, b);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          this.wrapAsync(
            this.readFileBase,
            [id, flagsNum, opts.encoding],
            callback,
          );
        }
        writeBase(fd, buf, offset, length, position) {
          const file = this.getFileByFdOrThrow(fd, "write");
          if (file.node.isSymlink()) {
            throw (0, util_1.createError)(EBADF, "write", file.link.getPath());
          }
          return file.write(
            buf,
            offset,
            length,
            position === -1 || typeof position !== "number"
              ? undefined
              : position,
          );
        }
        writeSync(fd, a, b, c, d) {
          const [, buf, offset, length, position] = (0,
          util_1.getWriteSyncArgs)(fd, a, b, c, d);
          return this.writeBase(fd, buf, offset, length, position);
        }
        write(fd, a, b, c, d, e) {
          const [, asStr, buf, offset, length, position, cb] = (0,
          util_1.getWriteArgs)(fd, a, b, c, d, e);
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.writeBase(fd, buf, offset, length, position);
              if (!asStr) {
                cb(null, bytes, buf);
              } else {
                cb(null, bytes, a);
              }
            } catch (err) {
              cb(err);
            }
          });
        }
        writevBase(fd, buffers, position) {
          const file = this.getFileByFdOrThrow(fd);
          let p =
            position !== null && position !== void 0 ? position : undefined;
          if (p === -1) {
            p = undefined;
          }
          let bytesWritten = 0;
          for (const buffer of buffers) {
            const nodeBuf = buffer_1.Buffer.from(
              buffer.buffer,
              buffer.byteOffset,
              buffer.byteLength,
            );
            const bytes = file.write(nodeBuf, 0, nodeBuf.byteLength, p);
            p = undefined;
            bytesWritten += bytes;
            if (bytes < nodeBuf.byteLength) break;
          }
          return bytesWritten;
        }
        writev(fd, buffers, a, b) {
          let position = a;
          let callback = b;
          if (typeof a === "function") {
            position = null;
            callback = a;
          }
          (0, util_1.validateCallback)(callback);
          (0, setImmediate_1.default)(() => {
            try {
              const bytes = this.writevBase(fd, buffers, position);
              callback(null, bytes, buffers);
            } catch (err) {
              callback(err);
            }
          });
        }
        writevSync(fd, buffers, position) {
          (0, util_1.validateFd)(fd);
          return this.writevBase(fd, buffers, position);
        }
        writeFileBase(id, buf, flagsNum, modeNum) {
          const isUserFd = typeof id === "number";
          let fd;
          if (isUserFd) fd = id;
          else {
            fd = this.openBase(
              (0, util_1.pathToFilename)(id),
              flagsNum,
              modeNum,
            );
          }
          let offset = 0;
          let length = buf.length;
          let position = flagsNum & O_APPEND ? undefined : 0;
          try {
            while (length > 0) {
              const written = this.writeSync(fd, buf, offset, length, position);
              offset += written;
              length -= written;
              if (position !== undefined) position += written;
            }
          } finally {
            if (!isUserFd) this.closeSync(fd);
          }
        }
        writeFileSync(id, data, options) {
          const opts = (0, options_1.getWriteFileOptions)(options);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          const modeNum = (0, util_1.modeToNumber)(opts.mode);
          const buf = (0, util_1.dataToBuffer)(data, opts.encoding);
          this.writeFileBase(id, buf, flagsNum, modeNum);
        }
        writeFile(id, data, a, b) {
          let options = a;
          let callback = b;
          if (typeof a === "function") {
            options = options_1.writeFileDefaults;
            callback = a;
          }
          const cb = (0, util_1.validateCallback)(callback);
          const opts = (0, options_1.getWriteFileOptions)(options);
          const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
          const modeNum = (0, util_1.modeToNumber)(opts.mode);
          const buf = (0, util_1.dataToBuffer)(data, opts.encoding);
          this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
        }
        linkBase(filename1, filename2) {
          const steps1 = filenameToSteps(filename1);
          const link1 = this.getLink(steps1);
          if (!link1)
            throw (0, util_1.createError)(ENOENT, "link", filename1, filename2);
          const steps2 = filenameToSteps(filename2);
          const dir2 = this.getLinkParent(steps2);
          if (!dir2)
            throw (0, util_1.createError)(ENOENT, "link", filename1, filename2);
          const name = steps2[steps2.length - 1];
          if (dir2.getChild(name))
            throw (0, util_1.createError)(EEXIST, "link", filename1, filename2);
          const node = link1.getNode();
          node.nlink++;
          dir2.createChild(name, node);
        }
        copyFileBase(src, dest, flags) {
          const buf = this.readFileSync(src);
          if (flags & COPYFILE_EXCL) {
            if (this.existsSync(dest)) {
              throw (0, util_1.createError)(EEXIST, "copyFile", src, dest);
            }
          }
          if (flags & COPYFILE_FICLONE_FORCE) {
            throw (0, util_1.createError)(ENOSYS, "copyFile", src, dest);
          }
          this.writeFileBase(dest, buf, constants_2.FLAGS.w, 438);
        }
        copyFileSync(src, dest, flags) {
          const srcFilename = (0, util_1.pathToFilename)(src);
          const destFilename = (0, util_1.pathToFilename)(dest);
          return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
        }
        copyFile(src, dest, a, b) {
          const srcFilename = (0, util_1.pathToFilename)(src);
          const destFilename = (0, util_1.pathToFilename)(dest);
          let flags;
          let callback;
          if (typeof a === "function") {
            flags = 0;
            callback = a;
          } else {
            flags = a;
            callback = b;
          }
          (0, util_1.validateCallback)(callback);
          this.wrapAsync(
            this.copyFileBase,
            [srcFilename, destFilename, flags],
            callback,
          );
        }
        linkSync(existingPath, newPath) {
          const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.linkBase(existingPathFilename, newPathFilename);
        }
        link(existingPath, newPath, callback) {
          const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.wrapAsync(
            this.linkBase,
            [existingPathFilename, newPathFilename],
            callback,
          );
        }
        unlinkBase(filename) {
          const steps = filenameToSteps(filename);
          const link = this.getLink(steps);
          if (!link) throw (0, util_1.createError)(ENOENT, "unlink", filename);
          if (link.length) throw Error("Dir not empty...");
          this.deleteLink(link);
          const node = link.getNode();
          node.nlink--;
          if (node.nlink <= 0) {
            this.deleteNode(node);
          }
        }
        unlinkSync(path) {
          const filename = (0, util_1.pathToFilename)(path);
          this.unlinkBase(filename);
        }
        unlink(path, callback) {
          const filename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(this.unlinkBase, [filename], callback);
        }
        symlinkBase(targetFilename, pathFilename) {
          const pathSteps = filenameToSteps(pathFilename);
          const dirLink = this.getLinkParent(pathSteps);
          if (!dirLink)
            throw (0, util_1.createError)(
              ENOENT,
              "symlink",
              targetFilename,
              pathFilename,
            );
          const name = pathSteps[pathSteps.length - 1];
          if (dirLink.getChild(name))
            throw (0, util_1.createError)(
              EEXIST,
              "symlink",
              targetFilename,
              pathFilename,
            );
          const symlink = dirLink.createChild(name);
          symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
          return symlink;
        }
        symlinkSync(target, path, type) {
          const targetFilename = (0, util_1.pathToFilename)(target);
          const pathFilename = (0, util_1.pathToFilename)(path);
          this.symlinkBase(targetFilename, pathFilename);
        }
        symlink(target, path, a, b) {
          const callback = (0, util_1.validateCallback)(
            typeof a === "function" ? a : b,
          );
          const targetFilename = (0, util_1.pathToFilename)(target);
          const pathFilename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(
            this.symlinkBase,
            [targetFilename, pathFilename],
            callback,
          );
        }
        realpathBase(filename, encoding) {
          const steps = filenameToSteps(filename);
          const realLink = this.getResolvedLink(steps);
          if (!realLink)
            throw (0, util_1.createError)(ENOENT, "realpath", filename);
          return (0, encoding_1.strToEncoding)(
            realLink.getPath() || "/",
            encoding,
          );
        }
        realpathSync(path, options) {
          return this.realpathBase(
            (0, util_1.pathToFilename)(path),
            (0, options_1.getRealpathOptions)(options).encoding,
          );
        }
        realpath(path, a, b) {
          const [opts, callback] = (0, options_1.getRealpathOptsAndCb)(a, b);
          const pathFilename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(
            this.realpathBase,
            [pathFilename, opts.encoding],
            callback,
          );
        }
        lstatBase(filename, bigint = false, throwIfNoEntry = false) {
          const link = this.getLink(filenameToSteps(filename));
          if (link) {
            return Stats_1.default.build(link.getNode(), bigint);
          } else if (!throwIfNoEntry) {
            return undefined;
          } else {
            throw (0, util_1.createError)(ENOENT, "lstat", filename);
          }
        }
        lstatSync(path, options) {
          const { throwIfNoEntry = true, bigint = false } = (0,
          options_1.getStatOptions)(options);
          return this.lstatBase(
            (0, util_1.pathToFilename)(path),
            bigint,
            throwIfNoEntry,
          );
        }
        lstat(path, a, b) {
          const [{ throwIfNoEntry = true, bigint = false }, callback] = (0,
          options_1.getStatOptsAndCb)(a, b);
          this.wrapAsync(
            this.lstatBase,
            [(0, util_1.pathToFilename)(path), bigint, throwIfNoEntry],
            callback,
          );
        }
        statBase(filename, bigint = false, throwIfNoEntry = true) {
          const link = this.getResolvedLink(filenameToSteps(filename));
          if (link) {
            return Stats_1.default.build(link.getNode(), bigint);
          } else if (!throwIfNoEntry) {
            return undefined;
          } else {
            throw (0, util_1.createError)(ENOENT, "stat", filename);
          }
        }
        statSync(path, options) {
          const { bigint = true, throwIfNoEntry = true } = (0,
          options_1.getStatOptions)(options);
          return this.statBase(
            (0, util_1.pathToFilename)(path),
            bigint,
            throwIfNoEntry,
          );
        }
        stat(path, a, b) {
          const [{ bigint = false, throwIfNoEntry = true }, callback] = (0,
          options_1.getStatOptsAndCb)(a, b);
          this.wrapAsync(
            this.statBase,
            [(0, util_1.pathToFilename)(path), bigint, throwIfNoEntry],
            callback,
          );
        }
        fstatBase(fd, bigint = false) {
          const file = this.getFileByFd(fd);
          if (!file) throw (0, util_1.createError)(EBADF, "fstat");
          return Stats_1.default.build(file.node, bigint);
        }
        fstatSync(fd, options) {
          return this.fstatBase(
            fd,
            (0, options_1.getStatOptions)(options).bigint,
          );
        }
        fstat(fd, a, b) {
          const [opts, callback] = (0, options_1.getStatOptsAndCb)(a, b);
          this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
        }
        renameBase(oldPathFilename, newPathFilename) {
          const link = this.getLink(filenameToSteps(oldPathFilename));
          if (!link)
            throw (0, util_1.createError)(
              ENOENT,
              "rename",
              oldPathFilename,
              newPathFilename,
            );
          const newPathSteps = filenameToSteps(newPathFilename);
          const newPathDirLink = this.getLinkParent(newPathSteps);
          if (!newPathDirLink)
            throw (0, util_1.createError)(
              ENOENT,
              "rename",
              oldPathFilename,
              newPathFilename,
            );
          const oldLinkParent = link.parent;
          if (oldLinkParent) {
            oldLinkParent.deleteChild(link);
          }
          const name = newPathSteps[newPathSteps.length - 1];
          link.name = name;
          link.steps = [...newPathDirLink.steps, name];
          newPathDirLink.setChild(link.getName(), link);
        }
        renameSync(oldPath, newPath) {
          const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.renameBase(oldPathFilename, newPathFilename);
        }
        rename(oldPath, newPath, callback) {
          const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
          const newPathFilename = (0, util_1.pathToFilename)(newPath);
          this.wrapAsync(
            this.renameBase,
            [oldPathFilename, newPathFilename],
            callback,
          );
        }
        existsBase(filename) {
          return !!this.statBase(filename);
        }
        existsSync(path) {
          try {
            return this.existsBase((0, util_1.pathToFilename)(path));
          } catch (err) {
            return false;
          }
        }
        exists(path, callback) {
          const filename = (0, util_1.pathToFilename)(path);
          if (typeof callback !== "function")
            throw Error(constants_2.ERRSTR.CB);
          (0, setImmediate_1.default)(() => {
            try {
              callback(this.existsBase(filename));
            } catch (err) {
              callback(false);
            }
          });
        }
        accessBase(filename, mode) {
          const link = this.getLinkOrThrow(filename, "access");
        }
        accessSync(path, mode = F_OK) {
          const filename = (0, util_1.pathToFilename)(path);
          mode = mode | 0;
          this.accessBase(filename, mode);
        }
        access(path, a, b) {
          let mode = F_OK;
          let callback;
          if (typeof a !== "function") {
            mode = a | 0;
            callback = (0, util_1.validateCallback)(b);
          } else {
            callback = a;
          }
          const filename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(this.accessBase, [filename, mode], callback);
        }
        appendFileSync(id, data, options) {
          const opts = (0, options_1.getAppendFileOpts)(options);
          if (!opts.flag || (0, util_1.isFd)(id)) opts.flag = "a";
          this.writeFileSync(id, data, opts);
        }
        appendFile(id, data, a, b) {
          const [opts, callback] = (0, options_1.getAppendFileOptsAndCb)(a, b);
          if (!opts.flag || (0, util_1.isFd)(id)) opts.flag = "a";
          this.writeFile(id, data, opts, callback);
        }
        readdirBase(filename, options) {
          const steps = filenameToSteps(filename);
          const link = this.getResolvedLink(steps);
          if (!link) throw (0, util_1.createError)(ENOENT, "readdir", filename);
          const node = link.getNode();
          if (!node.isDirectory())
            throw (0, util_1.createError)(ENOTDIR, "scandir", filename);
          const list = [];
          for (const name of link.children.keys()) {
            const child = link.getChild(name);
            if (!child || name === "." || name === "..") continue;
            list.push(Dirent_1.default.build(child, options.encoding));
            if (options.recursive && child.children.size) {
              const recurseOptions = Object.assign(Object.assign({}, options), {
                recursive: true,
                withFileTypes: true,
              });
              const childList = this.readdirBase(
                child.getPath(),
                recurseOptions,
              );
              list.push(...childList);
            }
          }
          if (!util_1.isWin && options.encoding !== "buffer")
            list.sort((a, b) => {
              if (a.name < b.name) return -1;
              if (a.name > b.name) return 1;
              return 0;
            });
          if (options.withFileTypes) return list;
          let filename2 = filename;
          if (util_1.isWin) {
            filename2 = filename2.replace(/\\/g, "/");
          }
          return list.map((dirent) => {
            if (options.recursive) {
              let fullPath = pathModule.join(
                dirent.path,
                dirent.name.toString(),
              );
              if (util_1.isWin) {
                fullPath = fullPath.replace(/\\/g, "/");
              }
              return fullPath.replace(filename2 + pathModule.posix.sep, "");
            }
            return dirent.name;
          });
        }
        readdirSync(path, options) {
          const opts = (0, options_1.getReaddirOptions)(options);
          const filename = (0, util_1.pathToFilename)(path);
          return this.readdirBase(filename, opts);
        }
        readdir(path, a, b) {
          const [options, callback] = (0, options_1.getReaddirOptsAndCb)(a, b);
          const filename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(this.readdirBase, [filename, options], callback);
        }
        readlinkBase(filename, encoding) {
          const link = this.getLinkOrThrow(filename, "readlink");
          const node = link.getNode();
          if (!node.isSymlink())
            throw (0, util_1.createError)(EINVAL, "readlink", filename);
          const str = sep + node.symlink.join(sep);
          return (0, encoding_1.strToEncoding)(str, encoding);
        }
        readlinkSync(path, options) {
          const opts = (0, options_1.getDefaultOpts)(options);
          const filename = (0, util_1.pathToFilename)(path);
          return this.readlinkBase(filename, opts.encoding);
        }
        readlink(path, a, b) {
          const [opts, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);
          const filename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(
            this.readlinkBase,
            [filename, opts.encoding],
            callback,
          );
        }
        fsyncBase(fd) {
          this.getFileByFdOrThrow(fd, "fsync");
        }
        fsyncSync(fd) {
          this.fsyncBase(fd);
        }
        fsync(fd, callback) {
          this.wrapAsync(this.fsyncBase, [fd], callback);
        }
        fdatasyncBase(fd) {
          this.getFileByFdOrThrow(fd, "fdatasync");
        }
        fdatasyncSync(fd) {
          this.fdatasyncBase(fd);
        }
        fdatasync(fd, callback) {
          this.wrapAsync(this.fdatasyncBase, [fd], callback);
        }
        ftruncateBase(fd, len) {
          const file = this.getFileByFdOrThrow(fd, "ftruncate");
          file.truncate(len);
        }
        ftruncateSync(fd, len) {
          this.ftruncateBase(fd, len);
        }
        ftruncate(fd, a, b) {
          const len = typeof a === "number" ? a : 0;
          const callback = (0, util_1.validateCallback)(
            typeof a === "number" ? b : a,
          );
          this.wrapAsync(this.ftruncateBase, [fd, len], callback);
        }
        truncateBase(path, len) {
          const fd = this.openSync(path, "r+");
          try {
            this.ftruncateSync(fd, len);
          } finally {
            this.closeSync(fd);
          }
        }
        truncateSync(id, len) {
          if ((0, util_1.isFd)(id)) return this.ftruncateSync(id, len);
          this.truncateBase(id, len);
        }
        truncate(id, a, b) {
          const len = typeof a === "number" ? a : 0;
          const callback = (0, util_1.validateCallback)(
            typeof a === "number" ? b : a,
          );
          if ((0, util_1.isFd)(id)) return this.ftruncate(id, len, callback);
          this.wrapAsync(this.truncateBase, [id, len], callback);
        }
        futimesBase(fd, atime, mtime) {
          const file = this.getFileByFdOrThrow(fd, "futimes");
          const node = file.node;
          node.atime = new Date(atime * 1e3);
          node.mtime = new Date(mtime * 1e3);
        }
        futimesSync(fd, atime, mtime) {
          this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
        }
        futimes(fd, atime, mtime, callback) {
          this.wrapAsync(
            this.futimesBase,
            [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)],
            callback,
          );
        }
        utimesBase(filename, atime, mtime) {
          const fd = this.openSync(filename, "r");
          try {
            this.futimesBase(fd, atime, mtime);
          } finally {
            this.closeSync(fd);
          }
        }
        utimesSync(path, atime, mtime) {
          this.utimesBase(
            (0, util_1.pathToFilename)(path),
            toUnixTimestamp(atime),
            toUnixTimestamp(mtime),
          );
        }
        utimes(path, atime, mtime, callback) {
          this.wrapAsync(
            this.utimesBase,
            [
              (0, util_1.pathToFilename)(path),
              toUnixTimestamp(atime),
              toUnixTimestamp(mtime),
            ],
            callback,
          );
        }
        mkdirBase(filename, modeNum) {
          const steps = filenameToSteps(filename);
          if (!steps.length) {
            throw (0, util_1.createError)(EEXIST, "mkdir", filename);
          }
          const dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
          const name = steps[steps.length - 1];
          if (dir.getChild(name))
            throw (0, util_1.createError)(EEXIST, "mkdir", filename);
          dir.createChild(name, this.createNode(true, modeNum));
        }
        mkdirpBase(filename, modeNum) {
          const fullPath = resolve(filename);
          const fullPathSansSlash = fullPath.substring(1);
          const steps = !fullPathSansSlash ? [] : fullPathSansSlash.split(sep);
          let link = this.root;
          let created = false;
          for (let i = 0; i < steps.length; i++) {
            const step = steps[i];
            if (!link.getNode().isDirectory())
              throw (0, util_1.createError)(ENOTDIR, "mkdir", link.getPath());
            const child = link.getChild(step);
            if (child) {
              if (child.getNode().isDirectory()) link = child;
              else
                throw (0, util_1.createError)(
                  ENOTDIR,
                  "mkdir",
                  child.getPath(),
                );
            } else {
              link = link.createChild(step, this.createNode(true, modeNum));
              created = true;
            }
          }
          return created ? fullPath : undefined;
        }
        mkdirSync(path, options) {
          const opts = (0, options_1.getMkdirOptions)(options);
          const modeNum = (0, util_1.modeToNumber)(opts.mode, 511);
          const filename = (0, util_1.pathToFilename)(path);
          if (opts.recursive) return this.mkdirpBase(filename, modeNum);
          this.mkdirBase(filename, modeNum);
        }
        mkdir(path, a, b) {
          const opts = (0, options_1.getMkdirOptions)(a);
          const callback = (0, util_1.validateCallback)(
            typeof a === "function" ? a : b,
          );
          const modeNum = (0, util_1.modeToNumber)(opts.mode, 511);
          const filename = (0, util_1.pathToFilename)(path);
          if (opts.recursive)
            this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
          else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
        }
        mkdtempBase(prefix, encoding, retry = 5) {
          const filename = prefix + (0, util_1.genRndStr6)();
          try {
            this.mkdirBase(filename, 511);
            return (0, encoding_1.strToEncoding)(filename, encoding);
          } catch (err) {
            if (err.code === EEXIST) {
              if (retry > 1)
                return this.mkdtempBase(prefix, encoding, retry - 1);
              else throw Error("Could not create temp dir.");
            } else throw err;
          }
        }
        mkdtempSync(prefix, options) {
          const { encoding } = (0, options_1.getDefaultOpts)(options);
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          (0, util_1.nullCheck)(prefix);
          return this.mkdtempBase(prefix, encoding);
        }
        mkdtemp(prefix, a, b) {
          const [{ encoding }, callback] = (0, options_1.getDefaultOptsAndCb)(
            a,
            b,
          );
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          if (!(0, util_1.nullCheck)(prefix)) return;
          this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
        }
        rmdirBase(filename, options) {
          const opts = (0, options_1.getRmdirOptions)(options);
          const link = this.getLinkAsDirOrThrow(filename, "rmdir");
          if (link.length && !opts.recursive)
            throw (0, util_1.createError)(ENOTEMPTY, "rmdir", filename);
          this.deleteLink(link);
        }
        rmdirSync(path, options) {
          this.rmdirBase((0, util_1.pathToFilename)(path), options);
        }
        rmdir(path, a, b) {
          const opts = (0, options_1.getRmdirOptions)(a);
          const callback = (0, util_1.validateCallback)(
            typeof a === "function" ? a : b,
          );
          this.wrapAsync(
            this.rmdirBase,
            [(0, util_1.pathToFilename)(path), opts],
            callback,
          );
        }
        rmBase(filename, options = {}) {
          const link = this.getResolvedLink(filename);
          if (!link) {
            if (!options.force)
              throw (0, util_1.createError)(ENOENT, "stat", filename);
            return;
          }
          if (link.getNode().isDirectory()) {
            if (!options.recursive) {
              throw (0, util_1.createError)(ERR_FS_EISDIR, "rm", filename);
            }
          }
          this.deleteLink(link);
        }
        rmSync(path, options) {
          this.rmBase((0, util_1.pathToFilename)(path), options);
        }
        rm(path, a, b) {
          const [opts, callback] = (0, options_1.getRmOptsAndCb)(a, b);
          this.wrapAsync(
            this.rmBase,
            [(0, util_1.pathToFilename)(path), opts],
            callback,
          );
        }
        fchmodBase(fd, modeNum) {
          const file = this.getFileByFdOrThrow(fd, "fchmod");
          file.chmod(modeNum);
        }
        fchmodSync(fd, mode) {
          this.fchmodBase(fd, (0, util_1.modeToNumber)(mode));
        }
        fchmod(fd, mode, callback) {
          this.wrapAsync(
            this.fchmodBase,
            [fd, (0, util_1.modeToNumber)(mode)],
            callback,
          );
        }
        chmodBase(filename, modeNum) {
          const fd = this.openSync(filename, "r");
          try {
            this.fchmodBase(fd, modeNum);
          } finally {
            this.closeSync(fd);
          }
        }
        chmodSync(path, mode) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path);
          this.chmodBase(filename, modeNum);
        }
        chmod(path, mode, callback) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
        }
        lchmodBase(filename, modeNum) {
          const fd = this.openBase(filename, O_RDWR, 0, false);
          try {
            this.fchmodBase(fd, modeNum);
          } finally {
            this.closeSync(fd);
          }
        }
        lchmodSync(path, mode) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path);
          this.lchmodBase(filename, modeNum);
        }
        lchmod(path, mode, callback) {
          const modeNum = (0, util_1.modeToNumber)(mode);
          const filename = (0, util_1.pathToFilename)(path);
          this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
        }
        fchownBase(fd, uid, gid) {
          this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
        }
        fchownSync(fd, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.fchownBase(fd, uid, gid);
        }
        fchown(fd, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
        }
        chownBase(filename, uid, gid) {
          const link = this.getResolvedLinkOrThrow(filename, "chown");
          const node = link.getNode();
          node.chown(uid, gid);
        }
        chownSync(path, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.chownBase((0, util_1.pathToFilename)(path), uid, gid);
        }
        chown(path, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(
            this.chownBase,
            [(0, util_1.pathToFilename)(path), uid, gid],
            callback,
          );
        }
        lchownBase(filename, uid, gid) {
          this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
        }
        lchownSync(path, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.lchownBase((0, util_1.pathToFilename)(path), uid, gid);
        }
        lchown(path, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(
            this.lchownBase,
            [(0, util_1.pathToFilename)(path), uid, gid],
            callback,
          );
        }
        watchFile(path, a, b) {
          const filename = (0, util_1.pathToFilename)(path);
          let options = a;
          let listener = b;
          if (typeof options === "function") {
            listener = a;
            options = null;
          }
          if (typeof listener !== "function") {
            throw Error('"watchFile()" requires a listener function');
          }
          let interval = 5007;
          let persistent = true;
          if (options && typeof options === "object") {
            if (typeof options.interval === "number")
              interval = options.interval;
            if (typeof options.persistent === "boolean")
              persistent = options.persistent;
          }
          let watcher = this.statWatchers[filename];
          if (!watcher) {
            watcher = new this.StatWatcher();
            watcher.start(filename, persistent, interval);
            this.statWatchers[filename] = watcher;
          }
          watcher.addListener("change", listener);
          return watcher;
        }
        unwatchFile(path, listener) {
          const filename = (0, util_1.pathToFilename)(path);
          const watcher = this.statWatchers[filename];
          if (!watcher) return;
          if (typeof listener === "function") {
            watcher.removeListener("change", listener);
          } else {
            watcher.removeAllListeners("change");
          }
          if (watcher.listenerCount("change") === 0) {
            watcher.stop();
            delete this.statWatchers[filename];
          }
        }
        createReadStream(path, options) {
          return new this.ReadStream(path, options);
        }
        createWriteStream(path, options) {
          return new this.WriteStream(path, options);
        }
        watch(path, options, listener) {
          const filename = (0, util_1.pathToFilename)(path);
          let givenOptions = options;
          if (typeof options === "function") {
            listener = options;
            givenOptions = null;
          }
          let { persistent, recursive, encoding } = (0,
          options_1.getDefaultOpts)(givenOptions);
          if (persistent === undefined) persistent = true;
          if (recursive === undefined) recursive = false;
          const watcher = new this.FSWatcher();
          watcher.start(filename, persistent, recursive, encoding);
          if (listener) {
            watcher.addListener("change", listener);
          }
          return watcher;
        }
      }
      exports.Volume = Volume;
      Volume.fd = 2147483647;
      function emitStop(self) {
        self.emit("stop");
      }
      class StatWatcher extends events_1.EventEmitter {
        constructor(vol) {
          super();
          this.onInterval = () => {
            try {
              const stats = this.vol.statSync(this.filename);
              if (this.hasChanged(stats)) {
                this.emit("change", stats, this.prev);
                this.prev = stats;
              }
            } finally {
              this.loop();
            }
          };
          this.vol = vol;
        }
        loop() {
          this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
        }
        hasChanged(stats) {
          if (stats.mtimeMs > this.prev.mtimeMs) return true;
          if (stats.nlink !== this.prev.nlink) return true;
          return false;
        }
        start(path, persistent = true, interval = 5007) {
          this.filename = (0, util_1.pathToFilename)(path);
          this.setTimeout = persistent
            ? setTimeout.bind(
                typeof globalThis !== "undefined" ? globalThis : global,
              )
            : setTimeoutUnref_1.default;
          this.interval = interval;
          this.prev = this.vol.statSync(this.filename);
          this.loop();
        }
        stop() {
          clearTimeout(this.timeoutRef);
          (0, queueMicrotask_1.default)(() => {
            emitStop.call(this, this);
          });
        }
      }
      exports.StatWatcher = StatWatcher;
      var pool;
      function allocNewPool(poolSize) {
        pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
        pool.used = 0;
      }
      util.inherits(FsReadStream, stream_1.Readable);
      exports.ReadStream = FsReadStream;
      function FsReadStream(vol, path, options) {
        if (!(this instanceof FsReadStream))
          return new FsReadStream(vol, path, options);
        this._vol = vol;
        options = Object.assign({}, (0, options_1.getOptions)(options, {}));
        if (options.highWaterMark === undefined)
          options.highWaterMark = 64 * 1024;
        stream_1.Readable.call(this, options);
        this.path = (0, util_1.pathToFilename)(path);
        this.fd = options.fd === undefined ? null : options.fd;
        this.flags = options.flags === undefined ? "r" : options.flags;
        this.mode = options.mode === undefined ? 438 : options.mode;
        this.start = options.start;
        this.end = options.end;
        this.autoClose =
          options.autoClose === undefined ? true : options.autoClose;
        this.pos = undefined;
        this.bytesRead = 0;
        if (this.start !== undefined) {
          if (typeof this.start !== "number") {
            throw new TypeError('"start" option must be a Number');
          }
          if (this.end === undefined) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw new TypeError('"end" option must be a Number');
          }
          if (this.start > this.end) {
            throw new Error('"start" option must be <= "end" option');
          }
          this.pos = this.start;
        }
        if (typeof this.fd !== "number") this.open();
        this.on("end", function () {
          if (this.autoClose) {
            if (this.destroy) this.destroy();
          }
        });
      }
      FsReadStream.prototype.open = function () {
        var self = this;
        this._vol.open(this.path, this.flags, this.mode, (er, fd) => {
          if (er) {
            if (self.autoClose) {
              if (self.destroy) self.destroy();
            }
            self.emit("error", er);
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self.read();
        });
      };
      FsReadStream.prototype._read = function (n) {
        if (typeof this.fd !== "number") {
          return this.once("open", function () {
            this._read(n);
          });
        }
        if (this.destroyed) return;
        if (!pool || pool.length - pool.used < kMinPoolSpace) {
          allocNewPool(this._readableState.highWaterMark);
        }
        var thisPool = pool;
        var toRead = Math.min(pool.length - pool.used, n);
        var start = pool.used;
        if (this.pos !== undefined)
          toRead = Math.min(this.end - this.pos + 1, toRead);
        if (toRead <= 0) return this.push(null);
        var self = this;
        this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
        if (this.pos !== undefined) this.pos += toRead;
        pool.used += toRead;
        function onread(er, bytesRead) {
          if (er) {
            if (self.autoClose && self.destroy) {
              self.destroy();
            }
            self.emit("error", er);
          } else {
            var b = null;
            if (bytesRead > 0) {
              self.bytesRead += bytesRead;
              b = thisPool.slice(start, start + bytesRead);
            }
            self.push(b);
          }
        }
      };
      FsReadStream.prototype._destroy = function (err, cb) {
        this.close((err2) => {
          cb(err || err2);
        });
      };
      FsReadStream.prototype.close = function (cb) {
        var _a;
        if (cb) this.once("close", cb);
        if (this.closed || typeof this.fd !== "number") {
          if (typeof this.fd !== "number") {
            this.once("open", closeOnOpen);
            return;
          }
          return (0, queueMicrotask_1.default)(() => this.emit("close"));
        }
        if (
          typeof ((_a = this._readableState) === null || _a === void 0
            ? void 0
            : _a.closed) === "boolean"
        ) {
          this._readableState.closed = true;
        } else {
          this.closed = true;
        }
        this._vol.close(this.fd, (er) => {
          if (er) this.emit("error", er);
          else this.emit("close");
        });
        this.fd = null;
      };
      function closeOnOpen(fd) {
        this.close();
      }
      util.inherits(FsWriteStream, stream_1.Writable);
      exports.WriteStream = FsWriteStream;
      function FsWriteStream(vol, path, options) {
        if (!(this instanceof FsWriteStream))
          return new FsWriteStream(vol, path, options);
        this._vol = vol;
        options = Object.assign({}, (0, options_1.getOptions)(options, {}));
        stream_1.Writable.call(this, options);
        this.path = (0, util_1.pathToFilename)(path);
        this.fd = options.fd === undefined ? null : options.fd;
        this.flags = options.flags === undefined ? "w" : options.flags;
        this.mode = options.mode === undefined ? 438 : options.mode;
        this.start = options.start;
        this.autoClose =
          options.autoClose === undefined ? true : !!options.autoClose;
        this.pos = undefined;
        this.bytesWritten = 0;
        this.pending = true;
        if (this.start !== undefined) {
          if (typeof this.start !== "number") {
            throw new TypeError('"start" option must be a Number');
          }
          if (this.start < 0) {
            throw new Error('"start" must be >= zero');
          }
          this.pos = this.start;
        }
        if (options.encoding) this.setDefaultEncoding(options.encoding);
        if (typeof this.fd !== "number") this.open();
        this.once("finish", function () {
          if (this.autoClose) {
            this.close();
          }
        });
      }
      FsWriteStream.prototype.open = function () {
        this._vol.open(
          this.path,
          this.flags,
          this.mode,
          function (er, fd) {
            if (er) {
              if (this.autoClose && this.destroy) {
                this.destroy();
              }
              this.emit("error", er);
              return;
            }
            this.fd = fd;
            this.pending = false;
            this.emit("open", fd);
          }.bind(this),
        );
      };
      FsWriteStream.prototype._write = function (data, encoding, cb) {
        if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
          return this.emit("error", new Error("Invalid data"));
        if (typeof this.fd !== "number") {
          return this.once("open", function () {
            this._write(data, encoding, cb);
          });
        }
        var self = this;
        this._vol.write(
          this.fd,
          data,
          0,
          data.length,
          this.pos,
          (er, bytes) => {
            if (er) {
              if (self.autoClose && self.destroy) {
                self.destroy();
              }
              return cb(er);
            }
            self.bytesWritten += bytes;
            cb();
          },
        );
        if (this.pos !== undefined) this.pos += data.length;
      };
      FsWriteStream.prototype._writev = function (data, cb) {
        if (typeof this.fd !== "number") {
          return this.once("open", function () {
            this._writev(data, cb);
          });
        }
        const self = this;
        const len = data.length;
        const chunks = new Array(len);
        var size = 0;
        for (var i = 0; i < len; i++) {
          var chunk = data[i].chunk;
          chunks[i] = chunk;
          size += chunk.length;
        }
        const buf = buffer_1.Buffer.concat(chunks);
        this._vol.write(this.fd, buf, 0, buf.length, this.pos, (er, bytes) => {
          if (er) {
            if (self.destroy) self.destroy();
            return cb(er);
          }
          self.bytesWritten += bytes;
          cb();
        });
        if (this.pos !== undefined) this.pos += size;
      };
      FsWriteStream.prototype.close = function (cb) {
        var _a;
        if (cb) this.once("close", cb);
        if (this.closed || typeof this.fd !== "number") {
          if (typeof this.fd !== "number") {
            this.once("open", closeOnOpen);
            return;
          }
          return (0, queueMicrotask_1.default)(() => this.emit("close"));
        }
        if (
          typeof ((_a = this._writableState) === null || _a === void 0
            ? void 0
            : _a.closed) === "boolean"
        ) {
          this._writableState.closed = true;
        } else {
          this.closed = true;
        }
        this._vol.close(this.fd, (er) => {
          if (er) this.emit("error", er);
          else this.emit("close");
        });
        this.fd = null;
      };
      FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
      FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
      class FSWatcher extends events_1.EventEmitter {
        constructor(vol) {
          super();
          this._filename = "";
          this._filenameEncoded = "";
          this._recursive = false;
          this._encoding = encoding_1.ENCODING_UTF8;
          this._listenerRemovers = new Map();
          this._onParentChild = (link) => {
            if (link.getName() === this._getName()) {
              this._emit("rename");
            }
          };
          this._emit = (type) => {
            this.emit("change", type, this._filenameEncoded);
          };
          this._persist = () => {
            this._timer = setTimeout(this._persist, 1e6);
          };
          this._vol = vol;
        }
        _getName() {
          return this._steps[this._steps.length - 1];
        }
        start(
          path,
          persistent = true,
          recursive = false,
          encoding = encoding_1.ENCODING_UTF8,
        ) {
          this._filename = (0, util_1.pathToFilename)(path);
          this._steps = filenameToSteps(this._filename);
          this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
          this._recursive = recursive;
          this._encoding = encoding;
          try {
            this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
          } catch (err) {
            const error = new Error(`watch ${this._filename} ${err.code}`);
            error.code = err.code;
            error.errno = err.code;
            throw error;
          }
          const watchLinkNodeChanged = (link) => {
            var _a;
            const filepath = link.getPath();
            const node = link.getNode();
            const onNodeChange = () => {
              let filename = relative(this._filename, filepath);
              if (!filename) {
                filename = this._getName();
              }
              return this.emit("change", "change", filename);
            };
            node.on("change", onNodeChange);
            const removers =
              (_a = this._listenerRemovers.get(node.ino)) !== null &&
              _a !== void 0
                ? _a
                : [];
            removers.push(() => node.removeListener("change", onNodeChange));
            this._listenerRemovers.set(node.ino, removers);
          };
          const watchLinkChildrenChanged = (link) => {
            var _a;
            const node = link.getNode();
            const onLinkChildAdd = (l) => {
              this.emit(
                "change",
                "rename",
                relative(this._filename, l.getPath()),
              );
              setTimeout(() => {
                watchLinkNodeChanged(l);
                watchLinkChildrenChanged(l);
              });
            };
            const onLinkChildDelete = (l) => {
              const removeLinkNodeListeners = (curLink) => {
                const ino = curLink.getNode().ino;
                const removers = this._listenerRemovers.get(ino);
                if (removers) {
                  removers.forEach((r) => r());
                  this._listenerRemovers.delete(ino);
                }
                for (const [name, childLink] of curLink.children.entries()) {
                  if (childLink && name !== "." && name !== "..") {
                    removeLinkNodeListeners(childLink);
                  }
                }
              };
              removeLinkNodeListeners(l);
              this.emit(
                "change",
                "rename",
                relative(this._filename, l.getPath()),
              );
            };
            for (const [name, childLink] of link.children.entries()) {
              if (childLink && name !== "." && name !== "..") {
                watchLinkNodeChanged(childLink);
              }
            }
            link.on("child:add", onLinkChildAdd);
            link.on("child:delete", onLinkChildDelete);
            const removers =
              (_a = this._listenerRemovers.get(node.ino)) !== null &&
              _a !== void 0
                ? _a
                : [];
            removers.push(() => {
              link.removeListener("child:add", onLinkChildAdd);
              link.removeListener("child:delete", onLinkChildDelete);
            });
            if (recursive) {
              for (const [name, childLink] of link.children.entries()) {
                if (childLink && name !== "." && name !== "..") {
                  watchLinkChildrenChanged(childLink);
                }
              }
            }
          };
          watchLinkNodeChanged(this._link);
          watchLinkChildrenChanged(this._link);
          const parent = this._link.parent;
          if (parent) {
            parent.setMaxListeners(parent.getMaxListeners() + 1);
            parent.on("child:delete", this._onParentChild);
          }
          if (persistent) this._persist();
        }
        close() {
          clearTimeout(this._timer);
          this._listenerRemovers.forEach((removers) => {
            removers.forEach((r) => r());
          });
          this._listenerRemovers.clear();
          const parent = this._link.parent;
          if (parent) {
            parent.removeListener("child:delete", this._onParentChild);
          }
        }
      }
      exports.FSWatcher = FSWatcher;
    },
    772: (module, __unused_webpack_exports, __nccwpck_require__) => {
      /*!
       * on-finished
       * Copyright(c) 2013 Jonathan Ong
       * Copyright(c) 2014 Douglas Christopher Wilson
       * MIT Licensed
       */
      module.exports = onFinished;
      module.exports.isFinished = isFinished;
      var asyncHooks = tryRequireAsyncHooks();
      var first = __nccwpck_require__(261);
      var defer =
        typeof setImmediate === "function"
          ? setImmediate
          : function (fn) {
              process.nextTick(fn.bind.apply(fn, arguments));
            };
      function onFinished(msg, listener) {
        if (isFinished(msg) !== false) {
          defer(listener, null, msg);
          return msg;
        }
        attachListener(msg, wrap(listener));
        return msg;
      }
      function isFinished(msg) {
        var socket = msg.socket;
        if (typeof msg.finished === "boolean") {
          return Boolean(msg.finished || (socket && !socket.writable));
        }
        if (typeof msg.complete === "boolean") {
          return Boolean(
            msg.upgrade ||
              !socket ||
              !socket.readable ||
              (msg.complete && !msg.readable),
          );
        }
        return undefined;
      }
      function attachFinishedListener(msg, callback) {
        var eeMsg;
        var eeSocket;
        var finished = false;
        function onFinish(error) {
          eeMsg.cancel();
          eeSocket.cancel();
          finished = true;
          callback(error);
        }
        eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
        function onSocket(socket) {
          msg.removeListener("socket", onSocket);
          if (finished) return;
          if (eeMsg !== eeSocket) return;
          eeSocket = first([[socket, "error", "close"]], onFinish);
        }
        if (msg.socket) {
          onSocket(msg.socket);
          return;
        }
        msg.on("socket", onSocket);
        if (msg.socket === undefined) {
          patchAssignSocket(msg, onSocket);
        }
      }
      function attachListener(msg, listener) {
        var attached = msg.__onFinished;
        if (!attached || !attached.queue) {
          attached = msg.__onFinished = createListener(msg);
          attachFinishedListener(msg, attached);
        }
        attached.queue.push(listener);
      }
      function createListener(msg) {
        function listener(err) {
          if (msg.__onFinished === listener) msg.__onFinished = null;
          if (!listener.queue) return;
          var queue = listener.queue;
          listener.queue = null;
          for (var i = 0; i < queue.length; i++) {
            queue[i](err, msg);
          }
        }
        listener.queue = [];
        return listener;
      }
      function patchAssignSocket(res, callback) {
        var assignSocket = res.assignSocket;
        if (typeof assignSocket !== "function") return;
        res.assignSocket = function _assignSocket(socket) {
          assignSocket.call(this, socket);
          callback(socket);
        };
      }
      function tryRequireAsyncHooks() {
        try {
          return __nccwpck_require__(852);
        } catch (e) {
          return {};
        }
      }
      function wrap(fn) {
        var res;
        if (asyncHooks.AsyncResource) {
          res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
        }
        if (!res || !res.runInAsyncScope) {
          return fn;
        }
        return res.runInAsyncScope.bind(res, fn, null);
      }
    },
    395: (module) => {
      /*!
       * range-parser
       * Copyright(c) 2012-2014 TJ Holowaychuk
       * Copyright(c) 2015-2016 Douglas Christopher Wilson
       * MIT Licensed
       */
      module.exports = rangeParser;
      function rangeParser(size, str, options) {
        if (typeof str !== "string") {
          throw new TypeError("argument str must be a string");
        }
        var index = str.indexOf("=");
        if (index === -1) {
          return -2;
        }
        var arr = str.slice(index + 1).split(",");
        var ranges = [];
        ranges.type = str.slice(0, index);
        for (var i = 0; i < arr.length; i++) {
          var range = arr[i].split("-");
          var start = parseInt(range[0], 10);
          var end = parseInt(range[1], 10);
          if (isNaN(start)) {
            start = size - end;
            end = size - 1;
          } else if (isNaN(end)) {
            end = size - 1;
          }
          if (end > size - 1) {
            end = size - 1;
          }
          if (isNaN(start) || isNaN(end) || start > end || start < 0) {
            continue;
          }
          ranges.push({ start, end });
        }
        if (ranges.length < 1) {
          return -1;
        }
        return options && options.combine ? combineRanges(ranges) : ranges;
      }
      function combineRanges(ranges) {
        var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
        for (var j = 0, i = 1; i < ordered.length; i++) {
          var range = ordered[i];
          var current = ordered[j];
          if (range.start > current.end + 1) {
            ordered[++j] = range;
          } else if (range.end > current.end) {
            current.end = range.end;
            current.index = Math.min(current.index, range.index);
          }
        }
        ordered.length = j + 1;
        var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
        combined.type = ranges.type;
        return combined;
      }
      function mapWithIndex(range, index) {
        return { start: range.start, end: range.end, index };
      }
      function mapWithoutIndex(range) {
        return { start: range.start, end: range.end };
      }
      function sortByRangeIndex(a, b) {
        return a.index - b.index;
      }
      function sortByRangeStart(a, b) {
        return a.start - b.start;
      }
    },
    907: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const middleware = __nccwpck_require__(926);
      const getFilenameFromUrl = __nccwpck_require__(461);
      const setupHooks = __nccwpck_require__(59);
      const setupWriteToDisk = __nccwpck_require__(998);
      const setupOutputFileSystem = __nccwpck_require__(950);
      const ready = __nccwpck_require__(201);
      const noop = () => {};
      function wdm(compiler, options = {}) {
        const context = {
          state: false,
          stats: undefined,
          callbacks: [],
          options,
          compiler,
          logger: compiler.getInfrastructureLogger("webpack-dev-middleware"),
        };
        setupHooks(context);
        if (options.writeToDisk) {
          setupWriteToDisk(context);
        }
        setupOutputFileSystem(context);
        if (context.compiler.watching) {
          context.watching = context.compiler.watching;
        } else {
          const errorHandler = (error) => {
            if (error) {
              context.logger.error(error);
            }
          };
          if (Array.isArray(context.compiler.compilers)) {
            const compiler = context.compiler;
            const watchOptions = compiler.compilers.map(
              (childCompiler) => childCompiler.options.watchOptions || {},
            );
            context.watching = compiler.watch(watchOptions, errorHandler);
          } else {
            const compiler = context.compiler;
            const watchOptions = compiler.options.watchOptions || {};
            context.watching = compiler.watch(watchOptions, errorHandler);
          }
        }
        const filledContext = context;
        const instance = middleware(filledContext);
        instance.getFilenameFromUrl = (url, extra) =>
          getFilenameFromUrl(filledContext, url, extra);
        instance.waitUntilValid = (callback = noop) => {
          ready(filledContext, callback);
        };
        instance.invalidate = (callback = noop) => {
          ready(filledContext, callback);
          filledContext.watching.invalidate();
        };
        instance.close = (callback = noop) => {
          filledContext.watching.close(callback);
        };
        instance.context = filledContext;
        return instance;
      }
      module.exports = wdm;
    },
    926: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const mrmime = __nccwpck_require__(802);
      const onFinishedStream = __nccwpck_require__(772);
      const getFilenameFromUrl = __nccwpck_require__(461);
      const { setStatusCode, send, pipe, createReadStreamOrReadFileSync } =
        __nccwpck_require__(309);
      const ready = __nccwpck_require__(201);
      const parseTokenList = __nccwpck_require__(830);
      const memorize = __nccwpck_require__(358);
      async function getEtag(stat) {
        const mtime = stat.mtime.getTime().toString(16);
        const size = stat.size.toString(16);
        return `W/"${size}-${mtime}"`;
      }
      function getContentType(str) {
        let mime = mrmime.lookup(str);
        if (!mime) {
          return false;
        }
        if (
          mime.startsWith("text/") ||
          mime === "application/json" ||
          mime === "application/manifest+json"
        ) {
          mime += `; charset=utf-8`;
        }
        return mime;
      }
      const BYTES_RANGE_REGEXP = /^ *bytes/i;
      function getValueContentRangeHeader(type, size, range) {
        return `${type} ${range ? `${range.start}-${range.end}` : "*"}/${size}`;
      }
      function parseHttpDate(date) {
        const timestamp = date && Date.parse(date);
        return typeof timestamp === "number" ? timestamp : NaN;
      }
      const CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
      function destroyStream(stream, suppress) {
        if (typeof stream.destroy === "function") {
          stream.destroy();
        }
        if (typeof stream.close === "function") {
          stream.on("open", function onOpenClose() {
            if (typeof this.fd === "number") {
              this.close();
            }
          });
        }
        if (typeof stream.addListener === "function" && suppress) {
          stream.removeAllListeners("error");
          stream.addListener("error", () => {});
        }
      }
      const statuses = {
        400: "Bad Request",
        403: "Forbidden",
        404: "Not Found",
        416: "Range Not Satisfiable",
        500: "Internal Server Error",
      };
      const parseRangeHeaders = memorize((value) => {
        const [len, rangeHeader] = value.split("|");
        return __nccwpck_require__(395)(Number(len), rangeHeader, {
          combine: true,
        });
      });
      function wrapper(context) {
        return async function middleware(req, res, next) {
          const acceptedMethods = ["GET", "HEAD"];
          res.locals = res.locals || {};
          async function goNext() {
            return new Promise((resolve) => {
              ready(
                context,
                () => {
                  res.locals.webpack = { devMiddleware: context };
                  resolve(next());
                },
                req,
              );
            });
          }
          if (req.method && !acceptedMethods.includes(req.method)) {
            await goNext();
            return;
          }
          function sendError(status, options) {
            const escapeHtml = __nccwpck_require__(227);
            const content = statuses[status] || String(status);
            const document = Buffer.from(
              `<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>${escapeHtml(content)}</pre>\n</body>\n</html>`,
              "utf-8",
            );
            const headers = res.getHeaderNames();
            for (let i = 0; i < headers.length; i++) {
              res.removeHeader(headers[i]);
            }
            if (options && options.headers) {
              const keys = Object.keys(options.headers);
              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const value = options.headers[key];
                if (typeof value !== "undefined") {
                  res.setHeader(key, value);
                }
              }
            }
            setStatusCode(res, status);
            res.setHeader("Content-Type", "text/html; charset=utf-8");
            res.setHeader("Content-Security-Policy", "default-src 'none'");
            res.setHeader("X-Content-Type-Options", "nosniff");
            const byteLength = Buffer.byteLength(document);
            res.setHeader("Content-Length", byteLength);
            res.end(document);
          }
          function isConditionalGET() {
            return (
              req.headers["if-match"] ||
              req.headers["if-unmodified-since"] ||
              req.headers["if-none-match"] ||
              req.headers["if-modified-since"]
            );
          }
          function isPreconditionFailure() {
            const ifMatch = req.headers["if-match"];
            if (ifMatch) {
              const etag = res.getHeader("ETag");
              return (
                !etag ||
                (ifMatch !== "*" &&
                  parseTokenList(ifMatch).every(
                    (match) =>
                      match !== etag &&
                      match !== `W/${etag}` &&
                      `W/${match}` !== etag,
                  ))
              );
            }
            const ifUnmodifiedSince = req.headers["if-unmodified-since"];
            if (ifUnmodifiedSince) {
              const unmodifiedSince = parseHttpDate(ifUnmodifiedSince);
              if (!isNaN(unmodifiedSince)) {
                const lastModified = parseHttpDate(
                  res.getHeader("Last-Modified"),
                );
                return isNaN(lastModified) || lastModified > unmodifiedSince;
              }
            }
            return false;
          }
          function isCachable() {
            return (
              (res.statusCode >= 200 && res.statusCode < 300) ||
              res.statusCode === 304
            );
          }
          function isFresh(resHeaders) {
            const cacheControl = req.headers["cache-control"];
            if (
              cacheControl &&
              CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)
            ) {
              return false;
            }
            const noneMatch = req.headers["if-none-match"];
            const modifiedSince = req.headers["if-modified-since"];
            if (!noneMatch && !modifiedSince) {
              return false;
            }
            if (noneMatch && noneMatch !== "*") {
              if (!resHeaders.etag) {
                return false;
              }
              const matches = parseTokenList(noneMatch);
              let etagStale = true;
              for (let i = 0; i < matches.length; i++) {
                const match = matches[i];
                if (
                  match === resHeaders.etag ||
                  match === `W/${resHeaders.etag}` ||
                  `W/${match}` === resHeaders.etag
                ) {
                  etagStale = false;
                  break;
                }
              }
              if (etagStale) {
                return false;
              }
            }
            if (noneMatch) {
              return true;
            }
            if (modifiedSince) {
              const lastModified = resHeaders["last-modified"];
              const modifiedStale =
                !lastModified ||
                !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
              if (modifiedStale) {
                return false;
              }
            }
            return true;
          }
          function isRangeFresh() {
            const ifRange = req.headers["if-range"];
            if (!ifRange) {
              return true;
            }
            if (ifRange.indexOf('"') !== -1) {
              const etag = res.getHeader("ETag");
              if (!etag) {
                return true;
              }
              return Boolean(etag && ifRange.indexOf(etag) !== -1);
            }
            const lastModified = res.getHeader("Last-Modified");
            if (!lastModified) {
              return true;
            }
            return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
          }
          function getRangeHeader() {
            const rage = req.headers.range;
            if (rage && BYTES_RANGE_REGEXP.test(rage)) {
              return rage;
            }
            return undefined;
          }
          function getOffsetAndLenFromRange(range) {
            const offset = range.start;
            const len = range.end - range.start + 1;
            return [offset, len];
          }
          function calcStartAndEnd(offset, len) {
            const start = offset;
            const end = Math.max(offset, offset + len - 1);
            return [start, end];
          }
          async function processRequest() {
            const extra = {};
            const filename = getFilenameFromUrl(context, req.url, extra);
            if (extra.errorCode) {
              if (extra.errorCode === 403) {
                context.logger.error(`Malicious path "${filename}".`);
              }
              sendError(extra.errorCode);
              return;
            }
            if (!filename) {
              await goNext();
              return;
            }
            const { size } = extra.stats;
            let len = size;
            let offset = 0;
            if (!res.getHeader("Content-Type")) {
              const contentType = getContentType(filename);
              if (contentType) {
                res.setHeader("Content-Type", contentType);
              }
            }
            if (!res.getHeader("Accept-Ranges")) {
              res.setHeader("Accept-Ranges", "bytes");
            }
            if (
              context.options.lastModified &&
              !res.getHeader("Last-Modified")
            ) {
              const modified = extra.stats.mtime.toUTCString();
              res.setHeader("Last-Modified", modified);
            }
            const rangeHeader = getRangeHeader();
            if (!res.getHeader("ETag")) {
              const value = extra.stats;
              if (value) {
                const hash = await getEtag(value);
                res.setHeader("ETag", hash);
              }
            }
            if (isConditionalGET()) {
              if (isPreconditionFailure()) {
                sendError(412);
                return;
              }
              if (res.statusCode === 404) {
                setStatusCode(res, 200);
              }
              if (
                isCachable() &&
                isFresh({
                  etag: res.getHeader("ETag"),
                  "last-modified": res.getHeader("Last-Modified"),
                })
              ) {
                setStatusCode(res, 304);
                res.removeHeader("Content-Encoding");
                res.removeHeader("Content-Language");
                res.removeHeader("Content-Length");
                res.removeHeader("Content-Range");
                res.removeHeader("Content-Type");
                res.end();
                return;
              }
            }
            if (rangeHeader) {
              let parsedRanges = parseRangeHeaders(`${size}|${rangeHeader}`);
              if (!isRangeFresh()) {
                parsedRanges = [];
              }
              if (parsedRanges === -1) {
                context.logger.error("Unsatisfiable range for 'Range' header.");
                res.setHeader(
                  "Content-Range",
                  getValueContentRangeHeader("bytes", size),
                );
                sendError(416, {
                  headers: { "Content-Range": res.getHeader("Content-Range") },
                });
                return;
              } else if (parsedRanges === -2) {
                context.logger.error(
                  "A malformed 'Range' header was provided. A regular response will be sent for this request.",
                );
              } else if (parsedRanges.length > 1) {
                context.logger.error(
                  "A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.",
                );
              }
              if (parsedRanges !== -2 && parsedRanges.length === 1) {
                setStatusCode(res, 206);
                res.setHeader(
                  "Content-Range",
                  getValueContentRangeHeader("bytes", size, parsedRanges[0]),
                );
                [offset, len] = getOffsetAndLenFromRange(parsedRanges[0]);
              }
            }
            let bufferOrStream;
            let byteLength;
            const [start, end] = calcStartAndEnd(offset, len);
            try {
              ({ bufferOrStream, byteLength } = createReadStreamOrReadFileSync(
                filename,
                context.outputFileSystem,
                start,
                end,
              ));
            } catch (_ignoreError) {
              await goNext();
              return;
            }
            res.setHeader("Content-Length", byteLength);
            if (req.method === "HEAD") {
              if (res.statusCode === 404) {
                setStatusCode(res, 200);
              }
              res.end();
              return;
            }
            const isPipeSupports = typeof bufferOrStream.pipe === "function";
            if (!isPipeSupports) {
              send(res, bufferOrStream);
              return;
            }
            const cleanup = () => {
              destroyStream(bufferOrStream, true);
            };
            bufferOrStream.on("error", (error) => {
              cleanup();
              switch (error.code) {
                case "ENAMETOOLONG":
                case "ENOENT":
                case "ENOTDIR":
                  sendError(404);
                  break;
                default:
                  sendError(500);
                  break;
              }
            });
            pipe(res, bufferOrStream);
            onFinishedStream(res, cleanup);
          }
          ready(context, processRequest, req);
        };
      }
      module.exports = wrapper;
    },
    309: (module) => {
      function setStatusCode(res, code) {
        if (typeof res.status === "function") {
          res.status(code);
          return;
        }
        res.statusCode = code;
      }
      function pipe(res, bufferOrStream) {
        if (typeof res.pipeInto === "function") {
          res.pipeInto(bufferOrStream);
          return;
        }
        bufferOrStream.pipe(res);
      }
      function send(res, bufferOrStream) {
        if (typeof res.send === "function") {
          res.send(bufferOrStream);
          return;
        }
        res.end(bufferOrStream);
      }
      function createReadStreamOrReadFileSync(
        filename,
        outputFileSystem,
        start,
        end,
      ) {
        let bufferOrStream;
        let byteLength;
        const isFsSupportsStream =
          typeof outputFileSystem.createReadStream === "function";
        if (isFsSupportsStream) {
          bufferOrStream = outputFileSystem.createReadStream(filename, {
            start,
            end,
          });
          byteLength = end === 0 ? 0 : end - start + 1;
        } else {
          bufferOrStream = outputFileSystem.readFileSync(filename);
          ({ byteLength } = bufferOrStream);
        }
        return { bufferOrStream, byteLength };
      }
      module.exports = {
        setStatusCode,
        send,
        pipe,
        createReadStreamOrReadFileSync,
      };
    },
    227: (module) => {
      const matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string) {
        const str = `${string}`;
        const match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        let escape;
        let html = "";
        let index = 0;
        let lastIndex = 0;
        for ({ index } = match; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&#39;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape;
        }
        return lastIndex !== index
          ? html + str.substring(lastIndex, index)
          : html;
      }
      module.exports = escapeHtml;
    },
    461: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const path = __nccwpck_require__(17);
      const { parse } = __nccwpck_require__(310);
      const querystring = __nccwpck_require__(477);
      const getPaths = __nccwpck_require__(586);
      const memorize = __nccwpck_require__(358);
      const memoizedParse = memorize(parse, undefined, (value) => {
        if (value.pathname) {
          value.pathname = decode(value.pathname);
        }
        return value;
      });
      const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
      function decode(input) {
        return querystring.unescape(input);
      }
      function getFilenameFromUrl(context, url, extra = {}) {
        const { options } = context;
        const paths = getPaths(context);
        let foundFilename;
        let urlObject;
        try {
          urlObject = memoizedParse(url, false, true);
        } catch (_ignoreError) {
          return;
        }
        for (const { publicPath, outputPath } of paths) {
          let filename;
          let publicPathObject;
          try {
            publicPathObject = memoizedParse(
              publicPath !== "auto" && publicPath ? publicPath : "/",
              false,
              true,
            );
          } catch (_ignoreError) {
            continue;
          }
          const { pathname } = urlObject;
          const { pathname: publicPathPathname } = publicPathObject;
          if (pathname && pathname.startsWith(publicPathPathname)) {
            if (pathname.includes("\0")) {
              extra.errorCode = 400;
              return;
            }
            if (UP_PATH_REGEXP.test(path.normalize(`./${pathname}`))) {
              extra.errorCode = 403;
              return;
            }
            filename = path.join(
              outputPath,
              pathname.slice(publicPathPathname.length),
            );
            try {
              extra.stats = context.outputFileSystem.statSync(filename);
            } catch (_ignoreError) {
              continue;
            }
            if (extra.stats.isFile()) {
              foundFilename = filename;
              break;
            } else if (
              extra.stats.isDirectory() &&
              (typeof options.index === "undefined" || options.index)
            ) {
              const indexValue =
                typeof options.index === "undefined" ||
                typeof options.index === "boolean"
                  ? "index.html"
                  : options.index;
              filename = path.join(filename, indexValue);
              try {
                extra.stats = context.outputFileSystem.statSync(filename);
              } catch (__ignoreError) {
                continue;
              }
              if (extra.stats.isFile()) {
                foundFilename = filename;
                break;
              }
            }
          }
        }
        return foundFilename;
      }
      module.exports = getFilenameFromUrl;
    },
    586: (module) => {
      function getPaths(context) {
        const { stats, options } = context;
        const childStats = stats.stats ? stats.stats : [stats];
        const publicPaths = [];
        for (const { compilation } of childStats) {
          const outputPath = compilation.getPath(
            compilation.outputOptions.path || "",
          );
          const publicPath = options.publicPath
            ? compilation.getPath(options.publicPath)
            : compilation.outputOptions.publicPath
              ? compilation.getPath(compilation.outputOptions.publicPath)
              : "";
          publicPaths.push({ outputPath, publicPath });
        }
        return publicPaths;
      }
      module.exports = getPaths;
    },
    358: (module) => {
      const cacheStore = new WeakMap();
      function memorize(fn, { cache = new Map() } = {}, callback) {
        const memoized = (...arguments_) => {
          const [key] = arguments_;
          const cacheItem = cache.get(key);
          if (cacheItem) {
            return cacheItem.data;
          }
          let result = fn.apply(this, arguments_);
          if (callback) {
            result = callback(result);
          }
          cache.set(key, { data: result });
          return result;
        };
        cacheStore.set(memoized, cache);
        return memoized;
      }
      module.exports = memorize;
    },
    830: (module) => {
      function parseTokenList(str) {
        let end = 0;
        let start = 0;
        const list = [];
        for (let i = 0, len = str.length; i < len; i++) {
          switch (str.charCodeAt(i)) {
            case 32:
              if (start === end) {
                end = i + 1;
                start = end;
              }
              break;
            case 44:
              if (start !== end) {
                list.push(str.substring(start, end));
              }
              end = i + 1;
              start = end;
              break;
            default:
              end = i + 1;
              break;
          }
        }
        if (start !== end) {
          list.push(str.substring(start, end));
        }
        return list;
      }
      module.exports = parseTokenList;
    },
    201: (module) => {
      function ready(context, callback, req) {
        if (context.state) {
          callback(context.stats);
          return;
        }
        const name = (req && req.url) || callback.name;
        context.logger.info(
          `wait until bundle finished${name ? `: ${name}` : ""}`,
        );
        context.callbacks.push(callback);
      }
      module.exports = ready;
    },
    59: (module) => {
      function setupHooks(context) {
        function invalid() {
          if (context.state) {
            context.logger.log("Compilation starting...");
          }
          context.state = false;
          context.stats = undefined;
        }
        function done(stats) {
          context.state = true;
          context.stats = stats;
          process.nextTick(() => {
            const { logger, state, callbacks } = context;
            if (!state) {
              return;
            }
            logger.log("Compilation finished");
            context.callbacks = [];
            callbacks.forEach((callback) => {
              callback(stats);
            });
          });
        }
        const compiler = context.compiler;
        compiler.hooks.watchRun.tap("webpack-dev-middleware", invalid);
        compiler.hooks.invalid.tap("webpack-dev-middleware", invalid);
        compiler.hooks.done.tap("webpack-dev-middleware", done);
      }
      module.exports = setupHooks;
    },
    950: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const memfs = __nccwpck_require__(664);
      function setupOutputFileSystem(context) {
        let outputFileSystem;
        if (context.options.writeToDisk !== true) {
          outputFileSystem = memfs.createFsFromVolume(new memfs.Volume());
        } else {
          const isMultiCompiler = context.compiler.compilers;
          if (isMultiCompiler) {
            const compiler = context.compiler.compilers.filter((item) =>
              Object.prototype.hasOwnProperty.call(item.options, "devServer"),
            );
            ({ outputFileSystem } =
              compiler[0] || context.compiler.compilers[0]);
          } else {
            ({ outputFileSystem } = context.compiler);
          }
        }
        const compilers = context.compiler.compilers || [context.compiler];
        for (const compiler of compilers) {
          compiler.outputFileSystem = outputFileSystem;
        }
        context.outputFileSystem = outputFileSystem;
      }
      module.exports = setupOutputFileSystem;
    },
    998: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const fs = __nccwpck_require__(147);
      const path = __nccwpck_require__(17);
      function setupWriteToDisk(context) {
        const compilers = context.compiler.compilers || [context.compiler];
        for (const compiler of compilers) {
          compiler.hooks.emit.tap("DevMiddleware", () => {
            if (compiler.hasWebpackDevMiddlewareAssetEmittedCallback) {
              return;
            }
            compiler.hooks.assetEmitted.tapAsync(
              "DevMiddleware",
              (file, info, callback) => {
                const { targetPath, content } = info;
                const { writeToDisk: filter } = context.options;
                const allowWrite =
                  filter && typeof filter === "function"
                    ? filter(targetPath)
                    : true;
                if (!allowWrite) {
                  return callback();
                }
                const dir = path.dirname(targetPath);
                const name = compiler.options.name
                  ? `Child "${compiler.options.name}": `
                  : "";
                return fs.mkdir(dir, { recursive: true }, (mkdirError) => {
                  if (mkdirError) {
                    context.logger.error(
                      `${name}Unable to write "${dir}" directory to disk:\n${mkdirError}`,
                    );
                    return callback(mkdirError);
                  }
                  return fs.writeFile(targetPath, content, (writeFileError) => {
                    if (writeFileError) {
                      context.logger.error(
                        `${name}Unable to write "${targetPath}" asset to disk:\n${writeFileError}`,
                      );
                      return callback(writeFileError);
                    }
                    context.logger.log(
                      `${name}Asset written to disk: "${targetPath}"`,
                    );
                    return callback();
                  });
                });
              },
            );
            compiler.hasWebpackDevMiddlewareAssetEmittedCallback = true;
          });
        }
      }
      module.exports = setupWriteToDisk;
    },
    802: (module) => {
      module.exports = require("../mrmime");
    },
    491: (module) => {
      module.exports = require("assert");
    },
    852: (module) => {
      module.exports = require("async_hooks");
    },
    300: (module) => {
      module.exports = require("buffer");
    },
    361: (module) => {
      module.exports = require("events");
    },
    147: (module) => {
      module.exports = require("fs");
    },
    17: (module) => {
      module.exports = require("path");
    },
    282: (module) => {
      module.exports = require("process");
    },
    477: (module) => {
      module.exports = require("querystring");
    },
    781: (module) => {
      module.exports = require("stream");
    },
    310: (module) => {
      module.exports = require("url");
    },
    837: (module) => {
      module.exports = require("util");
    },
  };
  var __webpack_module_cache__ = {};
  function __nccwpck_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (__webpack_module_cache__[moduleId] = { exports: {} });
    var threw = true;
    try {
      __webpack_modules__[moduleId](
        module,
        module.exports,
        __nccwpck_require__,
      );
      threw = false;
    } finally {
      if (threw) delete __webpack_module_cache__[moduleId];
    }
    return module.exports;
  }
  if (typeof __nccwpck_require__ !== "undefined")
    __nccwpck_require__.ab = __dirname + "/";
  var __webpack_exports__ = __nccwpck_require__(907);
  module.exports = __webpack_exports__;
})();
