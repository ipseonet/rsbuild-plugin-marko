// src/index.ts
import { sep } from "path";
var nms = sep + "node_modules" + sep;
var nmsLen = nms.length;
var backSep = `../`;
var toPosix = sep === "/" ? (v) => v : (v) => {
  let result = "";
  for (let i = v.length; i--; ) {
    const c = v[i];
    result = (c === sep ? "/" : c) + result;
  }
  return result;
};
function relativeImportPath(from, to) {
  let i = 0;
  let sepPos = -1;
  let prevSepPos = -1;
  let prevPrevSepPos = -1;
  const fromLen = from.length;
  const commonLen = Math.min(to.length, fromLen);
  for (; i < commonLen; i++) {
    const curChar = to[i];
    if (curChar !== from[i])
      break;
    if (curChar === sep) {
      prevPrevSepPos = prevSepPos;
      prevSepPos = sepPos;
      sepPos = i;
    }
  }
  if (sepPos !== -1) {
    if (hasNms(to, sepPos)) {
      return toPosix(stripNms(to, sepPos));
    }
    if (prevSepPos !== -1) {
      if (prevPrevSepPos !== -1 && to[prevSepPos + 1] === "@") {
        prevSepPos = prevPrevSepPos;
      }
      if (hasNms(to, prevSepPos)) {
        return toPosix(stripNms(to, prevSepPos));
      }
    }
  }
  if (sepPos <= 0)
    return toPosix(to);
  let back = 0;
  for (; i < fromLen; i++)
    if (from[i] === sep)
      back++;
  if (back) {
    return backSep.repeat(back) + toPosix(to.slice(sepPos + 1));
  } else {
    return `.${toPosix(to.slice(sepPos))}`;
  }
}
function hasNms(src, pos) {
  return src.slice(pos).startsWith(nms);
}
function stripNms(src, pos) {
  return src.slice(pos + nmsLen);
}
export {
  relativeImportPath
};
