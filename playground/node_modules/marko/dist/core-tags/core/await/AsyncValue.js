"use strict";var queueMicrotask = require("@internal/set-immediate").e_;

function AsyncValue() {
  /**
   * The data that was provided via call to resolve(data).
   * This property is assumed to be public and available for inspection.
   */
  this.f_ = undefined;

  /**
   * The data that was provided via call to reject(err)
   * This property is assumed to be public and available for inspection.
   */
  this.g_ = undefined;

  /**
   * The queue of callbacks that are waiting for data
   */
  this.h_ = undefined;

  /**
   * The state of the data holder (STATE_INITIAL, STATE_RESOLVED, or STATE_REJECTED)
   */
  this.i_ = false;
}

function notifyCallbacks(asyncValue, err, value) {
  var callbacks = asyncValue.h_;
  if (callbacks) {
    // clear out the registered callbacks (we still have reference to the original value)
    asyncValue.h_ = undefined;

    // invoke all of the callbacks and use their scope
    for (var i = 0; i < callbacks.length; i++) {
      // each callback is actually an object with "scope and "callback" properties
      var callback = callbacks[i];
      callback(err, value);
    }
  }
}

AsyncValue.prototype = {
  /**
   * Adds a callback to the queue. If there is not a pending request to load data
   * and we have a "loader" then we will use that loader to request the data.
   * The given callback will be invoked when there is an error or resolved data
   * available.
   */
  j_: function (callback) {
    // Do we already have data or error?
    if (this.i_) {
      // invoke the callback immediately
      return callback(this.g_, this.f_);
    }

    var callbacks = this.h_ || (this.h_ = []);
    callbacks.push(callback);
  },

  /**
   * This method will trigger any callbacks to be notified of rejection (error).
   * If this data holder has a loader then the data holder will be returned to
   * its initial state so that any future requests to load data will trigger a
   * new load call.
   */
  k_: function (err) {
    if (this.i_) {
      return;
    }

    // remember the error
    this.g_ = err;

    // Go to the rejected state if we don't have a loader.
    // If we do have a loader then return to the initial state
    // (we do this so that next call to done() will trigger load
    // again in case the error was transient).
    this.i_ = true;

    // always notify callbacks regardless of whether or not we return to the initial state
    notifyCallbacks(this, err, null);
  },

  /**
   * This method will trigger any callbacks to be notified of data.
   */
  l_: function (value) {
    if (this.i_) {
      return;
    }

    if (value && typeof value.then === "function") {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      var asyncValue = this;

      var finalPromise = value.then(
        function onFulfilled(value) {
          queueMicrotask(asyncValue.l_.bind(asyncValue, value));
        },
        function onRejected(err) {
          queueMicrotask(asyncValue.k_.bind(asyncValue, err));
        }
      );

      if (finalPromise.done) {
        finalPromise.done();
      }
    } else {
      // remember the state
      this.f_ = value;

      // go to the resolved state
      this.i_ = true;

      // notify callbacks
      notifyCallbacks(this, null, value);
    }
  }
};

module.exports = AsyncValue;