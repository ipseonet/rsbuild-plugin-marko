"use strict";
/**
 * The following code is modified based on
 * https://github.com/webpack/loader-runner
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/loader-runner/blob/main/LICENSE
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LoaderObject_loaderItem;
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePathQueryFragment = exports.runLoaders = exports.LoaderObject = void 0;
const node_querystring_1 = __importDefault(require("node:querystring"));
const node_assert_1 = __importDefault(require("node:assert"));
const node_util_1 = require("node:util");
const binding_1 = require("@rspack/binding");
const webpack_sources_1 = require("../../compiled/webpack-sources");
const Module_1 = require("../Module");
const NormalModule_1 = require("../NormalModule");
const RspackError_1 = require("../RspackError");
const adapterRuleUse_1 = require("../config/adapterRuleUse");
const util_1 = require("../util");
const createHash_1 = require("../util/createHash");
const identifier_1 = require("../util/identifier");
const memoize_1 = require("../util/memoize");
const loadLoader_1 = __importDefault(require("./loadLoader"));
function createLoaderObject(loader, compiler) {
    const obj = {
        path: null,
        query: null,
        fragment: null,
        options: null,
        ident: null,
        normal: null,
        pitch: null,
        raw: null,
        data: null,
        pitchExecuted: false,
        normalExecuted: false
    };
    Object.defineProperty(obj, "request", {
        enumerable: true,
        get: () => obj.path.replace(/#/g, "\u200b#") +
            obj.query.replace(/#/g, "\u200b#") +
            obj.fragment,
        set: value => {
            const splittedRequest = (0, identifier_1.parseResourceWithoutFragment)(value.request);
            obj.path = splittedRequest.path;
            obj.query = splittedRequest.query;
            obj.fragment = "";
            obj.options =
                obj.options === null
                    ? splittedRequest.query
                        ? splittedRequest.query.slice(1)
                        : undefined
                    : obj.options;
            if (typeof obj.options === "string" && obj.options[0] === "?") {
                const ident = obj.options.slice(1);
                if (ident === "[[missing ident]]") {
                    throw new Error("No ident is provided by referenced loader. " +
                        "When using a function for Rule.use in config you need to " +
                        "provide an 'ident' property for referenced loader options.");
                }
                obj.options = compiler.__internal__ruleSet.references.get(ident);
                if (obj.options === undefined) {
                    throw new Error("Invalid ident is provided by referenced loader");
                }
                obj.ident = ident;
            }
            // CHANGE: `rspack_core` returns empty string for `undefined` type.
            // Comply to webpack test case: tests/webpack-test/cases/loaders/cjs-loader-type/index.js
            obj.type = value.type === "" ? undefined : value.type;
            if (obj.options === null)
                obj.query = "";
            else if (obj.options === undefined)
                obj.query = "";
            else if (typeof obj.options === "string")
                obj.query = `?${obj.options}`;
            else if (obj.ident)
                obj.query = `??${obj.ident}`;
            else if (typeof obj.options === "object" && obj.options.ident)
                obj.query = `??${obj.options.ident}`;
            else
                obj.query = `?${JSON.stringify(obj.options)}`;
        }
    });
    obj.request = loader;
    if (Object.preventExtensions) {
        Object.preventExtensions(obj);
    }
    return obj;
}
class LoaderObject {
    constructor(loaderItem, compiler) {
        _LoaderObject_loaderItem.set(this, void 0);
        const { request, path, query, fragment, options, ident, normal, pitch, raw, type } = createLoaderObject(loaderItem, compiler);
        this.request = request;
        this.path = path;
        this.query = query;
        this.fragment = fragment;
        this.options = options;
        this.ident = ident;
        this.normal = normal;
        this.pitch = pitch;
        this.raw = raw;
        this.type = type;
        __classPrivateFieldSet(this, _LoaderObject_loaderItem, loaderItem, "f");
    }
    get pitchExecuted() {
        return __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").pitchExecuted;
    }
    set pitchExecuted(value) {
        (0, node_assert_1.default)(value);
        __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").pitchExecuted = true;
    }
    get normalExecuted() {
        return __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").normalExecuted;
    }
    set normalExecuted(value) {
        (0, node_assert_1.default)(value);
        __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").normalExecuted = true;
    }
    // A data object shared between the pitch and the normal phase
    get data() {
        return new Proxy((__classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").data = __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").data ?? {}), {
            set: (_, property, value) => {
                if (typeof property === "string") {
                    __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").data[property] = value;
                }
                return true;
            },
            get: (_, property) => {
                if (typeof property === "string") {
                    return __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").data[property];
                }
            }
        });
    }
    // A data object shared between the pitch and the normal phase
    set data(data) {
        __classPrivateFieldGet(this, _LoaderObject_loaderItem, "f").data = data;
    }
    shouldYield() {
        return this.request.startsWith(adapterRuleUse_1.BUILTIN_LOADER_PREFIX);
    }
    static __from_binding(loaderItem, compiler) {
        return new this(loaderItem, compiler);
    }
    static __to_binding(loader) {
        return __classPrivateFieldGet(loader, _LoaderObject_loaderItem, "f");
    }
}
exports.LoaderObject = LoaderObject;
_LoaderObject_loaderItem = new WeakMap();
class JsSourceMap {
    static __from_binding(map) {
        return (0, util_1.isNil)(map) ? undefined : (0, util_1.toObject)(map);
    }
    static __to_binding(map) {
        return (0, util_1.serializeObject)(map);
    }
}
const loadLoaderAsync = (0, node_util_1.promisify)(loadLoader_1.default);
const runSyncOrAsync = (0, node_util_1.promisify)(function runSyncOrAsync(fn, context, args, callback) {
    let isSync = true;
    let isDone = false;
    let isError = false; // internal error
    let reportedError = false;
    context.async = function async() {
        if (isDone) {
            if (reportedError)
                return undefined; // ignore
            throw new Error("async(): The callback was already called.");
        }
        isSync = false;
        return innerCallback;
    };
    const innerCallback = (err, ...args) => {
        if (isDone) {
            if (reportedError)
                return; // ignore
            throw new Error("callback(): The callback was already called.");
        }
        isDone = true;
        isSync = false;
        try {
            callback(err, args);
        }
        catch (e) {
            isError = true;
            throw e;
        }
    };
    context.callback = innerCallback;
    try {
        const result = (function LOADER_EXECUTION() {
            return fn.apply(context, args);
        })();
        if (isSync) {
            isDone = true;
            if (result === undefined) {
                callback(null, []);
                return;
            }
            if (result &&
                typeof result === "object" &&
                typeof result.then === "function") {
                result.then((r) => {
                    callback(null, [r]);
                }, callback);
                return;
            }
            callback(null, [result]);
            return;
        }
    }
    catch (e) {
        // use string for napi getter
        const err = e;
        if ("hideStack" in err && err.hideStack) {
            err.hideStack = "true";
        }
        if (isError)
            throw e;
        if (isDone) {
            // loader is already "done", so we cannot use the callback function
            // for better debugging we print the error on the console
            if (e instanceof Error)
                console.error(e.stack);
            else
                console.error(e);
            return;
        }
        isDone = true;
        reportedError = true;
        callback(e, []);
    }
});
function dirname(path) {
    if (path === "/")
        return "/";
    const i = path.lastIndexOf("/");
    const j = path.lastIndexOf("\\");
    const i2 = path.indexOf("/");
    const j2 = path.indexOf("\\");
    const idx = i > j ? i : j;
    const idx2 = i > j ? i2 : j2;
    if (idx < 0)
        return path;
    if (idx === idx2)
        return path.slice(0, idx + 1);
    return path.slice(0, idx);
}
function getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
    if (loaderContext.loaders?.length &&
        index < loaderContext.loaders.length &&
        index >= 0 &&
        loaderContext.loaders[index]) {
        return loaderContext.loaders[index];
    }
    return null;
}
async function runLoaders(compiler, context) {
    const loaderState = context.loaderState;
    //
    const { resource } = context.resourceData;
    const splittedResource = resource && parsePathQueryFragment(resource);
    const resourcePath = splittedResource ? splittedResource.path : undefined;
    const resourceQuery = splittedResource ? splittedResource.query : undefined;
    const resourceFragment = splittedResource
        ? splittedResource.fragment
        : undefined;
    const contextDirectory = resourcePath ? dirname(resourcePath) : null;
    // execution state
    const fileDependencies = context.fileDependencies;
    const contextDependencies = context.contextDependencies;
    const missingDependencies = context.missingDependencies;
    const buildDependencies = context.buildDependencies;
    /// Construct `loaderContext`
    const loaderContext = {};
    loaderContext.loaders = context.loaderItems.map(item => {
        return LoaderObject.__from_binding(item, compiler);
    });
    loaderContext.hot = context.hot;
    loaderContext.context = contextDirectory;
    loaderContext.resourcePath = resourcePath;
    loaderContext.resourceQuery = resourceQuery;
    loaderContext.resourceFragment = resourceFragment;
    loaderContext.dependency = loaderContext.addDependency =
        function addDependency(file) {
            fileDependencies.push(file);
        };
    loaderContext.addContextDependency = function addContextDependency(context) {
        contextDependencies.push(context);
    };
    loaderContext.addMissingDependency = function addMissingDependency(context) {
        missingDependencies.push(context);
    };
    loaderContext.addBuildDependency = function addBuildDependency(file) {
        buildDependencies.push(file);
    };
    loaderContext.getDependencies = function getDependencies() {
        return fileDependencies.slice();
    };
    loaderContext.getContextDependencies = function getContextDependencies() {
        return contextDependencies.slice();
    };
    loaderContext.getMissingDependencies = function getMissingDependencies() {
        return missingDependencies.slice();
    };
    loaderContext.clearDependencies = function clearDependencies() {
        fileDependencies.length = 0;
        contextDependencies.length = 0;
        missingDependencies.length = 0;
        context.cacheable = true;
    };
    loaderContext.importModule = function importModule(request, userOptions, callback) {
        const options = userOptions ? userOptions : {};
        if (!callback) {
            return new Promise((resolve, reject) => {
                compiler
                    ._lastCompilation.__internal_getInner()
                    .importModule(request, options.layer, options.publicPath, options.baseUri, context._module.moduleIdentifier, loaderContext.context, (err, res) => {
                    if (err)
                        reject(err);
                    else {
                        for (const dep of res.buildDependencies) {
                            this.addBuildDependency(dep);
                        }
                        for (const dep of res.contextDependencies) {
                            this.addContextDependency(dep);
                        }
                        for (const dep of res.missingDependencies) {
                            this.addMissingDependency(dep);
                        }
                        for (const dep of res.fileDependencies) {
                            this.addDependency(dep);
                        }
                        if (res.cacheable === false) {
                            this.cacheable(false);
                        }
                        resolve(compiler.__internal__getModuleExecutionResult(res.id));
                    }
                });
            });
        }
        return compiler
            ._lastCompilation.__internal_getInner()
            .importModule(request, options.layer, options.publicPath, options.baseUri, context._module.moduleIdentifier, loaderContext.context, (err, res) => {
            if (err) {
                callback(err, undefined);
            }
            else {
                for (const dep of res.buildDependencies) {
                    this.addBuildDependency(dep);
                }
                for (const dep of res.contextDependencies) {
                    this.addContextDependency(dep);
                }
                for (const dep of res.missingDependencies) {
                    this.addMissingDependency(dep);
                }
                for (const dep of res.fileDependencies) {
                    this.addDependency(dep);
                }
                if (res.cacheable === false) {
                    this.cacheable(false);
                }
                callback(undefined, compiler.__internal__getModuleExecutionResult(res.id));
            }
        });
    };
    Object.defineProperty(loaderContext, "resource", {
        enumerable: true,
        get: () => {
            if (loaderContext.resourcePath === undefined)
                return undefined;
            return (loaderContext.resourcePath.replace(/#/g, "\u200b#") +
                loaderContext.resourceQuery.replace(/#/g, "\u200b#") +
                loaderContext.resourceFragment);
        },
        set: value => {
            const splittedResource = value && parsePathQueryFragment(value);
            loaderContext.resourcePath = splittedResource
                ? splittedResource.path
                : undefined;
            loaderContext.resourceQuery = splittedResource
                ? splittedResource.query
                : undefined;
            loaderContext.resourceFragment = splittedResource
                ? splittedResource.fragment
                : undefined;
        }
    });
    Object.defineProperty(loaderContext, "request", {
        enumerable: true,
        get: () => loaderContext.loaders
            .map(o => o.request)
            .concat(loaderContext.resource || "")
            .join("!")
    });
    Object.defineProperty(loaderContext, "remainingRequest", {
        enumerable: true,
        get: () => {
            if (loaderContext.loaderIndex >= loaderContext.loaders.length - 1 &&
                !loaderContext.resource)
                return "";
            return loaderContext.loaders
                .slice(loaderContext.loaderIndex + 1)
                .map(o => o.request)
                .concat(loaderContext.resource || "")
                .join("!");
        }
    });
    Object.defineProperty(loaderContext, "currentRequest", {
        enumerable: true,
        get: () => loaderContext.loaders
            .slice(loaderContext.loaderIndex)
            .map(o => o.request)
            .concat(loaderContext.resource || "")
            .join("!")
    });
    Object.defineProperty(loaderContext, "previousRequest", {
        enumerable: true,
        get: () => loaderContext.loaders
            .slice(0, loaderContext.loaderIndex)
            .map(o => o.request)
            .join("!")
    });
    Object.defineProperty(loaderContext, "query", {
        enumerable: true,
        get: () => {
            const entry = loaderContext.loaders[loaderContext.loaderIndex];
            return entry.options && typeof entry.options === "object"
                ? entry.options
                : entry.query;
        }
    });
    loaderContext.version = 2;
    loaderContext.sourceMap = compiler.options.devtool
        ? (0, adapterRuleUse_1.isUseSourceMap)(compiler.options.devtool)
        : context._module.useSourceMap ?? false;
    loaderContext.mode = compiler.options.mode;
    Object.assign(loaderContext, compiler.options.loader);
    const getResolveContext = () => {
        return {
            fileDependencies: {
                // @ts-expect-error: Mocking insert-only `Set<T>`
                add: d => {
                    loaderContext.addDependency(d);
                }
            },
            contextDependencies: {
                // @ts-expect-error: Mocking insert-only `Set<T>`
                add: d => {
                    loaderContext.addContextDependency(d);
                }
            },
            missingDependencies: {
                // @ts-expect-error: Mocking insert-only `Set<T>`
                add: d => {
                    loaderContext.addMissingDependency(d);
                }
            }
        };
    };
    const resolver = compiler._lastCompilation.resolverFactory.get("normal");
    loaderContext.resolve = function resolve(context, request, callback) {
        resolver.resolve({}, context, request, getResolveContext(), callback);
    };
    loaderContext.getResolve = function getResolve(options) {
        const child = options ? resolver.withOptions(options) : resolver;
        return (context, request, callback) => {
            if (callback) {
                child.resolve({}, context, request, getResolveContext(), callback);
                return;
            }
            // TODO: (type) our native resolver return value is "string | false" but webpack type is "string"
            return new Promise((resolve, reject) => {
                child.resolve({}, context, request, getResolveContext(), (err, result) => {
                    if (err)
                        reject(err);
                    else
                        resolve(result);
                });
            });
        };
    };
    loaderContext.getLogger = function getLogger(name) {
        return compiler._lastCompilation.getLogger([name, resource].filter(Boolean).join("|"));
    };
    loaderContext.rootContext = compiler.context;
    loaderContext.emitError = function emitError(err) {
        let error = err;
        if (!(error instanceof Error)) {
            error = new RspackError_1.NonErrorEmittedError(error);
        }
        error.name = "ModuleError";
        error.message = `${error.message} (from: ${(0, util_1.stringifyLoaderObject)(loaderContext.loaders[loaderContext.loaderIndex])})`;
        error = (0, util_1.concatErrorMsgAndStack)(error);
        error.moduleIdentifier = this._module.identifier();
        compiler._lastCompilation.__internal__pushRspackDiagnostic({
            error,
            severity: binding_1.JsRspackSeverity.Error
        });
    };
    loaderContext.emitWarning = function emitWarning(warn) {
        let warning = warn;
        if (!(warning instanceof Error)) {
            warning = new RspackError_1.NonErrorEmittedError(warning);
        }
        warning.name = "ModuleWarning";
        warning.message = `${warning.message} (from: ${(0, util_1.stringifyLoaderObject)(loaderContext.loaders[loaderContext.loaderIndex])})`;
        warning = (0, util_1.concatErrorMsgAndStack)(warning);
        warning.moduleIdentifier = this._module.identifier();
        compiler._lastCompilation.__internal__pushRspackDiagnostic({
            error: warning,
            severity: binding_1.JsRspackSeverity.Warn
        });
    };
    loaderContext.emitFile = function emitFile(name, content, sourceMap, assetInfo) {
        let source = undefined;
        if (sourceMap) {
            if (typeof sourceMap === "string" &&
                (loaderContext.sourceMap ||
                    (compiler.options.devtool &&
                        (0, adapterRuleUse_1.isUseSimpleSourceMap)(compiler.options.devtool)))) {
                source = new webpack_sources_1.OriginalSource(content, (0, identifier_1.makePathsRelative)(contextDirectory, sourceMap, compiler));
            }
            if (this.sourceMap) {
                source = new webpack_sources_1.SourceMapSource(
                // @ts-expect-error webpack-sources type declaration is wrong
                content, name, (0, identifier_1.makePathsRelative)(contextDirectory, sourceMap, compiler));
            }
        }
        else {
            source = new webpack_sources_1.RawSource(
            // @ts-expect-error webpack-sources type declaration is wrong
            content);
        }
        compiler._lastCompilation.__internal__emit_asset_from_loader(name, source, assetInfo, context._moduleIdentifier);
    };
    loaderContext.fs = compiler.inputFileSystem;
    loaderContext.experiments = {
        emitDiagnostic: (diagnostic) => {
            const d = Object.assign({}, diagnostic, {
                message: diagnostic.severity === "warning"
                    ? `ModuleWarning: ${diagnostic.message}`
                    : `ModuleError: ${diagnostic.message}`,
                moduleIdentifier: context._module.moduleIdentifier
            });
            compiler._lastCompilation.__internal__pushDiagnostic((0, binding_1.formatDiagnostic)(d));
        }
    };
    const getAbsolutify = (0, memoize_1.memoize)(() => identifier_1.absolutify.bindCache(compiler.root));
    const getAbsolutifyInContext = (0, memoize_1.memoize)(() => identifier_1.absolutify.bindContextCache(contextDirectory, compiler.root));
    const getContextify = (0, memoize_1.memoize)(() => identifier_1.contextify.bindCache(compiler.root));
    const getContextifyInContext = (0, memoize_1.memoize)(() => identifier_1.contextify.bindContextCache(contextDirectory, compiler.root));
    loaderContext.utils = {
        absolutify: (context, request) => {
            return context === contextDirectory
                ? getAbsolutifyInContext()(request)
                : getAbsolutify()(context, request);
        },
        contextify: (context, request) => {
            return context === contextDirectory
                ? getContextifyInContext()(request)
                : getContextify()(context, request);
        },
        createHash: type => {
            return (0, createHash_1.createHash)(type || compiler._lastCompilation.outputOptions.hashFunction);
        }
    };
    loaderContext._compiler = compiler;
    loaderContext._compilation = compiler._lastCompilation;
    loaderContext._module = Module_1.Module.__from_binding(context._module, compiler._lastCompilation);
    loaderContext.getOptions = () => {
        const loader = getCurrentLoader(loaderContext);
        let options = loader?.options;
        if (typeof options === "string") {
            if (options.startsWith("{") && options.endsWith("}")) {
                try {
                    const parseJson = require("../../compiled/json-parse-even-better-errors");
                    options = parseJson(options);
                }
                catch (e) {
                    throw new Error(`Cannot parse string options: ${e.message}`);
                }
            }
            else {
                options = node_querystring_1.default.parse(options);
            }
        }
        if (options === null || options === undefined) {
            options = {};
        }
        return options;
    };
    let compilation = compiler._lastCompilation;
    let step = 0;
    while (compilation) {
        NormalModule_1.NormalModule.getCompilationHooks(compilation).loader.call(loaderContext, loaderContext._module);
        compilation = compilation.compiler.parentCompilation;
        step++;
        if (step > 1000) {
            throw Error("Too many nested child compiler, exceeded max limitation 1000");
        }
    }
    /// Sync with `context`
    Object.defineProperty(loaderContext, "loaderIndex", {
        enumerable: true,
        get: () => context.loaderIndex,
        set: loaderIndex => (context.loaderIndex = loaderIndex)
    });
    Object.defineProperty(loaderContext, "cacheable", {
        enumerable: true,
        get: () => (cacheable) => {
            if (cacheable === false) {
                context.cacheable = cacheable;
            }
        }
    });
    Object.defineProperty(loaderContext, "data", {
        enumerable: true,
        get: () => loaderContext.loaders[loaderContext.loaderIndex].data,
        set: data => (loaderContext.loaders[loaderContext.loaderIndex].data = data)
    });
    Object.defineProperty(loaderContext, "__internal__parseMeta", {
        enumerable: true,
        get: () => context.__internal__parseMeta
    });
    switch (loaderState) {
        case binding_1.JsLoaderState.Pitching: {
            while (loaderContext.loaderIndex < loaderContext.loaders.length) {
                const currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
                if (currentLoaderObject.shouldYield())
                    break;
                if (currentLoaderObject.pitchExecuted) {
                    loaderContext.loaderIndex += 1;
                    continue;
                }
                await loadLoaderAsync(currentLoaderObject);
                const fn = currentLoaderObject.pitch;
                currentLoaderObject.pitchExecuted = true;
                if (!fn)
                    continue;
                const args = (await runSyncOrAsync(fn, loaderContext, [
                    loaderContext.remainingRequest,
                    loaderContext.previousRequest,
                    currentLoaderObject.data
                ])) || [];
                const hasArg = args.some(value => value !== undefined);
                if (hasArg) {
                    const [content, sourceMap, additionalData] = args;
                    context.content = (0, util_1.isNil)(content) ? null : (0, util_1.toBuffer)(content);
                    context.sourceMap = (0, util_1.serializeObject)(sourceMap);
                    context.additionalData = additionalData;
                    break;
                }
            }
            break;
        }
        case binding_1.JsLoaderState.Normal: {
            let content = context.content;
            let sourceMap = JsSourceMap.__from_binding(context.sourceMap);
            let additionalData = context.additionalData;
            while (loaderContext.loaderIndex >= 0) {
                const currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
                if (currentLoaderObject.shouldYield())
                    break;
                if (currentLoaderObject.normalExecuted) {
                    loaderContext.loaderIndex--;
                    continue;
                }
                await loadLoaderAsync(currentLoaderObject);
                const fn = currentLoaderObject.normal;
                currentLoaderObject.normalExecuted = true;
                if (!fn)
                    continue;
                const args = [content, sourceMap, additionalData];
                convertArgs(args, !!currentLoaderObject.raw);
                [content, sourceMap, additionalData] =
                    (await runSyncOrAsync(fn, loaderContext, args)) || [];
            }
            context.content = (0, util_1.isNil)(content) ? null : (0, util_1.toBuffer)(content);
            context.sourceMap = JsSourceMap.__to_binding(sourceMap);
            context.additionalData = additionalData;
            break;
        }
        default:
            throw new Error(`Unexpected loader runner state: ${loaderState}`);
    }
    // update loader state
    context.loaderItems = loaderContext.loaders.map(item => LoaderObject.__to_binding(item));
    return context;
}
exports.runLoaders = runLoaders;
function utf8BufferToString(buf) {
    const str = buf.toString("utf-8");
    if (str.charCodeAt(0) === 0xfeff) {
        return str.slice(1);
    }
    return str;
}
function convertArgs(args, raw) {
    if (!raw && Buffer.isBuffer(args[0]))
        args[0] = utf8BufferToString(args[0]);
    else if (raw && typeof args[0] === "string")
        args[0] = Buffer.from(args[0], "utf-8");
}
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\u200b.|[^?#\u200b])*)(\?(?:\u200b.|[^#\u200b])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
    const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
    return {
        path: match?.[1].replace(/\u200b(.)/g, "$1") || "",
        query: match?.[2] ? match[2].replace(/\u200b(.)/g, "$1") : "",
        fragment: match?.[3] || ""
    };
}
exports.parsePathQueryFragment = parsePathQueryFragment;
