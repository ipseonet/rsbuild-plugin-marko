"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unsupported = exports.deprecatedWarn = exports.asArray = exports.stringifyLoaderObject = exports.indent = exports.concatErrorMsgAndStack = exports.isJsStatsError = exports.isPromiseLike = exports.serializeObject = exports.toObject = exports.toBuffer = exports.isNil = exports.mapValues = void 0;
function mapValues(record, fn) {
    return Object.fromEntries(Object.entries(record).map(([key, value]) => [key, fn(value)]));
}
exports.mapValues = mapValues;
function isNil(value) {
    return value === null || value === undefined;
}
exports.isNil = isNil;
const toBuffer = (bufLike) => {
    if (Buffer.isBuffer(bufLike)) {
        return bufLike;
    }
    if (typeof bufLike === "string") {
        return Buffer.from(bufLike);
    }
    throw new Error("Buffer or string expected");
};
exports.toBuffer = toBuffer;
const toObject = (input) => {
    let s;
    if (Buffer.isBuffer(input)) {
        s = input.toString("utf8");
    }
    else if (input && typeof input === "object") {
        return input;
    }
    else if (typeof input === "string") {
        s = input;
    }
    else {
        throw new Error("Buffer or string or object expected");
    }
    return JSON.parse(s);
};
exports.toObject = toObject;
function serializeObject(map) {
    if (isNil(map)) {
        return undefined;
    }
    if (typeof map === "string") {
        if (map) {
            return (0, exports.toBuffer)(map);
        }
        return undefined;
    }
    return (0, exports.toBuffer)(JSON.stringify(map));
}
exports.serializeObject = serializeObject;
function isPromiseLike(value) {
    return (typeof value === "object" &&
        value !== null &&
        typeof value.then === "function");
}
exports.isPromiseLike = isPromiseLike;
function isJsStatsError(err) {
    return !(err instanceof Error) && err.formatted;
}
exports.isJsStatsError = isJsStatsError;
function concatErrorMsgAndStack(err) {
    if (typeof err === "string") {
        return new Error(err);
    }
    const hideStack = "hideStack" in err && err.hideStack;
    if (!hideStack && "stack" in err) {
        // This is intended to be different than webpack,
        // here we want to treat the almost the same as `Error.stack` just without the stack.
        // Webpack uses `Error.message`, however it does not contain the `Error.prototype.name`
        // `xxx` -> `Error: xxx`. So they behave the same even if `hideStack` is set to `true`.
        err.message = err.stack || err.toString();
    }
    else {
        // This is intended to be different than webpack,
        // here we want to treat the almost the same as `Error.stack` just without the stack.
        // Webpack uses `Error.message`, however it does not contain the `Error.prototype.name`
        // `xxx` -> `Error: xxx`. So they behave the same even if `hideStack` is set to `true`.
        err.message = err.toString();
    }
    // maybe `null`, use `undefined` to compatible with `Option<String>`
    err.stack = err.stack || undefined;
    return err;
}
exports.concatErrorMsgAndStack = concatErrorMsgAndStack;
function indent(str, prefix) {
    const rem = str.replace(/\n([^\n])/g, `\n${prefix}$1`);
    return prefix + rem;
}
exports.indent = indent;
function stringifyLoaderObject(o) {
    return o.path + o.query + o.fragment;
}
exports.stringifyLoaderObject = stringifyLoaderObject;
function asArray(item) {
    return Array.isArray(item) ? item : [item];
}
exports.asArray = asArray;
const getDeprecationStatus = () => {
    const defaultEnableDeprecatedWarning = true;
    if (process.env.RSPACK_DEP_WARNINGS === "false" ||
        process.env.RSPACK_DEP_WARNINGS === "0") {
        return false;
    }
    return ((process.env.RSPACK_DEP_WARNINGS ?? `${defaultEnableDeprecatedWarning}`) !==
        "false");
};
const yellow = (content) => `\u001b[1m\u001b[33m${content}\u001b[39m\u001b[22m`;
const deprecatedWarn = (content, enable = getDeprecationStatus()) => {
    if (enable) {
        console.warn(yellow(content));
        console.warn(indent("Set env `RSPACK_DEP_WARNINGS` to 'false' to temporarily disable deprecation warnings.\n", "    "));
    }
};
exports.deprecatedWarn = deprecatedWarn;
const unsupported = (name, issue) => {
    let s = `${name} is not supported by rspack.`;
    if (issue) {
        s += ` Please refer to issue ${issue} for more information.`;
    }
    throw new Error(s);
};
exports.unsupported = unsupported;
