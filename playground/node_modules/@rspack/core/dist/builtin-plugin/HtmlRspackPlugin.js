"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HtmlRspackPlugin = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const binding_1 = require("@rspack/binding");
const liteTapable = __importStar(require("@rspack/lite-tapable"));
const zod_1 = require("../../compiled/zod");
const Compilation_1 = require("../Compilation");
const validate_1 = require("../util/validate");
const base_1 = require("./base");
const templateRenderFunction = zod_1.z
    .function()
    .args(zod_1.z.record(zod_1.z.string(), zod_1.z.any()))
    .returns(zod_1.z.string().or(zod_1.z.promise(zod_1.z.string())));
const templateParamFunction = zod_1.z
    .function()
    .args(zod_1.z.record(zod_1.z.string(), zod_1.z.any()))
    .returns(zod_1.z.record(zod_1.z.string(), zod_1.z.any()).or(zod_1.z.promise(zod_1.z.record(zod_1.z.string(), zod_1.z.any()))));
const htmlRspackPluginOptions = zod_1.z.strictObject({
    filename: zod_1.z.string().optional(),
    template: zod_1.z
        .string()
        .refine(val => !val.includes("!"), () => ({
        message: "HtmlRspackPlugin does not support template path with loader yet"
    }))
        .optional(),
    templateContent: zod_1.z.string().or(templateRenderFunction).optional(),
    templateParameters: zod_1.z
        .record(zod_1.z.string())
        .or(zod_1.z.boolean())
        .or(templateParamFunction)
        .optional(),
    inject: zod_1.z.enum(["head", "body"]).or(zod_1.z.boolean()).optional(),
    publicPath: zod_1.z.string().optional(),
    base: zod_1.z
        .string()
        .or(zod_1.z.strictObject({
        href: zod_1.z.string().optional(),
        target: zod_1.z.enum(["_self", "_blank", "_parent", "_top"]).optional()
    }))
        .optional(),
    scriptLoading: zod_1.z
        .enum(["blocking", "defer", "module", "systemjs-module"])
        .optional(),
    chunks: zod_1.z.string().array().optional(),
    excludeChunks: zod_1.z.string().array().optional(),
    sri: zod_1.z.enum(["sha256", "sha384", "sha512"]).optional(),
    minify: zod_1.z.boolean().optional(),
    title: zod_1.z.string().optional(),
    favicon: zod_1.z.string().optional(),
    meta: zod_1.z.record(zod_1.z.string().or(zod_1.z.record(zod_1.z.string()))).optional(),
    hash: zod_1.z.boolean().optional()
});
const HtmlRspackPluginImpl = (0, base_1.create)(binding_1.BuiltinPluginName.HtmlRspackPlugin, function (c = {}) {
    (0, validate_1.validate)(c, htmlRspackPluginOptions);
    const meta = {};
    for (const key in c.meta) {
        const value = c.meta[key];
        if (typeof value === "string") {
            meta[key] = {
                name: key,
                content: value
            };
        }
        else {
            meta[key] = {
                name: key,
                ...value
            };
        }
    }
    const scriptLoading = c.scriptLoading ?? "defer";
    const configInject = c.inject ?? true;
    const inject = configInject === true
        ? scriptLoading === "blocking"
            ? "body"
            : "head"
        : configInject === false
            ? "false"
            : configInject;
    const base = typeof c.base === "string" ? { href: c.base } : c.base;
    let compilation = null;
    this.hooks.compilation.tap("HtmlRspackPlugin", compilationInstance => {
        compilation = compilationInstance;
        compilationOptionsMap.set(compilation, c);
    });
    this.hooks.done.tap("HtmlRspackPlugin", stats => {
        compilationHooksMap.delete(stats.compilation);
        compilationOptionsMap.delete(stats.compilation);
    });
    function generateRenderData(data) {
        const json = JSON.parse(data);
        if (typeof c.templateParameters !== "function") {
            json.compilation = compilation;
        }
        const renderTag = function () {
            return htmlTagObjectToString(this);
        };
        const renderTagList = function () {
            return this.join("");
        };
        if (Array.isArray(json.htmlRspackPlugin?.tags?.headTags)) {
            for (const tag of json.htmlRspackPlugin.tags.headTags) {
                tag.toString = renderTag;
            }
            json.htmlRspackPlugin.tags.headTags.toString = renderTagList;
        }
        if (Array.isArray(json.htmlRspackPlugin?.tags?.bodyTags)) {
            for (const tag of json.htmlRspackPlugin.tags.bodyTags) {
                tag.toString = renderTag;
            }
            json.htmlRspackPlugin.tags.bodyTags.toString = renderTagList;
        }
        return json;
    }
    let templateContent = c.templateContent;
    let templateFn = undefined;
    if (typeof templateContent === "function") {
        templateFn = async (data) => {
            try {
                const renderer = c.templateContent;
                if (c.templateParameters === false) {
                    return await renderer({});
                }
                return await renderer(generateRenderData(data));
            }
            catch (e) {
                const error = new Error(`HtmlRspackPlugin: render template function failed, ${e.message}`);
                error.stack = e.stack;
                throw error;
            }
        };
        templateContent = "";
    }
    else if (c.template) {
        const filename = c.template.split("?")[0];
        if ([".js", ".cjs"].includes(node_path_1.default.extname(filename))) {
            templateFn = async (data) => {
                const context = this.options.context || process.cwd();
                const templateFilePath = node_path_1.default.resolve(context, filename);
                if (!node_fs_1.default.existsSync(templateFilePath)) {
                    throw new Error(`HtmlRspackPlugin: could not load file \`${filename}\` from \`${context}\``);
                }
                try {
                    const renderer = require(templateFilePath);
                    if (c.templateParameters === false) {
                        return await renderer({});
                    }
                    return await renderer(generateRenderData(data));
                }
                catch (e) {
                    const error = new Error(`HtmlRspackPlugin: render template function failed, ${e.message}`);
                    error.stack = e.stack;
                    throw error;
                }
            };
        }
    }
    const rawTemplateParameters = c.templateParameters;
    let templateParameters;
    if (typeof rawTemplateParameters === "function") {
        templateParameters = async (data) => {
            const newData = await rawTemplateParameters(JSON.parse(data));
            return JSON.stringify(newData);
        };
    }
    else {
        templateParameters = rawTemplateParameters;
    }
    return {
        filename: c.filename,
        template: c.template,
        hash: c.hash,
        title: c.title,
        favicon: c.favicon,
        publicPath: c.publicPath,
        chunks: c.chunks,
        excludeChunks: c.excludeChunks,
        sri: c.sri,
        minify: c.minify,
        meta,
        scriptLoading,
        inject,
        base,
        templateFn,
        templateContent,
        templateParameters
    };
});
function htmlTagObjectToString(tag) {
    const attributes = Object.keys(tag.attributes || {})
        .filter(attributeName => tag.attributes[attributeName] === "" || tag.attributes[attributeName])
        .map(attributeName => {
        if (tag.attributes[attributeName] === "true") {
            return attributeName;
        }
        return `${attributeName}="${tag.attributes[attributeName]}"`;
    });
    const res = `<${[tag.tagName].concat(attributes).join(" ")}${tag.voidTag && !tag.innerHTML ? "/" : ""}>${tag.innerHTML || ""}${tag.voidTag && !tag.innerHTML ? "" : `</${tag.tagName}>`}`;
    return res;
}
const compilationHooksMap = new WeakMap();
const compilationOptionsMap = new WeakMap();
const HtmlRspackPlugin = HtmlRspackPluginImpl;
exports.HtmlRspackPlugin = HtmlRspackPlugin;
const voidTags = [
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
];
HtmlRspackPlugin.createHtmlTagObject = (tagName, attributes, innerHTML) => {
    return {
        tagName,
        voidTag: voidTags.includes(tagName),
        attributes: attributes || {},
        innerHTML
    };
};
HtmlRspackPlugin.getCompilationOptions = (compilation) => {
    if (!(compilation instanceof Compilation_1.Compilation)) {
        throw new TypeError("The 'compilation' argument must be an instance of Compilation");
    }
    return compilationOptionsMap.get(compilation);
};
HtmlRspackPlugin.getCompilationHooks = (compilation) => {
    if (!(compilation instanceof Compilation_1.Compilation)) {
        throw new TypeError("The 'compilation' argument must be an instance of Compilation");
    }
    let hooks = compilationHooksMap.get(compilation);
    if (hooks === undefined) {
        hooks = {
            beforeAssetTagGeneration: new liteTapable.AsyncSeriesWaterfallHook([
                "data"
            ]),
            alterAssetTags: new liteTapable.AsyncSeriesWaterfallHook(["data"]),
            alterAssetTagGroups: new liteTapable.AsyncSeriesWaterfallHook(["data"]),
            afterTemplateExecution: new liteTapable.AsyncSeriesWaterfallHook([
                "data"
            ]),
            beforeEmit: new liteTapable.AsyncSeriesWaterfallHook(["data"]),
            afterEmit: new liteTapable.AsyncSeriesWaterfallHook(["data"])
        };
        compilationHooksMap.set(compilation, hooks);
    }
    return hooks;
};
