"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitChunksPlugin = void 0;
const node_assert_1 = __importDefault(require("node:assert"));
const binding_1 = require("@rspack/binding");
const Chunk_1 = require("../Chunk");
const Module_1 = require("../Module");
const SplitChunkSize_1 = require("../util/SplitChunkSize");
const base_1 = require("./base");
class SplitChunksPlugin extends base_1.RspackBuiltinPlugin {
    constructor(options) {
        super();
        this.options = options;
        this.name = binding_1.BuiltinPluginName.SplitChunksPlugin;
        this.affectedHooks = "thisCompilation";
    }
    raw(compiler) {
        const rawOptions = toRawSplitChunksOptions(this.options, compiler);
        (0, node_assert_1.default)(typeof rawOptions !== "undefined");
        return (0, base_1.createBuiltinPlugin)(this.name, rawOptions);
    }
}
exports.SplitChunksPlugin = SplitChunksPlugin;
function toRawSplitChunksOptions(sc, compiler) {
    if (!sc) {
        return;
    }
    function getName(name) {
        if (typeof name === "function") {
            return (ctx) => {
                if (typeof ctx.module === "undefined") {
                    return name(undefined);
                }
                return name(Module_1.Module.__from_binding(ctx.module, compiler._lastCompilation), getChunks(ctx.chunks), ctx.cacheGroupKey);
            };
        }
        return name;
    }
    function getTest(test) {
        if (typeof test === "function") {
            return (ctx) => {
                if (typeof ctx.module === "undefined") {
                    return test(undefined);
                }
                return test(Module_1.Module.__from_binding(ctx.module, compiler._lastCompilation));
            };
        }
        return test;
    }
    function getChunks(chunks) {
        if (typeof chunks === "function") {
            return (chunk) => chunks(Chunk_1.Chunk.__from_binding(chunk, compiler._lastCompilation.__internal_getInner()));
        }
        return chunks;
    }
    const { name, chunks, defaultSizeTypes, cacheGroups = {}, fallbackCacheGroup, minSize, maxSize, maxAsyncSize, maxInitialSize, ...passThrough } = sc;
    return {
        name: getName(name),
        chunks: getChunks(chunks),
        defaultSizeTypes: defaultSizeTypes || ["javascript", "unknown"],
        cacheGroups: Object.entries(cacheGroups)
            .filter(([_key, group]) => group !== false)
            .map(([key, group]) => {
            group = group;
            const { test, name, chunks, minSize, maxSize, maxAsyncSize, maxInitialSize, ...passThrough } = group;
            const rawGroup = {
                key,
                test: getTest(test),
                name: getName(name),
                chunks: getChunks(chunks),
                minSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(minSize),
                maxSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(maxSize),
                maxAsyncSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(maxAsyncSize),
                maxInitialSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(maxInitialSize),
                ...passThrough
            };
            return rawGroup;
        }),
        fallbackCacheGroup: {
            chunks: getChunks(chunks),
            ...fallbackCacheGroup
        },
        minSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(minSize),
        maxSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(maxSize),
        maxAsyncSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(maxAsyncSize),
        maxInitialSize: SplitChunkSize_1.JsSplitChunkSizes.__to_binding(maxInitialSize),
        ...passThrough
    };
}
