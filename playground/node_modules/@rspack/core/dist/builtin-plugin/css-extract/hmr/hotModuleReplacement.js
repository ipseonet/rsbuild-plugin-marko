"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssReload = void 0;
const normalizeUrl_1 = require("./normalizeUrl");
const srcByModuleId = Object.create(null);
const noDocument = typeof document === "undefined";
const { forEach } = Array.prototype;
function debounce(fn, time) {
    let timeout = 0;
    return function (...args) {
        const self = this;
        const functionCall = function functionCall() {
            return fn.apply(self, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(functionCall, time);
    };
}
function noop() { }
function getCurrentScriptUrl(moduleId) {
    let src = srcByModuleId[moduleId];
    if (!src) {
        if (document.currentScript) {
            ({ src } = document.currentScript);
        }
        else {
            const scripts = document.getElementsByTagName("script");
            const lastScriptTag = scripts[scripts.length - 1];
            if (lastScriptTag) {
                ({ src } = lastScriptTag);
            }
        }
        srcByModuleId[moduleId] = src;
    }
    return (fileMap) => {
        if (!src) {
            return null;
        }
        const splitResult = src.match(/([^\\/]+)\.js$/);
        // biome-ignore lint/complexity/useOptionalChain: not use optionalChain to support legacy browser
        const filename = splitResult && splitResult[1];
        if (!filename || !fileMap) {
            return [src.replace(".js", ".css")];
        }
        return fileMap.split(",").map(mapRule => {
            const reg = new RegExp(`${filename}\\.js$`, "g");
            return (0, normalizeUrl_1.normalizeUrl)(src.replace(reg, `${mapRule.replace(/{fileName}/g, filename)}.css`));
        });
    };
}
function updateCss(el, url) {
    let normalizedUrl;
    if (!url) {
        if (!el.href) {
            return;
        }
        normalizedUrl = el.href.split("?")[0];
    }
    else {
        normalizedUrl = url;
    }
    if (!isUrlRequest(normalizedUrl)) {
        return;
    }
    if (el.isLoaded === false) {
        // We seem to be about to replace a css link that hasn't loaded yet.
        // We're probably changing the same file more than once.
        return;
    }
    if (!normalizedUrl || !(normalizedUrl.indexOf(".css") > -1)) {
        return;
    }
    el.visited = true;
    const newEl = el.cloneNode();
    newEl.isLoaded = false;
    newEl.addEventListener("load", () => {
        if (newEl.isLoaded) {
            return;
        }
        newEl.isLoaded = true;
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
    });
    newEl.addEventListener("error", () => {
        if (newEl.isLoaded) {
            return;
        }
        newEl.isLoaded = true;
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
    });
    newEl.href = `${normalizedUrl}?${Date.now()}`;
    const parent = el.parentNode;
    if (!parent) {
        return;
    }
    if (el.nextSibling) {
        parent.insertBefore(newEl, el.nextSibling);
    }
    else {
        parent.appendChild(newEl);
    }
}
function getReloadUrl(href, src) {
    let ret = "";
    const normalizedHref = (0, normalizeUrl_1.normalizeUrl)(href);
    src.some(url => {
        if (normalizedHref.indexOf(src) > -1) {
            ret = url;
        }
    });
    return ret;
}
function reloadStyle(src) {
    if (!src) {
        return false;
    }
    const elements = document.querySelectorAll("link");
    let loaded = false;
    forEach.call(elements, el => {
        if (!el.href) {
            return;
        }
        const url = getReloadUrl(el.href, src);
        if (!isUrlRequest(url)) {
            return;
        }
        if (el.visited === true) {
            return;
        }
        if (url) {
            updateCss(el, url);
            loaded = true;
        }
    });
    return loaded;
}
function reloadAll() {
    const elements = document.querySelectorAll("link");
    forEach.call(elements, el => {
        if (el.visited === true) {
            return;
        }
        updateCss(el);
    });
}
function isUrlRequest(url) {
    // An URL is not an request if
    // It is not http or https
    if (!/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url)) {
        return false;
    }
    return true;
}
function cssReload(moduleId, options) {
    if (noDocument) {
        console.log("no window.document found, will not HMR CSS");
        return noop;
    }
    const getScriptSrc = getCurrentScriptUrl(moduleId);
    function update() {
        const src = getScriptSrc(options.filename);
        const reloaded = reloadStyle(src);
        if (options.locals) {
            console.log("[HMR] Detected local css modules. Reload all css");
            reloadAll();
            return;
        }
        if (reloaded) {
            // biome-ignore lint/complexity/useOptionalChain: not use optionalChain to support legacy browser
            console.log("[HMR] css reload %s", src && src.join(" "));
        }
        else {
            console.log("[HMR] Reload all css");
            reloadAll();
        }
    }
    return debounce(update, 50);
}
exports.cssReload = cssReload;
