"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pitch = exports.hotLoader = exports.SINGLE_DOT_PATH_SEGMENT = exports.ABSOLUTE_PUBLIC_PATH = exports.AUTO_PUBLIC_PATH = exports.MODULE_TYPE = exports.BASE_URI = void 0;
const node_path_1 = __importDefault(require("node:path"));
const index_1 = require("./index");
const utils_1 = require("./utils");
exports.BASE_URI = "webpack://";
exports.MODULE_TYPE = "css/mini-extract";
exports.AUTO_PUBLIC_PATH = "__mini_css_extract_plugin_public_path_auto__";
exports.ABSOLUTE_PUBLIC_PATH = `${exports.BASE_URI}/mini-css-extract-plugin/`;
exports.SINGLE_DOT_PATH_SEGMENT = "__mini_css_extract_plugin_single_dot_path_segment__";
function hotLoader(content, context) {
    const localsJsonString = JSON.stringify(JSON.stringify(context.locals));
    return `${content}
    if(module.hot) {
      (function() {
        var localsJsonString = ${localsJsonString};
        // ${Date.now()}
        var cssReload = require(${(0, utils_1.stringifyRequest)(context.loaderContext, node_path_1.default.join(__dirname, "hmr/hotModuleReplacement.js"))}).cssReload(module.id, ${JSON.stringify(context.options ?? {})});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  `;
}
exports.hotLoader = hotLoader;
const loader = function loader(content) {
    if (this._compiler?.options?.experiments?.css &&
        this._module &&
        (this._module.type === "css" ||
            this._module.type === "css/auto" ||
            this._module.type === "css/global" ||
            this._module.type === "css/module")) {
        return content;
    }
};
const pitch = function (request, _, data) {
    if (this._compiler?.options?.experiments?.css &&
        this._module &&
        (this._module.type === "css" ||
            this._module.type === "css/auto" ||
            this._module.type === "css/global" ||
            this._module.type === "css/module")) {
        const e = new Error(`use type 'css' and \`CssExtractRspackPlugin\` together, please set \`experiments.css\` to \`false\` or set \`{ type: "javascript/auto" }\` for rules with \`CssExtractRspackPlugin\` in your rspack config (now \`CssExtractRspackPlugin\` does nothing).`);
        e.stack = undefined;
        this.emitWarning(e);
        return;
    }
    const options = this.getOptions();
    const emit = typeof options.emit !== "undefined" ? options.emit : true;
    const callback = this.async();
    const filepath = this.resourcePath;
    const parseMeta = this.__internal__parseMeta;
    let { publicPath } = this._compilation.outputOptions;
    if (typeof options.publicPath === "string") {
        // eslint-disable-next-line prefer-destructuring
        publicPath = options.publicPath;
    }
    else if (typeof options.publicPath === "function") {
        publicPath = options.publicPath(this.resourcePath, this.rootContext);
    }
    if (publicPath === "auto") {
        publicPath = exports.AUTO_PUBLIC_PATH;
    }
    let publicPathForExtract;
    if (typeof publicPath === "string") {
        const isAbsolutePublicPath = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/.test(publicPath);
        publicPathForExtract = isAbsolutePublicPath
            ? publicPath
            : `${exports.ABSOLUTE_PUBLIC_PATH}${publicPath.replace(/\./g, exports.SINGLE_DOT_PATH_SEGMENT)}`;
    }
    else {
        publicPathForExtract = publicPath;
    }
    const handleExports = (originalExports) => {
        let locals;
        let namedExport;
        const esModule = typeof options.esModule !== "undefined" ? options.esModule : true;
        let dependencies = [];
        try {
            // eslint-disable-next-line no-underscore-dangle
            const exports = originalExports.__esModule
                ? originalExports.default
                : originalExports;
            namedExport =
                // eslint-disable-next-line no-underscore-dangle
                originalExports.__esModule &&
                    (!originalExports.default || !("locals" in originalExports.default));
            if (namedExport) {
                for (const key of Object.keys(originalExports)) {
                    if (key !== "default") {
                        if (!locals) {
                            locals = {};
                        }
                        locals[key] = originalExports[key];
                    }
                }
            }
            else {
                locals = exports?.locals;
            }
            if (Array.isArray(exports) && emit) {
                const identifierCountMap = new Map();
                dependencies = exports
                    .map(([id, content, media, sourceMap, supports, layer]) => {
                    const identifier = id;
                    const context = this.rootContext;
                    const count = identifierCountMap.get(identifier) || 0;
                    identifierCountMap.set(identifier, count + 1);
                    return {
                        identifier,
                        context,
                        content,
                        media,
                        supports,
                        layer,
                        identifierIndex: count,
                        sourceMap: sourceMap
                            ? JSON.stringify(sourceMap)
                            : // eslint-disable-next-line no-undefined
                                undefined,
                        filepath
                    };
                })
                    .filter(item => item !== null);
            }
        }
        catch (e) {
            callback(e);
            return;
        }
        const result = (function makeResult() {
            if (locals) {
                if (namedExport) {
                    const identifiers = Array.from((function* generateIdentifiers() {
                        let identifierId = 0;
                        for (const key of Object.keys(locals)) {
                            identifierId += 1;
                            yield [`_${identifierId.toString(16)}`, key];
                        }
                    })());
                    const localsString = identifiers
                        .map(([id, key]) => `\nvar ${id} = ${(0, utils_1.stringifyLocal)(locals[key])};`)
                        .join("");
                    const exportsString = `export { ${identifiers
                        .map(([id, key]) => `${id} as ${JSON.stringify(key)}`)
                        .join(", ")} }`;
                    const defaultExport = typeof options.defaultExport !== "undefined"
                        ? options.defaultExport
                        : false;
                    return defaultExport
                        ? `${localsString}\n${exportsString}\nexport default { ${identifiers
                            .map(([id, key]) => `${JSON.stringify(key)}: ${id}`)
                            .join(", ")} }\n`
                        : `${localsString}\n${exportsString}\n`;
                }
                return `\n${esModule ? "export default" : "module.exports = "} ${JSON.stringify(locals)};`;
            }
            if (esModule) {
                return "\nexport {};";
            }
            return "";
        })();
        let resultSource = `// extracted by ${index_1.CssExtractRspackPlugin.pluginName}`;
        // only attempt hotreloading if the css is actually used for something other than hash values
        resultSource +=
            this.hot && emit
                ? hotLoader(result, { loaderContext: this, options, locals: locals })
                : result;
        if (dependencies.length > 0) {
            parseMeta[index_1.CssExtractRspackPlugin.pluginName] =
                JSON.stringify(dependencies);
        }
        callback(null, resultSource, undefined, data);
    };
    this.importModule(`${this.resourcePath}.webpack[javascript/auto]!=!!!${request}`, {
        layer: options.layer,
        publicPath: publicPathForExtract,
        baseUri: `${exports.BASE_URI}/`
    }, (error, exports) => {
        if (error) {
            callback(error);
            return;
        }
        handleExports(exports);
    });
};
exports.pitch = pitch;
exports.default = loader;
