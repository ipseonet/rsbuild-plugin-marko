"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Chunk_inner, _Chunk_innerCompilation;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chunk = void 0;
const binding_1 = require("@rspack/binding");
const _1 = require(".");
const ChunkGroup_1 = require("./ChunkGroup");
const comparators_1 = require("./util/comparators");
class Chunk {
    static __from_binding(chunk, compilation) {
        if (compilation instanceof _1.Compilation) {
            return new Chunk(chunk, compilation.__internal_getInner());
        }
        return new Chunk(chunk, compilation);
    }
    constructor(chunk, compilation) {
        _Chunk_inner.set(this, void 0);
        _Chunk_innerCompilation.set(this, void 0);
        __classPrivateFieldSet(this, _Chunk_inner, chunk, "f");
        __classPrivateFieldSet(this, _Chunk_innerCompilation, compilation, "f");
        this.name = chunk.name;
        this.id = chunk.id;
        this.ids = chunk.ids;
        this.idNameHints = chunk.idNameHints;
        this.filenameTemplate = chunk.filenameTemplate;
        this.cssFilenameTemplate = chunk.cssFilenameTemplate;
        this.files = new Set(chunk.files);
        this.runtime = new Set(chunk.runtime);
        this.hash = chunk.hash;
        this.contentHash = chunk.contentHash;
        this.renderedHash = chunk.renderedHash;
        this.chunkReason = chunk.chunkReason;
        this.auxiliaryFiles = new Set(chunk.auxiliaryFiles);
    }
    isOnlyInitial() {
        return (0, binding_1.__chunk_inner_is_only_initial)(__classPrivateFieldGet(this, _Chunk_inner, "f").__inner_ukey, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"));
    }
    canBeInitial() {
        return (0, binding_1.__chunk_inner_can_be_initial)(__classPrivateFieldGet(this, _Chunk_inner, "f").__inner_ukey, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"));
    }
    hasRuntime() {
        return (0, binding_1.__chunk_inner_has_runtime)(__classPrivateFieldGet(this, _Chunk_inner, "f").__inner_ukey, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"));
    }
    get groupsIterable() {
        const chunk_groups = __classPrivateFieldGet(this, _Chunk_inner, "f").__inner_groups.map(ukey => {
            const cg = (0, binding_1.__chunk_group_inner_get_chunk_group)(ukey, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"));
            return ChunkGroup_1.ChunkGroup.__from_binding(cg, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"));
        });
        chunk_groups.sort(comparators_1.compareChunkGroupsByIndex);
        return new Set(chunk_groups);
    }
    getChunkMaps(realHash) {
        const chunkHashMap = {};
        const chunkContentHashMap = {};
        const chunkNameMap = {};
        for (const chunk of this.getAllAsyncChunks()) {
            const id = chunk.id;
            if (!id)
                continue;
            const chunkHash = realHash ? chunk.hash : chunk.renderedHash;
            if (chunkHash) {
                chunkHashMap[id] = chunkHash;
            }
            for (const key of Object.keys(chunk.contentHash)) {
                if (!chunkContentHashMap[key]) {
                    chunkContentHashMap[key] = {};
                }
                chunkContentHashMap[key][id] = chunk.contentHash[key];
            }
            if (chunk.name) {
                chunkNameMap[id] = chunk.name;
            }
        }
        return {
            hash: chunkHashMap,
            contentHash: chunkContentHashMap,
            name: chunkNameMap
        };
    }
    getAllAsyncChunks() {
        return new Set((0, binding_1.__chunk_inner_get_all_async_chunks)(__classPrivateFieldGet(this, _Chunk_inner, "f").__inner_ukey, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f")).map(c => Chunk.__from_binding(c, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"))));
    }
    getAllInitialChunks() {
        return new Set((0, binding_1.__chunk_inner_get_all_initial_chunks)(__classPrivateFieldGet(this, _Chunk_inner, "f").__inner_ukey, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f")).map(c => Chunk.__from_binding(c, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"))));
    }
    getAllReferencedChunks() {
        return new Set((0, binding_1.__chunk_inner_get_all_referenced_chunks)(__classPrivateFieldGet(this, _Chunk_inner, "f").__inner_ukey, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f")).map(c => Chunk.__from_binding(c, __classPrivateFieldGet(this, _Chunk_innerCompilation, "f"))));
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__innerUkey() {
        return __classPrivateFieldGet(this, _Chunk_inner, "f").__inner_ukey;
    }
    __internal_to_path_data_chunk() {
        return {
            id: this.id,
            name: this.name,
            hash: this.hash,
            contentHash: this.contentHash
        };
    }
}
exports.Chunk = Chunk;
_Chunk_inner = new WeakMap(), _Chunk_innerCompilation = new WeakMap();
