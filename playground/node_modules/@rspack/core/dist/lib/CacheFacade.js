"use strict";
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3b/lib/CacheFacade.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheFacade = exports.ItemCacheFacade = exports.MultiItemCache = void 0;
const neo_async_1 = __importDefault(require("../../compiled/neo-async"));
const getLazyHashedEtag_js_1 = require("./cache/getLazyHashedEtag.js");
const mergeEtags_js_1 = require("./cache/mergeEtags.js");
function forEachBail(array, iterator, callback) {
    if (array.length === 0) {
        callback();
        return;
    }
    let i = 0;
    const next = () => {
        /** @type {boolean|undefined} */
        let loop = undefined;
        iterator(array[i++], (err, result) => {
            if (err || result !== undefined || i >= array.length) {
                return callback(err, result, i);
            }
            if (loop === false)
                while (next())
                    ;
            loop = true;
        }, i);
        if (!loop)
            loop = false;
        return loop;
    };
    while (next())
        ;
}
class BaseCache {
}
class MultiItemCache {
    /**
     * @param items item caches
     * @returns
     */
    constructor(items) {
        this._items = items;
        if (items.length === 1)
            return items[0];
    }
    /**
     * @param callback signals when the value is retrieved
     * @returns
     */
    get(callback) {
        forEachBail(this._items, (item, callback) => item.get(callback), callback);
    }
    /**
     * @returns promise with the data
     */
    async getPromise() {
        for (let i = 0; i < this._items.length; i++) {
            const result = await this._items[i].getPromise();
            if (result !== undefined) {
                return result;
            }
        }
        return undefined;
    }
    /**
     * @param data the value to store
     * @param callback signals when the value is stored
     * @returns
     */
    store(data, callback) {
        neo_async_1.default.each(this._items, (item, callback) => item.store(data, callback), callback);
    }
    /**
     * @param data the value to store
     * @returns promise signals when the value is stored
     */
    async storePromise(data) {
        await Promise.all(this._items.map(item => item.storePromise(data)));
    }
}
exports.MultiItemCache = MultiItemCache;
class ItemCacheFacade {
    /**
     * @param cache the root cache
     * @param name the child cache item name
     * @param etag the etag
     * @returns
     */
    constructor(cache, name, etag) {
        this._cache = cache;
        this._name = name;
        this._etag = etag;
    }
    /**
     * @param callback signals when the value is retrieved
     * @returns
     */
    get(callback) {
        this._cache.get(this._name, this._etag, callback);
    }
    /**
     * @returns promise with the data
     */
    getPromise() {
        return new Promise((resolve, reject) => {
            this._cache.get(this._name, this._etag, (err, data) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data);
                }
            });
        });
    }
    /**
     * @param data the value to store
     * @param callback signals when the value is stored
     * @returns
     */
    store(data, callback) {
        this._cache.store(this._name, this._etag, data, callback);
    }
    /**
     * @param data the value to store
     * @returns promise signals when the value is stored
     */
    storePromise(data) {
        return new Promise((resolve, reject) => {
            this._cache.store(this._name, this._etag, data, err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * @param computer function to compute the value if not cached
     * @param callback signals when the value is retrieved
     * @returns
     */
    provide(computer, callback) {
        this.get((err, cacheEntry) => {
            if (err)
                return callback(err);
            if (cacheEntry !== undefined)
                return cacheEntry;
            computer((err, result) => {
                if (err)
                    return callback(err);
                this.store(result, err => {
                    if (err)
                        return callback(err);
                    callback(null, result);
                });
            });
        });
    }
    /**
     * @param computer function to compute the value if not cached
     * @returns promise with the data
     */
    async providePromise(computer) {
        const cacheEntry = await this.getPromise();
        if (cacheEntry !== undefined)
            return cacheEntry;
        const result = await computer();
        await this.storePromise(result);
        return result;
    }
}
exports.ItemCacheFacade = ItemCacheFacade;
class CacheFacade {
    /**
     * @param cache the root cache
     * @param name the child cache name
     * @param hashFunction the hash function to use
     */
    constructor(cache, name, hashFunction) {
        this._cache = cache;
        this._name = name;
        this._hashFunction = hashFunction;
    }
    /**
     * @param name the child cache name#
     * @returns child cache
     */
    getChildCache(name) {
        return new CacheFacade(this._cache, `${this._name}|${name}`, this._hashFunction);
    }
    /**
     * @param identifier the cache identifier
     * @param  etag the etag
     * @returns item cache
     */
    getItemCache(identifier, etag) {
        return new ItemCacheFacade(this._cache, `${this._name}|${identifier}`, etag);
    }
    /**
     * @param obj an hashable object
     * @returns an etag that is lazy hashed
     */
    getLazyHashedEtag(obj) {
        return (0, getLazyHashedEtag_js_1.getter)(obj, this._hashFunction);
    }
    /**
     * @param a an etag
     * @param b another etag
     * @returns an etag that represents both
     */
    mergeEtags(a, b) {
        return (0, mergeEtags_js_1.mergeEtags)(a, b);
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @param callback signals when the value is retrieved
     * @returns
     */
    get(identifier, etag, callback) {
        this._cache.get(`${this._name}|${identifier}`, etag, callback);
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @returns promise with the data
     */
    getPromise(identifier, etag) {
        return new Promise((resolve, reject) => {
            this._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data);
                }
            });
        });
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @param data the value to store
     * @param callback signals when the value is stored
     * @returns
     */
    store(identifier, etag, data, callback) {
        this._cache.store(`${this._name}|${identifier}`, etag, data, callback);
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @param data the value to store
     * @returns promise signals when the value is stored
     */
    storePromise(identifier, etag, data) {
        return new Promise((resolve, reject) => {
            this._cache.store(`${this._name}|${identifier}`, etag, data, err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @param computer function to compute the value if not cached
     * @param callback signals when the value is retrieved
     * @returns
     */
    provide(identifier, etag, computer, callback) {
        this.get(identifier, etag, (err, cacheEntry) => {
            if (err)
                return callback(err);
            if (cacheEntry !== undefined)
                return cacheEntry;
            computer((err, result) => {
                if (err)
                    return callback(err);
                this.store(identifier, etag, result, err => {
                    if (err)
                        return callback(err);
                    callback(null, result);
                });
            });
        });
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @param computer function to compute the value if not cached
     * @returns promise with the data
     */
    async providePromise(identifier, etag, computer) {
        const cacheEntry = await this.getPromise(identifier, etag);
        if (cacheEntry !== undefined)
            return cacheEntry;
        const result = await computer();
        await this.storePromise(identifier, etag, result);
        return result;
    }
}
exports.CacheFacade = CacheFacade;
exports.default = CacheFacade;
