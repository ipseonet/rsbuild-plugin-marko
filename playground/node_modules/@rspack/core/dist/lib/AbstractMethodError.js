"use strict";
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3b/lib/AbstractMethodError.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractMethodError = void 0;
const WebpackError_1 = __importDefault(require("./WebpackError"));
const CURRENT_METHOD_REGEXP = /at ([a-zA-Z0-9_.]*)/;
/**
 * @param method method name
 * @returns message
 */
function createMessage(method) {
    return `Abstract method${method ? ` ${method}` : ""}. Must be overridden.`;
}
class Message extends Error {
    constructor() {
        super();
        this.stack = undefined;
        Error.captureStackTrace(this);
        const match = this.stack.split("\n")[3].match(CURRENT_METHOD_REGEXP);
        this.message = match?.[1] ? createMessage(match[1]) : createMessage();
    }
}
/**
 * Error for abstract method
 * @example
 * class FooClass {
 *     abstractMethod() {
 *         throw new AbstractMethodError(); // error message: Abstract method FooClass.abstractMethod. Must be overridden.
 *     }
 * }
 *
 */
class AbstractMethodError extends WebpackError_1.default {
    constructor() {
        super(new Message().message);
        this.name = "AbstractMethodError";
    }
}
exports.AbstractMethodError = AbstractMethodError;
exports.default = AbstractMethodError;
