"use strict";
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3b/lib/Cache.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
const lite_tapable_1 = require("@rspack/lite-tapable");
const HookWebpackError_1 = require("./HookWebpackError");
const needCalls = (times, callback) => {
    let leftTimes = times;
    return err => {
        if (--leftTimes === 0) {
            return callback();
        }
        if (err && leftTimes > 0) {
            leftTimes = 0;
            return callback();
        }
    };
};
class Cache {
    constructor() {
        this.hooks = {
            get: new lite_tapable_1.AsyncSeriesBailHook(["identifier", "etag", "gotHandlers"]),
            store: new lite_tapable_1.AsyncParallelHook(["identifier", "etag", "data"]),
            storeBuildDependencies: new lite_tapable_1.AsyncParallelHook(["dependencies"]),
            beginIdle: new lite_tapable_1.SyncHook([]),
            endIdle: new lite_tapable_1.AsyncParallelHook([]),
            shutdown: new lite_tapable_1.AsyncParallelHook([])
        };
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @param callback signals when the value is retrieved
     * @returns
     */
    get(identifier, etag, callback) {
        const gotHandlers = [];
        this.hooks.get.callAsync(identifier, etag, gotHandlers, (err, res) => {
            if (err) {
                callback((0, HookWebpackError_1.makeWebpackError)(err, "Cache.hooks.get"));
                return;
            }
            let result = res;
            if (result === null) {
                result = undefined;
            }
            if (gotHandlers.length > 1) {
                const innerCallback = needCalls(gotHandlers.length, () => callback(null, result));
                for (const gotHandler of gotHandlers) {
                    gotHandler(result, innerCallback);
                }
            }
            else if (gotHandlers.length === 1) {
                gotHandlers[0](result, () => callback(null, result));
            }
            else {
                callback(null, result);
            }
        });
    }
    /**
     * @param identifier the cache identifier
     * @param etag the etag
     * @param data the value to store
     * @param callback signals when the value is stored
     * @returns
     */
    store(identifier, etag, data, callback) {
        this.hooks.store.callAsync(identifier, etag, data, (0, HookWebpackError_1.makeWebpackErrorCallback)(callback, "Cache.hooks.store"));
    }
    /**
     * After this method has succeeded the cache can only be restored when build dependencies are
     * @param dependencies list of all build dependencies
     * @param callback signals when the dependencies are stored
     * @returns
     */
    storeBuildDependencies(dependencies, callback) {
        this.hooks.storeBuildDependencies.callAsync(dependencies, (0, HookWebpackError_1.makeWebpackErrorCallback)(callback, "Cache.hooks.storeBuildDependencies"));
    }
    beginIdle() {
        this.hooks.beginIdle.call();
    }
    /**
     * @param callback signals when the call finishes
     * @returns
     */
    endIdle(callback) {
        this.hooks.endIdle.callAsync((0, HookWebpackError_1.makeWebpackErrorCallback)(callback, "Cache.hooks.endIdle"));
    }
    /**
     * @param callback signals when the call finishes
     * @returns
     */
    shutdown(callback) {
        this.hooks.shutdown.callAsync((0, HookWebpackError_1.makeWebpackErrorCallback)(callback, "Cache.hooks.shutdown"));
    }
}
Cache.STAGE_DISK = 10;
Cache.STAGE_MEMORY = -10;
Cache.STAGE_DEFAULT = 0;
Cache.STAGE_NETWORK = 20;
exports.Cache = Cache;
exports.default = Cache;
