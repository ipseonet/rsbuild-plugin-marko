"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RspackOptionsApply = void 0;
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/OptionsApply.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
const node_assert_1 = __importDefault(require("node:assert"));
const graceful_fs_1 = __importDefault(require("../compiled/graceful-fs"));
const Module_1 = require("./Module");
const builtin_plugin_1 = require("./builtin-plugin");
const EntryOptionPlugin_1 = __importDefault(require("./lib/EntryOptionPlugin"));
const IgnoreWarningsPlugin_1 = __importDefault(require("./lib/IgnoreWarningsPlugin"));
const MemoryCachePlugin_1 = __importDefault(require("./lib/cache/MemoryCachePlugin"));
const DefaultStatsFactoryPlugin_1 = require("./stats/DefaultStatsFactoryPlugin");
const DefaultStatsPresetPlugin_1 = require("./stats/DefaultStatsPresetPlugin");
const DefaultStatsPrinterPlugin_1 = require("./stats/DefaultStatsPrinterPlugin");
const assertNotNil_1 = require("./util/assertNotNil");
class RspackOptionsApply {
    process(options, compiler) {
        (0, node_assert_1.default)(options.output.path, "options.output.path should have value after `applyRspackOptionsDefaults`");
        compiler.outputPath = options.output.path;
        compiler.name = options.name;
        compiler.outputFileSystem = graceful_fs_1.default;
        if (options.externals) {
            (0, node_assert_1.default)(options.externalsType, "options.externalsType should have value after `applyRspackOptionsDefaults`");
            new builtin_plugin_1.ExternalsPlugin(options.externalsType, options.externals).apply(compiler);
        }
        if (options.externalsPresets.node) {
            new builtin_plugin_1.NodeTargetPlugin().apply(compiler);
        }
        if (options.externalsPresets.electronMain) {
            new builtin_plugin_1.ElectronTargetPlugin("main").apply(compiler);
        }
        if (options.externalsPresets.electronPreload) {
            new builtin_plugin_1.ElectronTargetPlugin("preload").apply(compiler);
        }
        if (options.externalsPresets.electronRenderer) {
            new builtin_plugin_1.ElectronTargetPlugin("renderer").apply(compiler);
        }
        if (options.externalsPresets.electron &&
            !options.externalsPresets.electronMain &&
            !options.externalsPresets.electronPreload &&
            !options.externalsPresets.electronRenderer) {
            new builtin_plugin_1.ElectronTargetPlugin().apply(compiler);
        }
        if (options.externalsPresets.nwjs) {
            new builtin_plugin_1.ExternalsPlugin("node-commonjs", "nw.gui").apply(compiler);
        }
        if (options.externalsPresets.web ||
            options.externalsPresets.webAsync ||
            (options.externalsPresets.node && options.experiments.css)) {
            new builtin_plugin_1.HttpExternalsRspackPlugin(!!options.experiments.css, !!options.externalsPresets.webAsync).apply(compiler);
        }
        new builtin_plugin_1.ChunkPrefetchPreloadPlugin().apply(compiler);
        if (typeof options.output.chunkFormat === "string") {
            switch (options.output.chunkFormat) {
                case "array-push": {
                    new builtin_plugin_1.ArrayPushCallbackChunkFormatPlugin().apply(compiler);
                    break;
                }
                case "commonjs": {
                    new builtin_plugin_1.CommonJsChunkFormatPlugin().apply(compiler);
                    break;
                }
                case "module": {
                    new builtin_plugin_1.ModuleChunkFormatPlugin().apply(compiler);
                    break;
                }
                default:
                    throw new Error(`Unsupported chunk format '${options.output.chunkFormat}'.`);
            }
        }
        if (options.output.enabledChunkLoadingTypes &&
            options.output.enabledChunkLoadingTypes.length > 0) {
            for (const type of options.output.enabledChunkLoadingTypes) {
                new builtin_plugin_1.EnableChunkLoadingPlugin(type).apply(compiler);
            }
        }
        if (options.output.enabledWasmLoadingTypes &&
            options.output.enabledWasmLoadingTypes.length > 0) {
            for (const type of options.output.enabledWasmLoadingTypes) {
                new builtin_plugin_1.EnableWasmLoadingPlugin(type).apply(compiler);
            }
        }
        const runtimeChunk = options.optimization
            .runtimeChunk;
        if (runtimeChunk) {
            new builtin_plugin_1.RuntimeChunkPlugin(runtimeChunk).apply(compiler);
        }
        if (!options.optimization.emitOnErrors) {
            new builtin_plugin_1.NoEmitOnErrorsPlugin().apply(compiler);
        }
        if (options.devtool) {
            if (options.devtool.includes("source-map")) {
                const hidden = options.devtool.includes("hidden");
                const inline = options.devtool.includes("inline");
                const evalWrapped = options.devtool.includes("eval");
                const cheap = options.devtool.includes("cheap");
                const moduleMaps = options.devtool.includes("module");
                const noSources = options.devtool.includes("nosources");
                const Plugin = evalWrapped
                    ? builtin_plugin_1.EvalSourceMapDevToolPlugin
                    : builtin_plugin_1.SourceMapDevToolPlugin;
                new Plugin({
                    filename: inline ? null : options.output.sourceMapFilename,
                    moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
                    fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,
                    append: hidden ? false : undefined,
                    module: moduleMaps ? true : !cheap,
                    columns: !cheap,
                    noSources: noSources,
                    namespace: options.output.devtoolNamespace
                }).apply(compiler);
            }
            else if (options.devtool.includes("eval")) {
                new builtin_plugin_1.EvalDevToolModulePlugin({
                    moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
                    namespace: options.output.devtoolNamespace
                }).apply(compiler);
            }
        }
        new builtin_plugin_1.JavascriptModulesPlugin().apply(compiler);
        new builtin_plugin_1.JsonModulesPlugin().apply(compiler);
        new builtin_plugin_1.AssetModulesPlugin().apply(compiler);
        if (options.experiments.asyncWebAssembly) {
            new builtin_plugin_1.AsyncWebAssemblyModulesPlugin().apply(compiler);
        }
        if (options.experiments.css) {
            new builtin_plugin_1.CssModulesPlugin().apply(compiler);
        }
        new EntryOptionPlugin_1.default().apply(compiler);
        (0, assertNotNil_1.assertNotNill)(options.context);
        compiler.hooks.entryOption.call(options.context, options.entry);
        new builtin_plugin_1.RuntimePlugin().apply(compiler);
        if (options.experiments.rspackFuture.bundlerInfo) {
            new builtin_plugin_1.BundlerInfoRspackPlugin(options.experiments.rspackFuture.bundlerInfo).apply(compiler);
        }
        new builtin_plugin_1.InferAsyncModulesPlugin().apply(compiler);
        new builtin_plugin_1.APIPlugin().apply(compiler);
        new builtin_plugin_1.DataUriPlugin().apply(compiler);
        new builtin_plugin_1.FileUriPlugin().apply(compiler);
        new builtin_plugin_1.EnsureChunkConditionsPlugin().apply(compiler);
        if (options.optimization.mergeDuplicateChunks) {
            new builtin_plugin_1.MergeDuplicateChunksPlugin().apply(compiler);
        }
        if (options.optimization.sideEffects) {
            new builtin_plugin_1.SideEffectsFlagPlugin( /* options.optimization.sideEffects === true */).apply(compiler);
        }
        if (options.optimization.providedExports) {
            new builtin_plugin_1.FlagDependencyExportsPlugin().apply(compiler);
        }
        if (options.optimization.usedExports) {
            new builtin_plugin_1.FlagDependencyUsagePlugin(options.optimization.usedExports === "global").apply(compiler);
        }
        if (options.optimization.concatenateModules) {
            new builtin_plugin_1.ModuleConcatenationPlugin().apply(compiler);
        }
        if (options.optimization.mangleExports) {
            new builtin_plugin_1.MangleExportsPlugin(options.optimization.mangleExports !== "size").apply(compiler);
        }
        if (options.experiments.lazyCompilation) {
            const lazyOptions = options.experiments.lazyCompilation;
            new builtin_plugin_1.LazyCompilationPlugin(
            // this is only for test
            // @ts-expect-error cacheable is hide
            lazyOptions.cacheable ?? true, lazyOptions.entries ?? true, lazyOptions.imports ?? true, typeof lazyOptions.test === "function"
                ? jsModule => lazyOptions.test.call(lazyOptions, new Module_1.Module(jsModule))
                : lazyOptions.test
                    ? {
                        source: lazyOptions.test.source,
                        flags: lazyOptions.test.flags
                    }
                    : undefined, lazyOptions.backend).apply(compiler);
        }
        if (options.output.enabledLibraryTypes &&
            options.output.enabledLibraryTypes.length > 0) {
            for (const type of options.output.enabledLibraryTypes) {
                new builtin_plugin_1.EnableLibraryPlugin(type).apply(compiler);
            }
        }
        if (options.optimization.splitChunks) {
            new builtin_plugin_1.SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
        }
        // TODO: inconsistent: the plugin need to be placed after SplitChunksPlugin
        if (options.optimization.removeEmptyChunks) {
            new builtin_plugin_1.RemoveEmptyChunksPlugin().apply(compiler);
        }
        if (options.optimization.realContentHash) {
            new builtin_plugin_1.RealContentHashPlugin().apply(compiler);
        }
        const moduleIds = options.optimization.moduleIds;
        if (moduleIds) {
            switch (moduleIds) {
                case "named": {
                    new builtin_plugin_1.NamedModuleIdsPlugin().apply(compiler);
                    break;
                }
                case "natural": {
                    new builtin_plugin_1.NaturalModuleIdsPlugin().apply(compiler);
                    break;
                }
                case "deterministic": {
                    new builtin_plugin_1.DeterministicModuleIdsPlugin().apply(compiler);
                    break;
                }
                default:
                    throw new Error(`moduleIds: ${moduleIds} is not implemented`);
            }
        }
        const chunkIds = options.optimization.chunkIds;
        if (chunkIds) {
            switch (chunkIds) {
                case "natural": {
                    new builtin_plugin_1.NaturalChunkIdsPlugin().apply(compiler);
                }
                case "named": {
                    new builtin_plugin_1.NamedChunkIdsPlugin().apply(compiler);
                    break;
                }
                case "deterministic": {
                    new builtin_plugin_1.DeterministicChunkIdsPlugin().apply(compiler);
                    break;
                }
                default:
                    throw new Error(`chunkIds: ${chunkIds} is not implemented`);
            }
        }
        if (options.optimization.nodeEnv) {
            new builtin_plugin_1.DefinePlugin({
                "process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
            }).apply(compiler);
        }
        const { minimize, minimizer } = options.optimization;
        if (minimize && minimizer) {
            for (const item of minimizer) {
                if (typeof item === "function") {
                    item.call(compiler, compiler);
                }
                else if (item !== "..." && item) {
                    item.apply(compiler);
                }
            }
        }
        if (options.performance) {
            new builtin_plugin_1.SizeLimitsPlugin(options.performance).apply(compiler);
        }
        new builtin_plugin_1.WarnCaseSensitiveModulesPlugin().apply(compiler);
        if (options.cache) {
            new MemoryCachePlugin_1.default().apply(compiler);
        }
        new builtin_plugin_1.WorkerPlugin(options.output.workerChunkLoading, options.output.workerWasmLoading, options.output.module, options.output.workerPublicPath).apply(compiler);
        new DefaultStatsFactoryPlugin_1.DefaultStatsFactoryPlugin().apply(compiler);
        new DefaultStatsPresetPlugin_1.DefaultStatsPresetPlugin().apply(compiler);
        new DefaultStatsPrinterPlugin_1.DefaultStatsPrinterPlugin().apply(compiler);
        if (options.ignoreWarnings && options.ignoreWarnings.length > 0) {
            new IgnoreWarningsPlugin_1.default(options.ignoreWarnings).apply(compiler);
        }
        compiler.hooks.afterPlugins.call(compiler);
        if (!compiler.inputFileSystem) {
            throw new Error("No input filesystem provided");
        }
        compiler.hooks.afterResolvers.call(compiler);
    }
}
exports.RspackOptionsApply = RspackOptionsApply;
