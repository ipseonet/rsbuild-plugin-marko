"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUseSimpleSourceMap = exports.isUseSourceMap = exports.createRawModuleRuleUses = exports.BUILTIN_LOADER_PREFIX = void 0;
const builtin_loader_1 = require("../builtin-loader");
const lightningcss_1 = require("../builtin-loader/lightningcss");
const loader_runner_1 = require("../loader-runner");
const util_1 = require("../util");
exports.BUILTIN_LOADER_PREFIX = "builtin:";
function createRawModuleRuleUses(uses, path, options) {
    const normalizeRuleSetUseItem = (item) => typeof item === "string" ? { loader: item } : item;
    const allUses = Array.isArray(uses)
        ? [...uses].map(normalizeRuleSetUseItem)
        : [normalizeRuleSetUseItem(uses)];
    return createRawModuleRuleUsesImpl(allUses, path, options);
}
exports.createRawModuleRuleUses = createRawModuleRuleUses;
const getSwcLoaderOptions = (o, _) => {
    if (o && typeof o === "object" && o.rspackExperiments) {
        const expr = o.rspackExperiments;
        if (expr.import || expr.pluginImport) {
            expr.import = (0, builtin_loader_1.resolvePluginImport)(expr.import || expr.pluginImport);
        }
    }
    return o;
};
const getLightningcssLoaderOptions = (o, _) => {
    if (o && typeof o === "object") {
        if (typeof o.targets === "string") {
            o.targets = [o.targets];
        }
        if (o.include && typeof o.include === "object") {
            o.include = (0, lightningcss_1.toFeatures)(o.include);
        }
        if (o.exclude && typeof o.exclude === "object") {
            o.exclude = (0, lightningcss_1.toFeatures)(o.exclude);
        }
    }
    return o;
};
function getBuiltinLoaderOptions(identifier, o, options) {
    if (identifier.startsWith(`${exports.BUILTIN_LOADER_PREFIX}swc-loader`)) {
        return getSwcLoaderOptions(o, options);
    }
    if (identifier.startsWith(`${exports.BUILTIN_LOADER_PREFIX}lightningcss-loader`)) {
        return getLightningcssLoaderOptions(o, options);
    }
    return o;
}
function createRawModuleRuleUsesImpl(uses, path, options) {
    if (!uses.length) {
        return [];
    }
    return uses.map((use, index) => {
        let o;
        let isBuiltin = false;
        if (use.loader.startsWith(exports.BUILTIN_LOADER_PREFIX)) {
            const temp = getBuiltinLoaderOptions(use.loader, use.options, options);
            // keep json with indent so miette can show pretty error
            o = (0, util_1.isNil)(temp)
                ? undefined
                : typeof temp === "string"
                    ? temp
                    : JSON.stringify(temp, null, 2);
            isBuiltin = true;
        }
        return {
            loader: resolveStringifyLoaders(use, `${path}[${index}]`, options.compiler, isBuiltin),
            options: o
        };
    });
}
function resolveStringifyLoaders(use, path, compiler, isBuiltin) {
    const obj = (0, loader_runner_1.parsePathQueryFragment)(use.loader);
    let ident = null;
    if (use.options === null) {
    }
    else if (use.options === undefined) {
    }
    else if (typeof use.options === "string")
        obj.query = `?${use.options}`;
    else if (use.ident)
        obj.query = `??${(ident = use.ident)}`;
    else if (typeof use.options === "object" && use.options.ident)
        obj.query = `??${(ident = use.options.ident)}`;
    else if (typeof use.options === "object")
        obj.query = `??${(ident = path)}`;
    else
        obj.query = `?${JSON.stringify(use.options)}`;
    if (use.options && typeof use.options === "object") {
        if (!ident)
            ident = "[[missing ident]]";
        compiler.__internal__ruleSet.references.set(ident, use.options);
        if (isBuiltin) {
            compiler.__internal__ruleSet.builtinReferences.set(ident, use.options);
        }
    }
    return obj.path + obj.query + obj.fragment;
}
function isUseSourceMap(devtool) {
    return (devtool.includes("source-map") &&
        (devtool.includes("module") || !devtool.includes("cheap")));
}
exports.isUseSourceMap = isUseSourceMap;
function isUseSimpleSourceMap(devtool) {
    return devtool.includes("source-map") && !isUseSourceMap(devtool);
}
exports.isUseSimpleSourceMap = isUseSimpleSourceMap;
