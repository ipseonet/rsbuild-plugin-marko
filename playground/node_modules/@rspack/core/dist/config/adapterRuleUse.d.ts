/// <reference types="node" />
import type { JsAssetInfo, RawModuleRuleUse, RawOptions } from "@rspack/binding";
import type { ResolveRequest } from "../../compiled/enhanced-resolve";
import type { Compilation } from "../Compilation";
import type { Compiler } from "../Compiler";
import type { Module } from "../Module";
import { type LoaderObject } from "../loader-runner";
import type { Logger } from "../logging/Logger";
import type Hash from "../util/hash";
import type { Mode, PublicPath, Resolve, RuleSetUseItem, Target } from "./zod";
export declare const BUILTIN_LOADER_PREFIX = "builtin:";
export interface ComposeJsUseOptions {
    devtool: RawOptions["devtool"];
    context: RawOptions["context"];
    mode: RawOptions["mode"];
    experiments: RawOptions["experiments"];
    compiler: Compiler;
}
export interface SourceMap {
    version: number;
    sources: string[];
    mappings: string;
    file?: string;
    sourceRoot?: string;
    sourcesContent?: string[];
    names?: string[];
}
export interface AdditionalData {
    [index: string]: any;
}
export type LoaderContextCallback = (err?: Error | null, content?: string | Buffer, sourceMap?: string | SourceMap, additionalData?: AdditionalData) => void;
export type ErrorWithDetails = Error & {
    details?: string;
};
export type ResolveCallback = (err: null | ErrorWithDetails, res?: string | false, req?: ResolveRequest) => void;
export interface DiagnosticLocation {
    /** Text for highlighting the location */
    text?: string;
    /** 1-based line */
    line: number;
    /** 0-based column in bytes */
    column: number;
    /** Length in bytes */
    length: number;
}
export interface Diagnostic {
    message: string;
    help?: string;
    sourceCode?: string;
    /**
     * Location to the source code.
     *
     * If `sourceCode` is not provided, location will be omitted.
     */
    location?: DiagnosticLocation;
    file?: string;
    severity: "error" | "warning";
}
interface LoaderExperiments {
    emitDiagnostic(diagnostic: Diagnostic): void;
}
export interface LoaderContext<OptionsType = {}> {
    version: 2;
    resource: string;
    resourcePath: string;
    resourceQuery: string;
    resourceFragment: string;
    async(): LoaderContextCallback;
    callback: LoaderContextCallback;
    cacheable(cacheable?: boolean): void;
    sourceMap: boolean;
    rootContext: string;
    context: string | null;
    loaderIndex: number;
    remainingRequest: string;
    currentRequest: string;
    previousRequest: string;
    request: string;
    /**
     * An array of all the loaders. It is writeable in the pitch phase.
     * loaders = [{request: string, path: string, query: string, module: function}]
     *
     * In the example:
     * [
     *   { request: "/abc/loader1.js?xyz",
     *     path: "/abc/loader1.js",
     *     query: "?xyz",
     *     module: [Function]
     *   },
     *   { request: "/abc/node_modules/loader2/index.js",
     *     path: "/abc/node_modules/loader2/index.js",
     *     query: "",
     *     module: [Function]
     *   }
     * ]
     */
    loaders: LoaderObject[];
    mode?: Mode;
    target?: Target;
    hot?: boolean;
    /**
     * @param schema To provide the best performance, Rspack does not perform the schema validation. If your loader requires schema validation, please call scheme-utils or zod on your own.
     */
    getOptions(schema?: any): OptionsType;
    resolve(context: string, request: string, callback: (arg0: null | Error, arg1?: string | false, arg2?: ResolveRequest) => void): void;
    getResolve(options: Resolve): ((context: string, request: string, callback: ResolveCallback) => void) | ((context: string, request: string) => Promise<string | false | undefined>);
    getLogger(name: string): Logger;
    emitError(error: Error): void;
    emitWarning(warning: Error): void;
    emitFile(name: string, content: string | Buffer, sourceMap?: string, assetInfo?: JsAssetInfo): void;
    addDependency(file: string): void;
    dependency(file: string): void;
    addContextDependency(context: string): void;
    addMissingDependency(missing: string): void;
    clearDependencies(): void;
    getDependencies(): string[];
    getContextDependencies(): string[];
    getMissingDependencies(): string[];
    addBuildDependency(file: string): void;
    importModule(request: string, options: {
        layer?: string;
        publicPath?: PublicPath;
        baseUri?: string;
    }, callback: (err?: Error, res?: any) => void): void;
    fs: any;
    /**
     * This is an experimental API and maybe subject to change.
     * @experimental
     */
    experiments: LoaderExperiments;
    utils: {
        absolutify: (context: string, request: string) => string;
        contextify: (context: string, request: string) => string;
        createHash: (algorithm?: string) => Hash;
    };
    query: string | OptionsType;
    data: unknown;
    _compiler: Compiler;
    _compilation: Compilation;
    _module: Module;
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     * Store some data from loader, and consume it from parser, it may be removed in the future
     *
     * @internal
     */
    __internal__parseMeta: Record<string, string>;
}
export type LoaderDefinitionFunction<OptionsType = {}, ContextAdditions = {}> = (this: LoaderContext<OptionsType> & ContextAdditions, content: string, sourceMap?: string | SourceMap, additionalData?: AdditionalData) => string | void | Buffer | Promise<string | Buffer>;
export type PitchLoaderDefinitionFunction<OptionsType = {}, ContextAdditions = {}> = (this: LoaderContext<OptionsType> & ContextAdditions, remainingRequest: string, previousRequest: string, data: object) => string | void | Buffer | Promise<string | Buffer>;
export type LoaderDefinition<OptionsType = {}, ContextAdditions = {}> = LoaderDefinitionFunction<OptionsType, ContextAdditions> & {
    raw?: false;
    pitch?: PitchLoaderDefinitionFunction;
};
export declare function createRawModuleRuleUses(uses: RuleSetUseItem | RuleSetUseItem[], path: string, options: ComposeJsUseOptions): RawModuleRuleUse[];
export declare function isUseSourceMap(devtool: RawOptions["devtool"]): boolean;
export declare function isUseSimpleSourceMap(devtool: RawOptions["devtool"]): boolean;
export {};
