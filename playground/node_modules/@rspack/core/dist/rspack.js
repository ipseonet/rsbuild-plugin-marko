"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stats = exports.rspack = exports.MultiStats = exports.createMultiCompiler = exports.createCompiler = void 0;
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3b/lib
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
const node_assert_1 = __importDefault(require("node:assert"));
const node_util_1 = __importDefault(require("node:util"));
const Compiler_1 = require("./Compiler");
const MultiCompiler_1 = require("./MultiCompiler");
const MultiStats_1 = __importDefault(require("./MultiStats"));
exports.MultiStats = MultiStats_1.default;
const Stats_1 = require("./Stats");
Object.defineProperty(exports, "Stats", { enumerable: true, get: function () { return Stats_1.Stats; } });
const config_1 = require("./config");
const NodeEnvironmentPlugin_1 = __importDefault(require("./node/NodeEnvironmentPlugin"));
const rspackOptionsApply_1 = require("./rspackOptionsApply");
const util_1 = require("./util");
const validate_1 = require("./util/validate");
function createMultiCompiler(options) {
    const compilers = options.map(createCompiler);
    const compiler = new MultiCompiler_1.MultiCompiler(compilers, options);
    for (const childCompiler of compilers) {
        if (childCompiler.options.dependencies) {
            compiler.setDependencies(childCompiler, childCompiler.options.dependencies);
        }
    }
    return compiler;
}
exports.createMultiCompiler = createMultiCompiler;
function createCompiler(userOptions) {
    const options = (0, config_1.getNormalizedRspackOptions)(userOptions);
    (0, config_1.applyRspackOptionsBaseDefaults)(options);
    (0, node_assert_1.default)(!(0, util_1.isNil)(options.context));
    const compiler = new Compiler_1.Compiler(options.context, options);
    new NodeEnvironmentPlugin_1.default({
        infrastructureLogging: options.infrastructureLogging
    }).apply(compiler);
    if (Array.isArray(options.plugins)) {
        for (const plugin of options.plugins) {
            if (typeof plugin === "function") {
                plugin.call(compiler, compiler);
            }
            else if (plugin) {
                plugin.apply(compiler);
            }
        }
    }
    (0, config_1.applyRspackOptionsDefaults)(compiler.options);
    compiler.hooks.environment.call();
    compiler.hooks.afterEnvironment.call();
    new rspackOptionsApply_1.RspackOptionsApply().process(compiler.options, compiler);
    compiler.hooks.initialize.call();
    return compiler;
}
exports.createCompiler = createCompiler;
function isMultiRspackOptions(o) {
    return Array.isArray(o);
}
function rspack(options, callback) {
    try {
        for (const o of (0, util_1.asArray)(options)) {
            (0, validate_1.validate)(o, config_1.rspackOptions);
        }
    }
    catch (e) {
        if (e instanceof Error && callback) {
            callback(e);
            return null;
        }
        throw e;
    }
    const create = () => {
        if (isMultiRspackOptions(options)) {
            const compiler = createMultiCompiler(options);
            const watch = options.some(options => options.watch);
            const watchOptions = options.map(options => options.watchOptions || {});
            return { compiler, watch, watchOptions };
        }
        const compiler = createCompiler(options);
        const watch = options.watch;
        const watchOptions = options.watchOptions || {};
        return { compiler, watch, watchOptions };
    };
    if (callback) {
        try {
            const { compiler, watch, watchOptions } = create();
            if (watch) {
                compiler.watch(watchOptions, callback);
            }
            else {
                compiler.run((err, stats) => {
                    compiler.close(() => {
                        callback(err, stats);
                    });
                });
            }
            return compiler;
        }
        catch (err) {
            process.nextTick(() => callback(err));
            return null;
        }
    }
    else {
        const { compiler, watch } = create();
        if (watch) {
            node_util_1.default.deprecate(() => { }, "A 'callback' argument needs to be provided to the 'rspack(options, callback)' function when the 'watch' option is set. There is no way to handle the 'watch' option without a callback.")();
        }
        return compiler;
    }
}
exports.rspack = rspack;
exports.default = rspack;
