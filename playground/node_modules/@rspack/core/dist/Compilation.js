"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Compilation_instances, _Compilation_inner, _Compilation_customModules, _Compilation_createCachedAssets, _Compilation_rebuildModuleCaller, _Entries_data;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Entries = exports.Compilation = void 0;
const binding_1 = require("@rspack/binding");
const liteTapable = __importStar(require("@rspack/lite-tapable"));
const Chunk_1 = require("./Chunk");
const ChunkGraph_1 = require("./ChunkGraph");
const ChunkGroup_1 = require("./ChunkGroup");
const Entrypoint_1 = require("./Entrypoint");
const ErrorHelpers_1 = require("./ErrorHelpers");
const Module_1 = require("./Module");
const RspackError_1 = require("./RspackError");
const RuntimeModule_1 = require("./RuntimeModule");
const Stats_1 = require("./Stats");
const Logger_1 = require("./logging/Logger");
const StatsFactory_1 = require("./stats/StatsFactory");
const StatsPrinter_1 = require("./stats/StatsPrinter");
const AssetInfo_1 = require("./util/AssetInfo");
const MergeCaller_1 = __importDefault(require("./util/MergeCaller"));
const createReadonlyMap_1 = require("./util/createReadonlyMap");
const fake_1 = require("./util/fake");
const memoize_1 = require("./util/memoize");
const source_1 = require("./util/source");
class Compilation {
    constructor(compiler, inner) {
        _Compilation_instances.add(this);
        _Compilation_inner.set(this, void 0);
        this.fileSystemInfo = {
            createSnapshot() {
                // fake implement to support html-webpack-plugin
                return null;
            }
        };
        /**
         * Records the dynamically added fields for Module on the JavaScript side, using the Module identifier for association.
         * These fields are generally used within a plugin, so they do not need to be passed back to the Rust side.
         */
        _Compilation_customModules.set(this, void 0);
        this.fileDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").dependencies().fileDependencies, d => __classPrivateFieldGet(this, _Compilation_inner, "f").addFileDependencies(d));
        this.contextDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").dependencies().contextDependencies, d => __classPrivateFieldGet(this, _Compilation_inner, "f").addContextDependencies(d));
        this.missingDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").dependencies().missingDependencies, d => __classPrivateFieldGet(this, _Compilation_inner, "f").addMissingDependencies(d));
        this.buildDependencies = (0, fake_1.createFakeCompilationDependencies)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").dependencies().buildDependencies, d => __classPrivateFieldGet(this, _Compilation_inner, "f").addBuildDependencies(d));
        _Compilation_rebuildModuleCaller.set(this, ((compilation) => new MergeCaller_1.default((args) => {
            __classPrivateFieldGet(compilation, _Compilation_inner, "f").rebuildModule(args.map(item => item[0]), (err, modules) => {
                for (const [id, callback] of args) {
                    const m = modules.find(item => item.moduleIdentifier === id);
                    if (m) {
                        callback(err, Module_1.Module.__from_binding(m, compilation));
                    }
                    else {
                        callback(err || new Error("module no found"), null);
                    }
                }
            });
        }, 10))(this));
        __classPrivateFieldSet(this, _Compilation_inner, inner, "f");
        __classPrivateFieldSet(this, _Compilation_customModules, {}, "f");
        const processAssetsHook = new liteTapable.AsyncSeriesHook([
            "assets"
        ]);
        const createProcessAssetsHook = (name, stage, getArgs, code) => {
            const errorMessage = (reason) => `Can't automatically convert plugin using Compilation.hooks.${name} to Compilation.hooks.processAssets because ${reason}.
BREAKING CHANGE: Asset processing hooks in Compilation has been merged into a single Compilation.hooks.processAssets hook.`;
            const getOptions = (options) => {
                const isString = typeof options === "string";
                if (!isString && options.stage) {
                    throw new Error(errorMessage("it's using the 'stage' option"));
                }
                return {
                    ...(isString ? { name: options } : options),
                    stage: stage
                };
            };
            return Object.freeze({
                name,
                intercept() {
                    throw new Error(errorMessage("it's using 'intercept'"));
                },
                tap: (options, fn) => {
                    processAssetsHook.tap(getOptions(options), () => fn(...getArgs()));
                },
                tapAsync: (options, fn) => {
                    processAssetsHook.tapAsync(getOptions(options), (assets, callback) => fn(...getArgs(), callback));
                },
                tapPromise: (options, fn) => {
                    processAssetsHook.tapPromise(getOptions(options), () => fn(...getArgs()));
                },
                _fakeHook: true
            });
        };
        this.hooks = {
            processAssets: processAssetsHook,
            afterProcessAssets: new liteTapable.SyncHook(["assets"]),
            /** @deprecated */
            additionalAssets: createProcessAssetsHook("additionalAssets", Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL, () => []),
            childCompiler: new liteTapable.SyncHook([
                "childCompiler",
                "compilerName",
                "compilerIndex"
            ]),
            log: new liteTapable.SyncBailHook(["origin", "logEntry"]),
            optimizeModules: new liteTapable.SyncBailHook(["modules"]),
            afterOptimizeModules: new liteTapable.SyncBailHook(["modules"]),
            optimizeTree: new liteTapable.AsyncSeriesHook(["chunks", "modules"]),
            optimizeChunkModules: new liteTapable.AsyncSeriesBailHook([
                "chunks",
                "modules"
            ]),
            finishModules: new liteTapable.AsyncSeriesHook(["modules"]),
            chunkHash: new liteTapable.SyncHook(["chunk", "hash"]),
            chunkAsset: new liteTapable.SyncHook(["chunk", "filename"]),
            processWarnings: new liteTapable.SyncWaterfallHook(["warnings"]),
            succeedModule: new liteTapable.SyncHook(["module"]),
            stillValidModule: new liteTapable.SyncHook(["module"]),
            statsPreset: new liteTapable.HookMap(() => new liteTapable.SyncHook(["options", "context"])),
            statsNormalize: new liteTapable.SyncHook(["options", "context"]),
            statsFactory: new liteTapable.SyncHook(["statsFactory", "options"]),
            statsPrinter: new liteTapable.SyncHook(["statsPrinter", "options"]),
            buildModule: new liteTapable.SyncHook(["module"]),
            executeModule: new liteTapable.SyncHook(["options", "context"]),
            additionalTreeRuntimeRequirements: new liteTapable.SyncHook([
                "chunk",
                "runtimeRequirements"
            ]),
            runtimeRequirementInTree: new liteTapable.HookMap(() => new liteTapable.SyncBailHook(["chunk", "runtimeRequirements"])),
            runtimeModule: new liteTapable.SyncHook(["module", "chunk"]),
            seal: new liteTapable.SyncHook([]),
            afterSeal: new liteTapable.AsyncSeriesHook([])
        };
        this.compiler = compiler;
        this.resolverFactory = compiler.resolverFactory;
        this.inputFileSystem = compiler.inputFileSystem;
        this.options = compiler.options;
        this.outputOptions = compiler.options.output;
        this.logging = new Map();
        this.childrenCounters = {};
        this.children = [];
        this.chunkGraph = new ChunkGraph_1.ChunkGraph(this);
    }
    get hash() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").hash;
    }
    get fullHash() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").hash;
    }
    /**
     * Get a map of all assets.
     */
    get assets() {
        return (0, memoize_1.memoizeValue)(() => __classPrivateFieldGet(this, _Compilation_instances, "m", _Compilation_createCachedAssets).call(this));
    }
    /**
     * Get a map of all entrypoints.
     */
    get entrypoints() {
        return (0, memoize_1.memoizeValue)(() => new Map(Object.entries(__classPrivateFieldGet(this, _Compilation_inner, "f").entrypoints).map(([n, e]) => [
            n,
            Entrypoint_1.Entrypoint.__from_binding(e, __classPrivateFieldGet(this, _Compilation_inner, "f"))
        ])));
    }
    get chunkGroups() {
        return (0, memoize_1.memoizeValue)(() => __classPrivateFieldGet(this, _Compilation_inner, "f").chunkGroups.map(cg => ChunkGroup_1.ChunkGroup.__from_binding(cg, __classPrivateFieldGet(this, _Compilation_inner, "f"))));
    }
    /**
     * Get the named chunk groups.
     *
     * Note: This is a proxy for webpack internal API, only method `get`, `keys`, `values` and `entries` are supported now.
     */
    get namedChunkGroups() {
        return (0, createReadonlyMap_1.createReadonlyMap)({
            keys: () => {
                const names = __classPrivateFieldGet(this, _Compilation_inner, "f").getNamedChunkGroupKeys();
                return names[Symbol.iterator]();
            },
            get: (property) => {
                if (typeof property === "string") {
                    const chunk = __classPrivateFieldGet(this, _Compilation_inner, "f").getNamedChunkGroup(property) || undefined;
                    return chunk && ChunkGroup_1.ChunkGroup.__from_binding(chunk, __classPrivateFieldGet(this, _Compilation_inner, "f"));
                }
            }
        });
    }
    get modules() {
        return new Set(__classPrivateFieldGet(this, _Compilation_inner, "f").modules.map(module => Module_1.Module.__from_binding(module, this)));
    }
    get builtModules() {
        return new Set(__classPrivateFieldGet(this, _Compilation_inner, "f").builtModules.map(module => Module_1.Module.__from_binding(module, this)));
    }
    get chunks() {
        return (0, memoize_1.memoizeValue)(() => new Set(this.__internal__getChunks()));
    }
    /**
     * Get the named chunks.
     *
     * Note: This is a proxy for webpack internal API, only method `get`, `keys`, `values` and `entries` are supported now.
     */
    get namedChunks() {
        return (0, createReadonlyMap_1.createReadonlyMap)({
            keys: () => {
                const names = __classPrivateFieldGet(this, _Compilation_inner, "f").getNamedChunkKeys();
                return names[Symbol.iterator]();
            },
            get: (property) => {
                if (typeof property === "string") {
                    const chunk = __classPrivateFieldGet(this, _Compilation_inner, "f").getNamedChunk(property) || undefined;
                    return chunk && Chunk_1.Chunk.__from_binding(chunk, __classPrivateFieldGet(this, _Compilation_inner, "f"));
                }
            }
        });
    }
    get entries() {
        return new Entries(__classPrivateFieldGet(this, _Compilation_inner, "f").entries);
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getCustomModule(moduleIdentifier) {
        let module = __classPrivateFieldGet(this, _Compilation_customModules, "f")[moduleIdentifier];
        if (!module) {
            module = __classPrivateFieldGet(this, _Compilation_customModules, "f")[moduleIdentifier] = {
                buildInfo: {},
                buildMeta: {}
            };
        }
        return module;
    }
    getCache(name) {
        return this.compiler.getCache(name);
    }
    createStatsOptions(statsValue, context = {}) {
        let optionsOrPreset = statsValue;
        if (typeof optionsOrPreset === "boolean" ||
            typeof optionsOrPreset === "string") {
            optionsOrPreset = { preset: optionsOrPreset };
        }
        if (typeof optionsOrPreset === "object" && optionsOrPreset !== null) {
            // We use this method of shallow cloning this object to include
            // properties in the prototype chain
            const options = {};
            for (const key in optionsOrPreset) {
                options[key] =
                    optionsOrPreset[key];
            }
            if (options.preset !== undefined) {
                this.hooks.statsPreset.for(options.preset).call(options, context);
            }
            this.hooks.statsNormalize.call(options, context);
            return options;
        }
        const options = {};
        this.hooks.statsNormalize.call(options, context);
        return options;
    }
    createStatsFactory(options) {
        const statsFactory = new StatsFactory_1.StatsFactory();
        this.hooks.statsFactory.call(statsFactory, options);
        return statsFactory;
    }
    createStatsPrinter(options) {
        const statsPrinter = new StatsPrinter_1.StatsPrinter();
        this.hooks.statsPrinter.call(statsPrinter, options);
        return statsPrinter;
    }
    /**
     * Update an existing asset. Trying to update an asset that doesn't exist will throw an error.
     */
    updateAsset(filename, newSourceOrFunction, assetInfoUpdateOrFunction) {
        let compatNewSourceOrFunction;
        if (typeof newSourceOrFunction === "function") {
            compatNewSourceOrFunction = function newSourceFunction(source) {
                return source_1.JsSource.__to_binding(newSourceOrFunction(source_1.JsSource.__from_binding(source)));
            };
        }
        else {
            compatNewSourceOrFunction = source_1.JsSource.__to_binding(newSourceOrFunction);
        }
        __classPrivateFieldGet(this, _Compilation_inner, "f").updateAsset(filename, compatNewSourceOrFunction, assetInfoUpdateOrFunction === undefined
            ? assetInfoUpdateOrFunction
            : typeof assetInfoUpdateOrFunction === "function"
                ? jsAssetInfo => AssetInfo_1.JsAssetInfo.__to_binding(assetInfoUpdateOrFunction(jsAssetInfo))
                : AssetInfo_1.JsAssetInfo.__to_binding(assetInfoUpdateOrFunction));
    }
    /**
     * Emit an not existing asset. Trying to emit an asset that already exists will throw an error.
     *
     * @param file - file name
     * @param source - asset source
     * @param assetInfo - extra asset information
     */
    emitAsset(filename, source, assetInfo) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").emitAsset(filename, source_1.JsSource.__to_binding(source), AssetInfo_1.JsAssetInfo.__to_binding(assetInfo));
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__emit_asset_from_loader(filename, source, assetInfo, module) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").emitAssetFromLoader(filename, source_1.JsSource.__to_binding(source), AssetInfo_1.JsAssetInfo.__to_binding(assetInfo), module);
    }
    deleteAsset(filename) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").deleteAsset(filename);
    }
    renameAsset(filename, newFilename) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").renameAsset(filename, newFilename);
    }
    /**
     * Get an array of Asset
     */
    getAssets() {
        const assets = __classPrivateFieldGet(this, _Compilation_inner, "f").getAssets();
        return assets.map(asset => {
            return Object.defineProperties(asset, {
                info: {
                    value: AssetInfo_1.JsAssetInfo.__from_binding(asset.info)
                },
                source: {
                    get: () => this.__internal__getAssetSource(asset.name)
                }
            });
        });
    }
    getAsset(name) {
        const asset = __classPrivateFieldGet(this, _Compilation_inner, "f").getAsset(name);
        if (!asset) {
            return;
        }
        return Object.defineProperties(asset, {
            info: {
                value: AssetInfo_1.JsAssetInfo.__from_binding(asset.info)
            },
            source: {
                get: () => this.__internal__getAssetSource(asset.name)
            }
        });
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__pushRspackDiagnostic(diagnostic) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").pushDiagnostic(diagnostic);
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__pushDiagnostic(diagnostic) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").pushNativeDiagnostic(diagnostic);
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__pushDiagnostics(diagnostics) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").pushNativeDiagnostics(diagnostics);
    }
    get errors() {
        const inner = __classPrivateFieldGet(this, _Compilation_inner, "f");
        const errors = inner.getErrors();
        const proxyMethod = [
            {
                method: "push",
                handler(target, thisArg, errs) {
                    for (let i = 0; i < errs.length; i++) {
                        const error = errs[i];
                        inner.pushDiagnostic(RspackError_1.JsRspackDiagnostic.__to_binding(error, binding_1.JsRspackSeverity.Error));
                    }
                    return Reflect.apply(target, thisArg, errs);
                }
            },
            {
                method: "pop",
                handler(target, thisArg) {
                    inner.spliceDiagnostic(errors.length - 1, errors.length, []);
                    return Reflect.apply(target, thisArg, []);
                }
            },
            {
                method: "shift",
                handler(target, thisArg) {
                    inner.spliceDiagnostic(0, 1, []);
                    return Reflect.apply(target, thisArg, []);
                }
            },
            {
                method: "unshift",
                handler(target, thisArg, errs) {
                    const errList = errs.map(error => {
                        return RspackError_1.JsRspackDiagnostic.__to_binding(error, binding_1.JsRspackSeverity.Error);
                    });
                    inner.spliceDiagnostic(0, 0, errList);
                    return Reflect.apply(target, thisArg, errs);
                }
            },
            {
                method: "splice",
                handler(target, thisArg, [startIdx, delCount, ...errors]) {
                    const errList = errors.map(error => {
                        return RspackError_1.JsRspackDiagnostic.__to_binding(error, binding_1.JsRspackSeverity.Error);
                    });
                    inner.spliceDiagnostic(startIdx, startIdx + delCount, errList);
                    return Reflect.apply(target, thisArg, [
                        startIdx,
                        delCount,
                        ...errors
                    ]);
                }
            }
        ];
        for (const item of proxyMethod) {
            const proxiedMethod = new Proxy(errors[item.method], {
                apply: item.handler
            });
            errors[item.method] = proxiedMethod;
        }
        return errors;
    }
    get warnings() {
        const inner = __classPrivateFieldGet(this, _Compilation_inner, "f");
        const processWarningsHook = this.hooks.processWarnings;
        const warnings = inner.getWarnings();
        const proxyMethod = [
            {
                method: "push",
                handler(target, thisArg, warns) {
                    return Reflect.apply(target, thisArg, processWarningsHook.call(warns).map(warn => {
                        inner.pushDiagnostic(RspackError_1.JsRspackDiagnostic.__to_binding(warn, binding_1.JsRspackSeverity.Warn));
                        return warn;
                    }));
                }
            },
            {
                method: "pop",
                handler(target, thisArg) {
                    inner.spliceDiagnostic(warnings.length - 1, warnings.length, []);
                    return Reflect.apply(target, thisArg, []);
                }
            },
            {
                method: "shift",
                handler(target, thisArg) {
                    inner.spliceDiagnostic(0, 1, []);
                    return Reflect.apply(target, thisArg, []);
                }
            },
            {
                method: "unshift",
                handler(target, thisArg, warns) {
                    const warnings = processWarningsHook.call(warns);
                    inner.spliceDiagnostic(0, 0, warnings.map(warn => {
                        return RspackError_1.JsRspackDiagnostic.__to_binding(warn, binding_1.JsRspackSeverity.Warn);
                    }));
                    return Reflect.apply(target, thisArg, warnings);
                }
            },
            {
                method: "splice",
                handler(target, thisArg, [startIdx, delCount, ...warns]) {
                    warns = processWarningsHook.call(warns);
                    const warnList = warns.map(warn => {
                        return RspackError_1.JsRspackDiagnostic.__to_binding(warn, binding_1.JsRspackSeverity.Warn);
                    });
                    inner.spliceDiagnostic(startIdx, startIdx + delCount, warnList);
                    return Reflect.apply(target, thisArg, [
                        startIdx,
                        delCount,
                        ...warnList
                    ]);
                }
            }
        ];
        for (const item of proxyMethod) {
            const proxiedMethod = new Proxy(warnings[item.method], {
                apply: item.handler
            });
            warnings[item.method] = proxiedMethod;
        }
        return warnings;
    }
    getPath(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getPath(filename, {
            ...data,
            chunk: data.chunk instanceof Chunk_1.Chunk
                ? data.chunk.__internal_to_path_data_chunk()
                : data.chunk
        });
    }
    getPathWithInfo(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getPathWithInfo(filename, {
            ...data,
            chunk: data.chunk instanceof Chunk_1.Chunk
                ? data.chunk.__internal_to_path_data_chunk()
                : data.chunk
        });
    }
    getAssetPath(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetPath(filename, {
            ...data,
            chunk: data.chunk instanceof Chunk_1.Chunk
                ? data.chunk.__internal_to_path_data_chunk()
                : data.chunk
        });
    }
    getAssetPathWithInfo(filename, data = {}) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetPathWithInfo(filename, {
            ...data,
            chunk: data.chunk instanceof Chunk_1.Chunk
                ? data.chunk.__internal_to_path_data_chunk()
                : data.chunk
        });
    }
    getLogger(name) {
        if (!name) {
            throw new TypeError("Compilation.getLogger(name) called without a name");
        }
        let logName = name;
        let logEntries;
        return new Logger_1.Logger((type, args) => {
            if (typeof logName === "function") {
                logName = logName();
                if (!logName) {
                    throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
                }
            }
            let trace;
            switch (type) {
                case Logger_1.LogType.warn:
                case Logger_1.LogType.error:
                case Logger_1.LogType.trace:
                    trace = (0, ErrorHelpers_1.cutOffLoaderExecution)(new Error("Trace").stack)
                        .split("\n")
                        .slice(3);
                    break;
            }
            const logEntry = {
                time: Date.now(),
                type,
                args,
                trace
            };
            if (this.hooks.log.call(logName, logEntry) === undefined) {
                if (logEntry.type === Logger_1.LogType.profileEnd) {
                    if (typeof console.profileEnd === "function") {
                        console.profileEnd(`[${logName}] ${logEntry.args[0]}`);
                    }
                }
                if (logEntries === undefined) {
                    logEntries = this.logging.get(logName);
                    if (logEntries === undefined) {
                        logEntries = [];
                        this.logging.set(logName, logEntries);
                    }
                }
                logEntries.push(logEntry);
                if (logEntry.type === Logger_1.LogType.profile) {
                    if (typeof console.profile === "function") {
                        console.profile(`[${logName}] ${logEntry.args[0]}`);
                    }
                }
            }
        }, (childName) => {
            let normalizedChildName = childName;
            if (typeof logName === "function") {
                if (typeof normalizedChildName === "function") {
                    return this.getLogger(() => {
                        if (typeof logName === "function") {
                            logName = logName();
                            if (!logName) {
                                throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
                            }
                        }
                        if (typeof normalizedChildName === "function") {
                            normalizedChildName = normalizedChildName();
                            if (!normalizedChildName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${logName}/${normalizedChildName}`;
                    });
                }
                return this.getLogger(() => {
                    if (typeof logName === "function") {
                        logName = logName();
                        if (!logName) {
                            throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
                        }
                    }
                    return `${logName}/${normalizedChildName}`;
                });
            }
            if (typeof normalizedChildName === "function") {
                return this.getLogger(() => {
                    if (typeof normalizedChildName === "function") {
                        normalizedChildName = normalizedChildName();
                        if (!normalizedChildName) {
                            throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                        }
                    }
                    return `${logName}/${normalizedChildName}`;
                });
            }
            return this.getLogger(`${logName}/${normalizedChildName}`);
        });
    }
    getStats() {
        return new Stats_1.Stats(this);
    }
    createChildCompiler(name, outputOptions, plugins) {
        const idx = this.childrenCounters[name] || 0;
        this.childrenCounters[name] = idx + 1;
        return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);
    }
    rebuildModule(m, f) {
        __classPrivateFieldGet(this, _Compilation_rebuildModuleCaller, "f").push([m.identifier(), f]);
    }
    addRuntimeModule(chunk, runtimeModule) {
        runtimeModule.attach(this, chunk, this.chunkGraph);
        __classPrivateFieldGet(this, _Compilation_inner, "f").addRuntimeModule(chunk.__internal__innerUkey(), RuntimeModule_1.RuntimeModule.__to_binding(this, runtimeModule));
    }
    /**
     * Get the `Source` of a given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in the future.
     *
     * @internal
     */
    __internal__getAssetSource(filename) {
        const rawSource = __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetSource(filename);
        if (!rawSource) {
            return;
        }
        return source_1.JsSource.__from_binding(rawSource);
    }
    /**
     * Set the `Source` of an given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__setAssetSource(filename, source) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").setAssetSource(filename, source_1.JsSource.__to_binding(source));
    }
    /**
     * Delete the `Source` of an given asset filename.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__deleteAssetSource(filename) {
        __classPrivateFieldGet(this, _Compilation_inner, "f").deleteAssetSource(filename);
    }
    /**
     * Get a list of asset filenames.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getAssetFilenames() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").getAssetFilenames();
    }
    /**
     * Test if an asset exists.
     *
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__hasAsset(name) {
        return __classPrivateFieldGet(this, _Compilation_inner, "f").hasAsset(name);
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal__getChunks() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f")
            .getChunks()
            .map(c => Chunk_1.Chunk.__from_binding(c, __classPrivateFieldGet(this, _Compilation_inner, "f")));
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     *
     * @internal
     */
    __internal_getInner() {
        return __classPrivateFieldGet(this, _Compilation_inner, "f");
    }
    seal() { }
    unseal() { }
}
_Compilation_inner = new WeakMap(), _Compilation_customModules = new WeakMap(), _Compilation_rebuildModuleCaller = new WeakMap(), _Compilation_instances = new WeakSet(), _Compilation_createCachedAssets = function _Compilation_createCachedAssets() {
    return new Proxy({}, {
        get: (_, property) => {
            if (typeof property === "string") {
                return this.__internal__getAssetSource(property);
            }
        },
        set: (_, p, newValue) => {
            if (typeof p === "string") {
                this.__internal__setAssetSource(p, newValue);
                return true;
            }
            return false;
        },
        deleteProperty: (_, p) => {
            if (typeof p === "string") {
                this.__internal__deleteAssetSource(p);
                return true;
            }
            return false;
        },
        has: (_, property) => {
            if (typeof property === "string") {
                return this.__internal__hasAsset(property);
            }
            return false;
        },
        ownKeys: _ => {
            return this.__internal__getAssetFilenames();
        },
        getOwnPropertyDescriptor() {
            // To work with `Object.keys`, you should mark the property as enumerable.
            // See: https://262.ecma-international.org/7.0/#sec-enumerableownnames
            return {
                enumerable: true,
                configurable: true
            };
        }
    });
};
Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL = -2000;
Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS = -1000;
Compilation.PROCESS_ASSETS_STAGE_DERIVED = -200;
Compilation.PROCESS_ASSETS_STAGE_ADDITIONS = -100;
Compilation.PROCESS_ASSETS_STAGE_NONE = 0;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE = 100;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT = 200;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY = 300;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE = 400;
Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING = 500;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE = 700;
Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE = 1000;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH = 2500;
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER = 3000;
Compilation.PROCESS_ASSETS_STAGE_ANALYSE = 4000;
Compilation.PROCESS_ASSETS_STAGE_REPORT = 5000;
exports.Compilation = Compilation;
class Entries {
    constructor(data) {
        _Entries_data.set(this, void 0);
        __classPrivateFieldSet(this, _Entries_data, data, "f");
    }
    clear() {
        __classPrivateFieldGet(this, _Entries_data, "f").clear();
    }
    forEach(callback, thisArg) {
        for (const [key, value] of this) {
            callback.call(thisArg, value, key, this);
        }
    }
    get size() {
        return __classPrivateFieldGet(this, _Entries_data, "f").size;
    }
    entries() {
        const self = this;
        const keys = this.keys();
        return {
            [Symbol.iterator]() {
                return this;
            },
            next() {
                const { done, value } = keys.next();
                return {
                    done,
                    value: done ? undefined : [value, self.get(value)]
                };
            }
        };
    }
    values() {
        return __classPrivateFieldGet(this, _Entries_data, "f").values()[Symbol.iterator]();
    }
    [(_Entries_data = new WeakMap(), Symbol.iterator)]() {
        return this.entries();
    }
    get [Symbol.toStringTag]() {
        return "Map";
    }
    has(key) {
        return __classPrivateFieldGet(this, _Entries_data, "f").has(key);
    }
    set(key, value) {
        __classPrivateFieldGet(this, _Entries_data, "f").set(key, value);
        return this;
    }
    delete(key) {
        return __classPrivateFieldGet(this, _Entries_data, "f").delete(key);
    }
    get(key) {
        return __classPrivateFieldGet(this, _Entries_data, "f").get(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _Entries_data, "f").keys()[Symbol.iterator]();
    }
}
exports.Entries = Entries;
