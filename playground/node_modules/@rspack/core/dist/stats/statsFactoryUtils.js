"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorsSpaceLimit = exports.resolveStatsMillisecond = exports.mergeToObject = exports.moduleGroup = exports.assetGroup = exports.sortByField = exports.countWithChildren = exports.spaceLimited = exports.collapse = exports.getTotalItems = exports.iterateConfig = exports.uniqueOrderedArray = exports.uniqueArray = void 0;
const comparators_1 = require("../util/comparators");
const uniqueArray = (items, selector) => {
    const set = new Set();
    for (const item of items) {
        for (const i of selector(item)) {
            set.add(i);
        }
    }
    return Array.from(set);
};
exports.uniqueArray = uniqueArray;
const uniqueOrderedArray = (items, selector, comparator) => {
    return (0, exports.uniqueArray)(items, selector).sort(comparator);
};
exports.uniqueOrderedArray = uniqueOrderedArray;
const iterateConfig = (config, options, fn) => {
    for (const hookFor of Object.keys(config)) {
        const subConfig = config[hookFor];
        for (const option of Object.keys(subConfig)) {
            if (option !== "_") {
                if (option.startsWith("!")) {
                    if (
                    // string cannot be used as key, so use "as"
                    options[option.slice(1)])
                        continue;
                }
                else {
                    const value = options[option];
                    if (value === false ||
                        value === undefined ||
                        (Array.isArray(value) && value.length === 0))
                        continue;
                }
            }
            fn(hookFor, subConfig[option]);
        }
    }
};
exports.iterateConfig = iterateConfig;
const getTotalItems = (children) => {
    let count = 0;
    for (const child of children) {
        if (!child.children && !child.filteredChildren) {
            count++;
        }
        else {
            if (child.children)
                count += (0, exports.getTotalItems)(child.children);
            if (child.filteredChildren)
                count += child.filteredChildren;
        }
    }
    return count;
};
exports.getTotalItems = getTotalItems;
const collapse = (children) => {
    // After collapse each child must take exactly one line
    const newChildren = [];
    for (const child of children) {
        if (child.children) {
            let filteredChildren = child.filteredChildren || 0;
            filteredChildren += (0, exports.getTotalItems)(child.children);
            newChildren.push({
                ...child,
                children: undefined,
                filteredChildren
            });
        }
        else {
            newChildren.push(child);
        }
    }
    return newChildren;
};
exports.collapse = collapse;
const getTotalSize = (children) => {
    let size = 0;
    for (const child of children) {
        size += getItemSize(child);
    }
    return size;
};
const getItemSize = (item) => {
    // Each item takes 1 line
    // + the size of the children
    // + 1 extra line when it has children and filteredChildren
    return !item.children
        ? 1
        : item.filteredChildren
            ? 2 + getTotalSize(item.children)
            : 1 + getTotalSize(item.children);
};
const spaceLimited = (itemsAndGroups, max, filteredChildrenLineReserved = false) => {
    if (max < 1) {
        return {
            children: undefined,
            filteredChildren: (0, exports.getTotalItems)(itemsAndGroups)
        };
    }
    let children = undefined;
    let filteredChildren = undefined;
    // This are the groups, which take 1+ lines each
    const groups = [];
    // The sizes of the groups are stored in groupSizes
    const groupSizes = [];
    // This are the items, which take 1 line each
    const items = [];
    // The total of group sizes
    let groupsSize = 0;
    for (const itemOrGroup of itemsAndGroups) {
        // is item
        if (!itemOrGroup.children && !itemOrGroup.filteredChildren) {
            items.push(itemOrGroup);
        }
        else {
            groups.push(itemOrGroup);
            const size = getItemSize(itemOrGroup);
            groupSizes.push(size);
            groupsSize += size;
        }
    }
    if (groupsSize + items.length <= max) {
        // The total size in the current state fits into the max
        // keep all
        children = groups.length > 0 ? groups.concat(items) : items;
    }
    else if (groups.length === 0) {
        // slice items to max
        // inner space marks that lines for filteredChildren already reserved
        const limit = max - (filteredChildrenLineReserved ? 0 : 1);
        filteredChildren = items.length - limit;
        items.length = limit;
        children = items;
    }
    else {
        // limit is the size when all groups are collapsed
        const limit = groups.length +
            (filteredChildrenLineReserved || items.length === 0 ? 0 : 1);
        if (limit < max) {
            // calculate how much we are over the size limit
            // this allows to approach the limit faster
            let oversize;
            // If each group would take 1 line the total would be below the maximum
            // collapse some groups, keep items
            while ((oversize =
                groupsSize +
                    items.length +
                    (filteredChildren && !filteredChildrenLineReserved ? 1 : 0) -
                    max) > 0) {
                // Find the maximum group and process only this one
                const maxGroupSize = Math.max(...groupSizes);
                if (maxGroupSize < items.length) {
                    filteredChildren = items.length;
                    items.length = 0;
                    continue;
                }
                for (let i = 0; i < groups.length; i++) {
                    if (groupSizes[i] === maxGroupSize) {
                        const group = groups[i];
                        // run this algorithm recursively and limit the size of the children to
                        // current size - oversize / number of groups
                        // So it should always end up being smaller
                        const headerSize = group.filteredChildren ? 2 : 1;
                        const limited = (0, exports.spaceLimited)(group.children, maxGroupSize -
                            // we should use ceil to always feet in max
                            Math.ceil(oversize / groups.length) -
                            // we substitute size of group head
                            headerSize, headerSize === 2);
                        groups[i] = {
                            ...group,
                            children: limited.children,
                            filteredChildren: limited.filteredChildren
                                ? (group.filteredChildren || 0) + limited.filteredChildren
                                : group.filteredChildren
                        };
                        const newSize = getItemSize(groups[i]);
                        groupsSize -= maxGroupSize - newSize;
                        groupSizes[i] = newSize;
                        break;
                    }
                }
            }
            children = groups.concat(items);
        }
        else if (limit === max) {
            // If we have only enough space to show one line per group and one line for the filtered items
            // collapse all groups and items
            children = (0, exports.collapse)(groups);
            filteredChildren = items.length;
        }
        else {
            // If we have no space
            // collapse complete group
            filteredChildren = (0, exports.getTotalItems)(itemsAndGroups);
        }
    }
    return {
        children,
        filteredChildren
    };
};
exports.spaceLimited = spaceLimited;
const countWithChildren = (compilation, getItems) => {
    let count = getItems(compilation, "").length;
    for (const child of compilation.children) {
        count += (0, exports.countWithChildren)(child, (c, type) => getItems(c, `.children[].compilation${type}`));
    }
    return count;
};
exports.countWithChildren = countWithChildren;
// remove a prefixed "!" that can be specified to reverse sort order
const normalizeFieldKey = (field) => {
    if (field[0] === "!") {
        return field.slice(1);
    }
    return field;
};
// if a field is prefixed by a "!" reverse sort order
const sortOrderRegular = (field) => {
    if (field[0] === "!") {
        return false;
    }
    return true;
};
const sortByField = (field) => {
    if (!field) {
        const noSort = (_a, _b) => 0;
        return noSort;
    }
    const fieldKey = normalizeFieldKey(field);
    let sortFn = (0, comparators_1.compareSelect)((m) => m[fieldKey], comparators_1.compareIds);
    // if a field is prefixed with a "!" the sort is reversed!
    const sortIsRegular = sortOrderRegular(field);
    if (!sortIsRegular) {
        const oldSortFn = sortFn;
        sortFn = (a, b) => oldSortFn(b, a);
    }
    return sortFn;
};
exports.sortByField = sortByField;
const assetGroup = (children) => {
    let size = 0;
    for (const asset of children) {
        size += asset.size;
    }
    return {
        size
    };
};
exports.assetGroup = assetGroup;
const moduleGroup = (children) => {
    let size = 0;
    const sizes = {};
    for (const module of children) {
        size += module.size;
        for (const key of Object.keys(module.sizes)) {
            sizes[key] = (sizes[key] || 0) + module.sizes[key];
        }
    }
    return {
        size,
        sizes
    };
};
exports.moduleGroup = moduleGroup;
const mergeToObject = (items) => {
    const obj = Object.create(null);
    for (const item of items) {
        obj[item.name] = item;
    }
    return obj;
};
exports.mergeToObject = mergeToObject;
function resolveStatsMillisecond(s) {
    return s.secs * 1000 + s.subsecMillis;
}
exports.resolveStatsMillisecond = resolveStatsMillisecond;
const errorsSpaceLimit = (errors, max) => {
    let filtered = 0;
    // Can not fit into limit
    // print only messages
    if (errors.length + 1 >= max) {
        return {
            errors: errors.map(error => {
                if (typeof error === "string" || !error.details)
                    return error;
                filtered++;
                return { ...error, details: "" };
            }),
            filtered
        };
    }
    let fullLength = errors.length;
    let result = errors;
    let i = 0;
    for (; i < errors.length; i++) {
        const error = errors[i];
        if (typeof error !== "string" && error.details) {
            const splitted = error.details.split("\n");
            const len = splitted.length;
            fullLength += len;
            if (fullLength > max) {
                result = i > 0 ? errors.slice(0, i) : [];
                const overLimit = fullLength - max + 1;
                const error = errors[i++];
                result.push({
                    ...error,
                    details: error.details.split("\n").slice(0, -overLimit).join("\n"),
                    filteredDetails: overLimit
                });
                filtered = errors.length - i;
                for (; i < errors.length; i++) {
                    const error = errors[i];
                    if (typeof error === "string" || !error.details)
                        result.push(error);
                    result.push({ ...error, details: "" });
                }
                break;
            }
            if (fullLength === max) {
                result = errors.slice(0, ++i);
                filtered = errors.length - i;
                for (; i < errors.length; i++) {
                    const error = errors[i];
                    if (typeof error === "string" || !error.details)
                        result.push(error);
                    result.push({ ...error, details: "" });
                }
                break;
            }
        }
    }
    return {
        errors: result,
        filtered
    };
};
exports.errorsSpaceLimit = errorsSpaceLimit;
