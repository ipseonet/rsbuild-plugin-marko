"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsFactory = void 0;
const lite_tapable_1 = require("@rspack/lite-tapable");
const comparators_1 = require("../util/comparators");
const smartGrouping_1 = require("../util/smartGrouping");
class StatsFactory {
    constructor() {
        this.hooks = Object.freeze({
            extract: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook([
                "object",
                "data",
                "context"
            ])),
            filter: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook(["item", "context", "index", "unfilteredIndex"])),
            sort: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook(["comparators", "context"])),
            filterSorted: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook(["item", "context", "index", "unfilteredIndex"])),
            groupResults: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook(["groupConfigs", "context"])),
            sortResults: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook(["comparators", "context"])),
            filterResults: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook(["item", "context", "index", "unfilteredIndex"])),
            merge: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook([
                "items",
                "context"
            ])),
            result: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncWaterfallHook([
                "result",
                "context"
            ])),
            getItemName: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook([
                "item",
                "context"
            ])),
            getItemFactory: new lite_tapable_1.HookMap(() => new lite_tapable_1.SyncBailHook([
                "item",
                "context"
            ]))
        });
        const hooks = this.hooks;
        const caches = {};
        for (const key of Object.keys(hooks)) {
            caches[key] = new Map();
        }
        this._caches = caches;
        this._inCreate = false;
    }
    _getAllLevelHooks(hookMap, cache, type) {
        const cacheEntry = cache.get(type);
        if (cacheEntry !== undefined) {
            return cacheEntry;
        }
        const hooks = [];
        const typeParts = type.split(".");
        for (let i = 0; i < typeParts.length; i++) {
            const hook = hookMap.get(typeParts.slice(i).join("."));
            if (hook) {
                hooks.push(hook);
            }
        }
        cache.set(type, hooks);
        return hooks;
    }
    _forEachLevel(hookMap, cache, type, fn) {
        for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {
            const result = fn(hook);
            if (result !== undefined)
                return result;
        }
    }
    _forEachLevelWaterfall(hookMap, cache, type, data, fn) {
        return this._getAllLevelHooks(hookMap, cache, type).reduce((data, hook) => {
            return fn(hook, data);
        }, data);
    }
    _forEachLevelFilter(hookMap, cache, type, items, fn, forceClone) {
        const hooks = this._getAllLevelHooks(hookMap, cache, type);
        if (hooks.length === 0)
            return forceClone ? items.slice() : items;
        let i = 0;
        return items.filter((item, idx) => {
            for (const hook of hooks) {
                const r = fn(hook, item, idx, i);
                if (r !== undefined) {
                    if (r)
                        i++;
                    return r;
                }
            }
            i++;
            return true;
        });
    }
    create(type, data, baseContext) {
        if (this._inCreate) {
            return this._create(type, data, baseContext);
        }
        try {
            this._inCreate = true;
            return this._create(type, data, baseContext);
        }
        finally {
            for (const key of Object.keys(this._caches))
                this._caches[key].clear();
            this._inCreate = false;
        }
    }
    _create(type, data, baseContext) {
        const context = {
            ...baseContext,
            type,
            [type]: data
        };
        if (Array.isArray(data)) {
            // run filter on unsorted items
            const items = this._forEachLevelFilter(this.hooks.filter, this._caches.filter, type, data, (h, r, idx, i) => h.call(r, context, idx, i), true);
            // sort items
            const comparators = [];
            this._forEachLevel(this.hooks.sort, this._caches.sort, type, h => h.call(comparators, context));
            if (comparators.length > 0) {
                items.sort((0, comparators_1.concatComparators)(...comparators));
            }
            // run filter on sorted items
            const items2 = this._forEachLevelFilter(this.hooks.filterSorted, this._caches.filterSorted, type, items, (h, r, idx, i) => h.call(r, context, idx, i), false);
            // for each item
            let resultItems = items2.map((item, i) => {
                const itemContext = {
                    ...context,
                    _index: i
                };
                // run getItemName
                const itemName = this._forEachLevel(this.hooks.getItemName, this._caches.getItemName, `${type}[]`, h => h.call(item, itemContext));
                if (itemName)
                    itemContext[itemName] = item;
                const innerType = itemName ? `${type}[].${itemName}` : `${type}[]`;
                // run getItemFactory
                const itemFactory = this._forEachLevel(this.hooks.getItemFactory, this._caches.getItemFactory, innerType, h => h.call(item, itemContext)) || this;
                // run item factory
                return itemFactory.create(innerType, item, itemContext);
            });
            // sort result items
            const comparators2 = [];
            this._forEachLevel(this.hooks.sortResults, this._caches.sortResults, type, h => h.call(comparators2, context));
            if (comparators2.length > 0) {
                resultItems.sort((0, comparators_1.concatComparators)(...comparators2));
            }
            // group result items
            const groupConfigs = [];
            this._forEachLevel(this.hooks.groupResults, this._caches.groupResults, type, h => h.call(groupConfigs, context));
            if (groupConfigs.length > 0) {
                resultItems = (0, smartGrouping_1.smartGrouping)(resultItems, groupConfigs);
            }
            // run filter on sorted result items
            const finalResultItems = this._forEachLevelFilter(this.hooks.filterResults, this._caches.filterResults, type, resultItems, (h, r, idx, i) => h.call(r, context, idx, i), false);
            // run merge on mapped items
            let result = this._forEachLevel(this.hooks.merge, this._caches.merge, type, h => h.call(finalResultItems, context));
            if (result === undefined)
                result = finalResultItems;
            // run result on merged items
            return this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, result, (h, r) => h.call(r, context));
        }
        const object = {};
        // run extract on value
        this._forEachLevel(this.hooks.extract, this._caches.extract, type, h => h.call(object, data, context));
        // run result on extracted object
        return this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, object, (h, r) => h.call(r, context));
    }
}
exports.StatsFactory = StatsFactory;
