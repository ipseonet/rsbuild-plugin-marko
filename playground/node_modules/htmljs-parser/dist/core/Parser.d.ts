import { STATE, type Range, type ParserOptions as Options, ErrorCode } from "../internal";
export interface Meta extends Range {
    parent: Meta;
    state: StateDefinition;
}
export interface StateDefinition<P extends Meta = Meta> {
    name: string;
    enter: (this: Parser, parent: Meta, pos: number) => Partial<P & {
        state: unknown;
    }>;
    exit: (this: Parser, activeRange: P) => void;
    char: (this: Parser, code: number, activeRange: P) => void;
    eol: (this: Parser, length: number, activeRange: P) => void;
    eof: (this: Parser, activeRange: P) => void;
    return: (this: Parser, child: Meta, activeRange: P) => void;
}
export declare class Parser {
    options: Options;
    pos: number;
    maxPos: number;
    data: string;
    activeState: StateDefinition;
    activeRange: Meta;
    forward: number;
    activeTag: STATE.OpenTagMeta | undefined;
    activeAttr: STATE.AttrMeta | undefined;
    indent: string;
    isConcise: boolean;
    beginMixedMode?: boolean;
    endingMixedModeAtEOL?: boolean;
    textPos: number;
    lines: undefined | number[];
    constructor(options: Options);
    read(range: Range): string;
    positionAt(offset: number): import("../internal").Position;
    locationAt(range: Range): import("../internal").Location;
    enterState<P extends Meta>(state: StateDefinition<P>): P;
    exitState(): void;
    /**
     * Compare a position in the source to either another position, or a string.
     */
    matchAtPos(a: Range, b: Range | string): boolean;
    matchAnyAtPos(a: Range, list: (Range | string)[]): boolean;
    /**
     * Look ahead to see if the given str matches the substring sequence
     * beyond
     */
    lookAheadFor(str: string, startPos?: number): string | undefined;
    lookAtCharCodeAhead(offset: number, startPos?: number): number;
    startText(): void;
    endText(): void;
    /**
     * This is used to enter into "HTML" parsing mode instead
     * of concise HTML. We push a block on to the stack so that we know when
     * return back to the previous parsing mode and to ensure that all
     * tags within a block are properly closed.
     */
    beginHtmlBlock(delimiter: string | undefined, singleLine: boolean): void;
    emitError(range: number | Range, code: ErrorCode, message: string): void;
    closeTagEnd(start: number, end: number, name: Range | undefined): void;
    consumeWhitespaceIfBefore(str: string, start?: number): boolean;
    getPreviousNonWhitespaceCharCode(start?: number): number;
    onlyWhitespaceRemainsOnLine(start?: number): boolean;
    consumeWhitespaceOnLine(start?: number): boolean;
    consumeWhitespace(): void;
    parse(data: string): void;
}
