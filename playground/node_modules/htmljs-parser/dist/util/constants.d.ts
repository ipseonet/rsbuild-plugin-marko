export declare const enum CODE {
    NUMBER_0 = 48,
    NUMBER_9 = 57,
    UPPER_A = 65,
    UPPER_Z = 90,
    LOWER_A = 97,
    LOWER_Z = 122,
    BACK_SLASH = 92,
    FORWARD_SLASH = 47,
    OPEN_ANGLE_BRACKET = 60,
    CLOSE_ANGLE_BRACKET = 62,
    EXCLAMATION = 33,
    QUESTION = 63,
    OPEN_SQUARE_BRACKET = 91,
    CLOSE_SQUARE_BRACKET = 93,
    EQUAL = 61,
    SINGLE_QUOTE = 39,
    DOUBLE_QUOTE = 34,
    BACKTICK = 96,
    OPEN_PAREN = 40,
    CLOSE_PAREN = 41,
    OPEN_CURLY_BRACE = 123,
    CLOSE_CURLY_BRACE = 125,
    ASTERISK = 42,
    HYPHEN = 45,
    DOLLAR = 36,
    PERCENT = 37,
    PERIOD = 46,
    PLUS = 43,
    COMMA = 44,
    COLON = 58,
    SEMICOLON = 59,
    NUMBER_SIGN = 35,
    PIPE = 124,
    NEWLINE = 10,
    CARRIAGE_RETURN = 13,
    SPACE = 32,
    TAB = 9,
    AMPERSAND = 38,
    CARET = 94,
    TILDE = 126,
    UNDERSCORE = 95
}
export interface Position {
    /**
     * Line position in a document (zero-based).
     */
    line: number;
    /**
     * Character offset on a line in a document (zero-based).
     */
    character: number;
}
export interface Location {
    start: Position;
    end: Position;
}
export interface Range {
    /**
     * The start characters offset from the beginning of the document (zero-based).
     */
    start: number;
    /**
     * The end characters offset from the beginning of the document (zero-based).
     */
    end: number;
}
export declare namespace Ranges {
    interface Value extends Range {
        value: Range;
    }
    interface Template extends Range {
        expressions: Value[];
        quasis: Range[];
    }
    interface Error extends Range {
        code: ErrorCode;
        message: string;
    }
    interface Scriptlet extends Value {
        block: boolean;
    }
    interface Placeholder extends Value {
        escape: boolean;
    }
    interface AttrValue extends Value {
        bound: boolean;
    }
    interface AttrMethod extends Range {
        body: Value;
        params: Value;
        typeParams: Value | undefined;
    }
    interface OpenTagEnd extends Range {
        selfClosed: boolean;
    }
}
export declare enum ErrorCode {
    EXTRA_CLOSING_TAG = 0,
    INVALID_ATTRIBUTE_ARGUMENT = 1,
    INVALID_ATTRIBUTE_NAME = 2,
    INVALID_ATTRIBUTE_VALUE = 3,
    INVALID_CHARACTER = 4,
    INVALID_CODE_AFTER_SEMICOLON = 5,
    INVALID_EXPRESSION = 6,
    INVALID_INDENTATION = 7,
    INVALID_LINE_START = 8,
    INVALID_REGULAR_EXPRESSION = 9,
    INVALID_STRING = 10,
    INVALID_TAG_ARGUMENT = 11,
    INVALID_TAG_SHORTHAND = 12,
    INVALID_TEMPLATE_STRING = 13,
    MALFORMED_CDATA = 14,
    MALFORMED_CLOSE_TAG = 15,
    MALFORMED_COMMENT = 16,
    MALFORMED_DECLARATION = 17,
    MALFORMED_DOCUMENT_TYPE = 18,
    MALFORMED_OPEN_TAG = 19,
    MALFORMED_PLACEHOLDER = 20,
    MISMATCHED_CLOSING_TAG = 21,
    MISSING_END_TAG = 22,
    MISSING_TAG_VARIABLE = 23,
    RESERVED_TAG_NAME = 24,
    ROOT_TAG_ONLY = 25,
    INVALID_TAG_PARAMS = 26,
    INVALID_TAG_TYPES = 27,
    INVALID_ATTR_TYPE_PARAMS = 28
}
export declare const enum TagType {
    html = 0,
    text = 1,
    void = 2,
    statement = 3
}
export interface ParserOptions {
    onError?(data: Ranges.Error): void;
    onText?(data: Range): void;
    onPlaceholder?(data: Ranges.Placeholder): void;
    onComment?(data: Ranges.Value): void;
    onCDATA?(data: Ranges.Value): void;
    onDeclaration?(data: Ranges.Value): void;
    onDoctype?(data: Ranges.Value): void;
    onScriptlet?(data: Ranges.Scriptlet): void;
    onOpenTagStart?(data: Range): void;
    onOpenTagName?(data: Ranges.Template): TagType | void;
    onTagShorthandId?(data: Ranges.Template): void;
    onTagShorthandClass?(data: Ranges.Template): void;
    onTagTypeArgs?(data: Ranges.Value): void;
    onTagVar?(data: Ranges.Value): void;
    onTagArgs?(data: Ranges.Value): void;
    onTagTypeParams?(data: Ranges.Value): void;
    onTagParams?(data: Ranges.Value): void;
    onAttrName?(data: Range): void;
    onAttrArgs?(data: Ranges.Value): void;
    onAttrValue?(data: Ranges.AttrValue): void;
    onAttrMethod?(data: Ranges.AttrMethod): void;
    onAttrSpread?(data: Ranges.Value): void;
    onOpenTagEnd?(data: Ranges.OpenTagEnd): void;
    onCloseTagStart?(data: Range): void;
    onCloseTagName?(data: Range): void;
    onCloseTagEnd?(data: Range): void;
}
